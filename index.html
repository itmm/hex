<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>index.x</title>
<link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>HTML Extractor</h1>
<div class="slides">
<div>
<div>
<h1>HTML Extractor</h1>
</div>
<ul><li>
This presentation is the program <b>HTML Extractor</b> (<code><span class="var">hx</span></code>)
</li><li>
It contains all source code that is needed to build the executable
</li><li>
But the code is spread over multiple slides
</li><li>
To form an extreme form of Literate Programming
</li><li>
that I call <b>Slideware-Programming</b> (SWP)
</li><li>
Have fun!
</li></ul>
</div>
</div>
<h2>What is <code><span class="var">hx</span></code>?</h2>
<div class="slides">
<div>
<div>
<h2>What is <code><span class="var">hx</span></code>?</h2>
</div>
<ul><li>
<code><span class="var">hx</span></code> is a program that parses a <code><span class="var">x</span></code>-document and extracts source
  code or an executable program out of it
</li><li>
Think of it as a very powerful macro processor that combines, extends
  and orders small fragments of code
</li><li>
But also it generates a HTML documentation like the one you are
  currently reading
</li></ul>
</div>
</div>
<h2>What is a <code><span class="var">x</span></code>-document?</h2>
<div class="slides">
<div>
<div>
<h2>What is a <code><span class="var">x</span></code>-document?</h2>
</div>
<ul><li>
<code><span class="var">x</span></code>-documents are text documents with a markdown-like syntax
</li><li>
It contains sections at different levels, paragraphs and code snippets
</li><li>
The sections and code snippets are automatically formatted as slides
  of a very big slide show
</li><li>
These slides can be decorated with notes
</li></ul>
</div>
</div>
<h2>SWP ≠ Literate Programming</h2>
<div class="slides">
<div>
<div>
<h2>SWP ≠ Literate Programming</h2>
</div>
<ul><li>
SWP should not document a finished program
</li><li>
but it should document the process of creating a program instead
</li><li>
After every slide you can generate the code from all the slides that
  you have read
</li><li>
and without peeking in the future a runnable program must result
</li><li>
So it does not contain features that are described the later slides
</li></ul>
</div>
</div>
<h2>A very top-down view of <code><span class="var">hx</span></code></h2>
<div class="slides">
<div>
<div>
<h2>A very top-down view of <code><span class="var">hx</span></code></h2>
</div>
<ul><li>
In the first code slide contains the highest view of the <code><span class="var">hx</span></code> program
</li><li>
While not very interesting, it contains a lot of commands that show
  how <code><span class="var">hx</span></code> works
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Def(<span class="name">file: hx.cpp</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="type">int</span> <span class="fn">main</span>(<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">argc</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">char</span> **<span class="var">argv</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">main body</span>)</span><br/>
<span class="in1"></span>}<br/>
<span class="macro">@End(<span class="name">file: hx.cpp</span>)</span><br/>
</code></div>
<ul><li>
<code><span class="var">hx</span></code> is written in C++ and consists of one source file <code><span class="str">hx.cpp</span></code>
</li><li>
Global elements like types, macros and functions are defined before
  the central <code><span class="fn">main</span></code> function is defined
</li><li>
These elements and the body of the <code><span class="fn">main</span></code> function will be defined
  and refined in later slides
</li></ul>
</div>
</div>
<h3>Commands</h3>
<div class="slides">
<div>
<div>
<h3>Commands</h3>
</div>
<ul><li>
The first code slide has three <code><span class="var">hx</span></code> commands: <code><span class="keyword">@Def</span></code>, <code><span class="keyword">@put</span></code>,
  and <code><span class="keyword">@End</span></code>
</li><li>
Each command starts with an ampersand (<code>@</code>), some letters and an
  argument block
</li><li>
The argument block consists of an opening parenthesis, the argument
  value, and a closing parenthesis
</li><li>
For now assume, that no closing parenthesis or ampersand is part of
  the argument value
</li></ul>
</div>
</div>
<h3>Fragments</h3>
<div class="slides">
<div>
<div>
<h3>Fragments</h3>
</div>
<ul><li>
<code><span class="var">hx</span></code> processes code fragments
</li><li>
A fragment starts with an opening command like <code><span class="keyword">@Def</span></code>
</li><li>
and ends with a matching <code><span class="keyword">@End</span></code> or <code><span class="keyword">@end</span></code> closing command
</li><li>
The <b>name</b> of the fragment is the argument value of the opening
  command
</li><li>
and must be the same as the argument value of the closing command
</li></ul>
</div>
</div>
<h3>Defined Fragments</h3>
<div class="slides">
<div>
<div>
<h3>Defined Fragments</h3>
</div>
<ul><li>
Three fragments are defined on the first code page
</li><li>
They have the names <code><span class="str">file: hx.cpp</span></code>, <code><span class="str">global elements</span></code>, and
  <code><span class="str">main body</span></code>
</li><li>
Not all <code><span class="var">hx</span></code> commands use their argument value as fragment name
</li><li>
but the three presented so far all do
</li></ul>
</div>
</div>
<h3>Including fragments</h3>
<div class="slides">
<div>
<div>
<h3>Including fragments</h3>
</div>
<ul><li>
A fragment can be included into another fragment with the <code><span class="keyword">@put</span></code>
  command
</li><li>
Of course you must not include a fragment that directly or indirectly
  includes the current fragment
</li><li>
The inclusion will happen after all slides are processed
</li><li>
So it is possible to include a fragment that is not defined yet
</li></ul>
</div>
</div>
<h3>Naming files</h3>
<div class="slides">
<div>
<div>
<h3>Naming files</h3>
</div>
<ul><li>
Fragments whose name start with <code><span class="str">file: </span></code> are special
</li><li>
<code><span class="var">hx</span></code> writes them into files
</li><li>
the file name is the rest of the argument value after the <code><span class="str">file: </span></code>
  prefix
</li><li>
The first code slide creates one fragment that is written into the
  file named <code><span class="str">hx.cpp</span></code>
</li></ul>
</div>
</div>
<h3>Generating the first source code</h3>
<div class="slides">
<div>
<div>
<h3>Generating the first source code</h3>
</div>
<ul><li>
If we stop here and run <code><span class="var">hx</span></code>, the following code will be generated
</li></ul>
</div>
<div><div>
<code>
<span class="in1"></span><span class="type">int</span> <span class="fn">main</span>(<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">argc</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">char</span> **<span class="var">argv</span><br/>
<span class="in1"></span>) {<br/>
<span class="in1"></span>}<br/>
</code></div>
<ul><li>
The unknown fragments are noted in the output of <code><span class="var">hx</span></code>
</li><li>
But the file compiles without errors
</li><li>
So it does not do much
</li></ul>
</div>
</div>
<h3>Steps in <code><span class="fn">main</span></code></h3>
<div class="slides">
<div>
<div>
<h3>Steps in <code><span class="fn">main</span></code></h3>
</div>
<ul><li>
The next code slides identify multiple steps to perform in the
  <code><span class="fn">main</span></code> function
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">main body</span>)</span><br/>
<span class="in1"></span><span class="keyword">#if</span> ! <span class="var">NDEBUG</span><br/>
<span class="in2"></span><span class="macro">@put(<span class="name">perform unit-tests</span>)</span>;<br/>
<span class="in1"></span><span class="keyword">#endif</span><br/>
<span class="macro">@end(<span class="name">main body</span>)</span><br/>
</code></div>
<ul><li>
The unit-tests are performed at every start of the program
</li><li>
unless a release version is build
</li><li>
The use of <code><span class="keyword">@def</span></code> instead of <code><span class="keyword">@Def</span></code> is no mistake
</li><li>
<code><span class="keyword">@Def</span></code> defines a global fragment that is visible in all <code><span class="var">x</span></code>-files
</li><li>
<code><span class="keyword">@def</span></code> defines a local fragment that is only visible in the
  current <code><span class="var">x</span></code>-file and in all included <code><span class="var">x</span></code>-files
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">main body</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">process arguments</span>)</span>;<br/>
<span class="macro">@end(<span class="name">main body</span>)</span><br/>
</code></div>
<ul><li>
After the unit-tests <code><span class="fn">main</span></code> parses the arguments passed to it from
  the command line
</li><li>
<code><span class="keyword">@add</span></code> extends an existing local fragment
</li><li>
The ability of macros to grow with time is borrowed from Literate
  Programming
</li><li>
But is is far more important in SWP, as a slide provides only limited
  space
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">main body</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">read source files</span>)</span>;<br/>
<span class="macro">@end(<span class="name">main body</span>)</span><br/>
</code></div>
<ul><li>
Next the source files are read into a fragment tree
</li><li>
Here a lot of interesting things are happening but right now it will
  expand to nothing as nothing is described yet
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">main body</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">serialize fragments</span>)</span>;<br/>
<span class="macro">@end(<span class="name">main body</span>)</span><br/>
</code></div>
<ul><li>
In the next step <code><span class="var">hx</span></code> writes the content of every file fragment in its
  designated file
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">main body</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">write HTML file</span>)</span>;<br/>
<span class="macro">@end(<span class="name">main body</span>)</span><br/>
</code></div>
<ul><li>
And lastly the HTML documentation is generated
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">includes</span>)</span>;<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
<ul><li>
<code><span class="var">hx</span></code> defines a global fragment for included files
</li></ul>
</div>
</div>
<h2>Next steps</h2>
<div class="slides">
<div>
<div>
<h2>Next steps</h2>
</div>
<ul><li>
The following slides refer to documents that document the next steps
  of <code><span class="var">hx</span></code>
</li><li>
Follow them in order so that you do not miss important concepts
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@inc(<span class="name"><a href="read.html">read.x</a></span>)</span><br/>
</code></div>
<ul><li>
Defines the mechanisms of reading files line by line
</li><li>
The <code><span class="keyword">@inc</span></code> command includes a different <code><span class="var">x</span></code>-file at the current
  position
</li><li>
The file is read only once, no matter how often it is included
</li><li>
You can click on the argument value in the HTML documentation to
  navigate to the documentation from this file
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@inc(<span class="name"><a href="blocks.html">blocks.x</a></span>)</span><br/>
</code></div>
</div>
</div>
<h1>WORKING HERE</h1>
<div class="slides">
<div>
<div>
<h1>WORKING HERE</h1>
</div>
</div>
<div><div>
<code>
<span class="macro">@inc(<span class="name"><a href="log.html">log.x</a></span>)</span><br/>
</code></div>
<ul><li>
Defines logging mechanism
</li></ul>
</div>
</div>
<h1>Fragmente</h1>
<div class="slides">
<div>
<div>
<h1>Fragmente</h1>
</div>
<ul><li>
Fragmenten können während des Parsens erweitert, ersetzt und
  angewendet werden
</li><li>
Ein Haupt-Vorteil von <code><span class="var">hx</span></code> gegenüber anderen Makro-Präprozessoren ist
  die Möglichkeit, Fragmente vor der Definition zu verwenden
</li><li>
Und Fragment an mehreren Stellen zu erweitern
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@inc(<span class="name"><a href="frag.html">frag.x</a></span>)</span><br/>
</code></div>
<ul><li>
Fragment-Behandlung wird in einer eigenen Datei definiert
</li></ul>
</div>
</div>
<h1>Input</h1>
<div class="slides">
<div>
<div>
<h1>Input</h1>
</div>
<ul><li>
Eine Klasse für Eingabe-Dateien enthält neben der offenen Datei noch
  die aktuelle Zeilennummer oder verweise auf offene inkludierte Dateien
</li><li>
Die Definition der Klasse mit allen Methoden ist in einer eigenen
  Datei ausgelagert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@inc(<span class="name"><a href="input.html">input.x</a></span>)</span><br/>
</code></div>
<ul><li>
Bindet Datei-Klasse ein
</li></ul>
</div>
</div>
<h1>Kommandozeile</h1>
<div class="slides">
<div>
<div>
<h1>Kommandozeile</h1>
</div>
<ul><li>
Die Kommandozeile wird Element für Element abgearbeitet
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">stylesheet</span> {<br/>
<span class="in2"></span><span class="str">"slides/slides.css"</span><br/>
<span class="in1"></span>};<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
<ul><li>
Für die HTML-Ausgabe wird eine Stylesheet-Datei benötigt
</li><li>
Über die Kommandozeile kann eine alternative Datei angegeben werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="type">int</span> <span class="var">blockLimit</span> = -<span class="num">1</span>;<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
<ul><li>
Die Anzahl der Blocks, die ausgegeben werden sollen, kann mit
  diesem Parameter limitiert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process arguments</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="var">someFile</span> { <span class="num">false</span> };<br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">int</span> <span class="var">i</span> { <span class="num">1</span> }; <span class="var">i</span> &lt; <span class="var">argc</span>; ++<span class="var">i</span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">process argument</span>)</span>;<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="num">false</span>,<br/>
<span class="in3"></span><span class="str">"unknown argument ["</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">argv</span>[<span class="var">i</span>] &lt;&lt; <span class="str">']'</span><br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">process arguments</span>)</span><br/>
</code></div>
<ul><li>
Die Argumente werden einzeln durchgegangen
</li><li>
Wenn sie nicht verwendet werden, bricht das Programm ab
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process argument</span>)</span> {<br/>
<span class="in1"></span><span class="keyword">static</span> <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">prefix</span> {<br/>
<span class="in2"></span><span class="str">"--css="</span><br/>
<span class="in1"></span>};<br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">arg</span> { <span class="var">argv</span>[<span class="var">i</span>] };<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">arg</span>.<span class="fn">substr</span>(<br/>
<span class="in2"></span><span class="num">0</span>, <span class="var">prefix</span>.<span class="fn">length</span>()<br/>
<span class="in1"></span>) == <span class="var">prefix</span>) {<br/>
<span class="in2"></span><span class="var">stylesheet</span> =<br/>
<span class="in3"></span><span class="var">arg</span>.<span class="fn">substr</span>(<span class="var">prefix</span>.<span class="fn">length</span>());<br/>
<span class="in2"></span><span class="keyword">continue</span>;<br/>
<span class="in1"></span>}<br/>
} <span class="macro">@end(<span class="name">process argument</span>)</span><br/>
</code></div>
<ul><li>
Der Pfad zur Stylesheet-Datei kann über die Kommandozeile gesetzt
  werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">process argument</span>)</span> {<br/>
<span class="in1"></span><span class="keyword">static</span> <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">prefix</span> {<br/>
<span class="in2"></span><span class="str">"--limit="</span><br/>
<span class="in1"></span>};<br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">arg</span> { <span class="var">argv</span>[<span class="var">i</span>] };<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">arg</span>.<span class="fn">substr</span>(<br/>
<span class="in2"></span><span class="num">0</span>, <span class="var">prefix</span>.<span class="fn">length</span>()<br/>
<span class="in1"></span>) == <span class="var">prefix</span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">extract block limit</span>)</span>;<br/>
<span class="in1"></span>}<br/>
} <span class="macro">@end(<span class="name">process argument</span>)</span><br/>
</code></div>
<ul><li>
Der Benutzer kann die Anzahl der Folien beschränken, aus denen der
  Code generiert wird
</li><li>
So können Teilabschnitte validiert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">extract block limit</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">istringstream</span> <span class="var">iss</span> {<br/>
<span class="in2"></span><span class="var">arg</span>.<span class="fn">substr</span>(<span class="var">prefix</span>.<span class="fn">length</span>())<br/>
<span class="in1"></span>};<br/>
<span class="in1"></span><span class="var">iss</span> &gt;&gt; <span class="var">blockLimit</span>;<br/>
<span class="in1"></span><span class="keyword">continue</span>;<br/>
<span class="macro">@end(<span class="name">extract block limit</span>)</span><br/>
</code></div>
<ul><li>
Das Programm legt das Argument in einen Input-Stream
</li><li>
Und liest aus diesem eine Zahl
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">process argument</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (! <span class="var">someFile</span>) {<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">push</span>(<span class="var">argv</span>[<span class="num">1</span>]);<br/>
<span class="in2"></span><span class="var">someFile</span> = <span class="num">true</span>;<br/>
<span class="in2"></span><span class="keyword">continue</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">process argument</span>)</span><br/>
</code></div>
<ul><li>
Ansonsten wird das Argument als Pfad der <code>.<span class="var">x</span></code>-Datei interpretiert
</li><li>
Aus dieser werden HTML-Slides und Source-Code generiert
</li><li>
Es kann nur eine Datei angegeben werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">process arguments</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (! <span class="var">someFile</span>) {<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">push</span>(<span class="str">"index.x"</span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">process arguments</span>)</span><br/>
</code></div>
<ul><li>
Wenn kein Pfad angegeben wurde, wird <code><span class="var">index</span>.<span class="var">x</span></code> als Vorgabe verwendet
</li></ul>
</div>
</div>
<h1>Eingabe-Dateien lesen</h1>
<div class="slides">
<div>
<div>
<h1>Eingabe-Dateien lesen</h1>
</div>
<ul><li>
In diesem Abschnitt werden die Eingabe-Dateien gelesen, um die
  Fragmente aufzubauen und alle notwendigen Beziehungen zwischen den
  einzelnen Folien zu finden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="keyword">using</span> <span class="var">SI</span> =<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span>::<span class="var">const_iterator</span>;<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
<ul><li>
Die Anwendung verwendet den String-Iterator an vielen Stellen
</li><li>
Daher definiert sie eine Abkürzung, damit die Folien nicht überlaufen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">process_chars</span>(<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>, <span class="var">SI</span> <span class="var">i</span>, <span class="var">SI</span> <span class="var">e</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">process chars</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
<ul><li>
Fügt ein Range an den Inhalt von <code><span class="var">frag</span></code> an
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">process_char</span>(<span class="type">Frag</span> *<span class="var">frag</span>, <span class="type">char</span> <span class="var">ch</span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">process char</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
<ul><li>
Fügt ein Zeichen an den Inhalt von <code><span class="var">frag</span></code> an
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Add(<span class="name">process line</span>)</span><br/>
<span class="in1"></span><span class="type">auto</span> <span class="var">end</span> = <span class="var">line</span>.<span class="fn">cend</span>();<br/>
<span class="in1"></span><span class="keyword">for</span> (<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">i</span> = <span class="var">line</span>.<span class="fn">cbegin</span>();<br/>
<span class="in2"></span><span class="var">i</span> != <span class="var">end</span>; ++<span class="var">i</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">process special lines</span>)</span>;<br/>
<span class="in2"></span><span class="fn">process_chars</span>(<span class="var">frag</span>, <span class="var">i</span>, <span class="var">i</span> + <span class="num">1</span>);<br/>
<span class="in1"></span>}<br/>
<span class="in1"></span><span class="fn">process_char</span>(<span class="var">frag</span>, <span class="str">'\n'</span>);<br/>
<span class="macro">@End(<span class="name">process line</span>)</span><br/>
</code></div>
<ul><li>
Neben dem aktuellen Zeichen wird auch das letzte Zeichen aufgehoben
</li><li>
Dabei kann <code><span class="var">hx</span></code> auch mit einer leeren Eingabe-Datei umgehen (wenn
  schon das erste Zeichen ein <code><span class="num">EOF</span></code> ist)
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Def(<span class="name">additional read vars</span>)</span><br/>
<span class="in1"></span><span class="type">Frag</span> *<span class="var">frag</span> { <span class="num">nullptr</span> };<br/>
<span class="macro">@End(<span class="name">additional read vars</span>)</span><br/>
</code></div>
<ul><li>
Wir unterscheiden, ob wir in einem Code-Block sind, oder außerhalb
</li><li>
In einem Code sind wir sogar in einem Fragment, dessen Inhalt gerade
  gelesen wird
</li><li>
Am Anfang sind wir außerhalb eines Code-Blocks
</li><li>
In einem Code-Block ist <code><span class="var">frag</span></code> nicht <code><span class="num">nullptr</span></code>
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process chars</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">str</span> {<span class="var">i</span>, <span class="var">e</span>};<br/>
<span class="in2"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in3"></span><span class="var">str</span>, <span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in3"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">process chars</span>)</span><br/>
</code></div>
<ul><li>
Fügt mehrere Zeichen an das aktuelle Fragment an
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process char</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>) {<br/>
<span class="in2"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in3"></span><span class="var">ch</span>, <span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in3"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">process char</span>)</span><br/>
</code></div>
<ul><li>
Fügt einzelnes Zeichen an das aktuelle Fragment an
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">includes</span>)</span><br/>
<span class="in1"></span><span class="keyword">#include</span> &lt;<span class="var">algorithm</span>&gt;<br/>
<span class="macro">@end(<span class="name">includes</span>)</span><br/>
</code></div>
<ul><li>
Wird für find benötigt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process special lines</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (*<span class="var">i</span> == <span class="str">'@'</span>) {<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">nb</span> = <span class="var">i</span> + <span class="num">1</span>;<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">ne</span> = <span class="var">nb</span>;<br/>
<span class="in2"></span><span class="keyword">while</span> (<span class="var">ne</span> != <span class="var">end</span> &amp;&amp; *<span class="var">ne</span> != <span class="str">'('</span>) {<br/>
<span class="in3"></span><span class="keyword">if</span> (! <span class="fn">isalpha</span>(*<span class="var">ne</span>)) {<br/>
<span class="in4"></span><span class="var">ne</span> = <span class="var">end</span>;<br/>
<span class="in4"></span><span class="keyword">break</span>;<br/>
<span class="in3"></span>}<br/>
<span class="in3"></span>++<span class="var">ne</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">ne</span> != <span class="var">end</span> &amp;&amp; <span class="var">ne</span> != <span class="var">nb</span>) {<br/>
<span class="in3"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">name</span> {<span class="var">nb</span>, <span class="var">ne</span>};<br/>
<span class="in3"></span><span class="macro">@put(<span class="name">macro argument</span>)</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">process special lines</span>)</span><br/>
</code></div>
<ul><li>
Makros können mit dem Ampersand eingeleitet werden
</li><li>
Danach kommt der Name des Makros
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">macro argument</span>)</span><br/>
<span class="in1"></span><span class="type">auto</span> <span class="var">ab</span> = <span class="var">ne</span> + <span class="num">1</span>;<br/>
<span class="in1"></span><span class="type">auto</span> <span class="var">ae</span> = <span class="var">ab</span>;<br/>
<span class="in1"></span><span class="keyword">while</span> (<span class="var">ae</span> != <span class="var">end</span> &amp;&amp; *<span class="var">ae</span> != <span class="str">')'</span>) {<br/>
<span class="in2"></span><span class="keyword">if</span> (*<span class="var">ae</span> == <span class="str">'@'</span>) {<br/>
<span class="in3"></span><span class="keyword">if</span> (++<span class="var">ae</span> == <span class="var">end</span>) { <span class="keyword">break</span>; }<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span>++<span class="var">ae</span>;<br/>
<span class="in1"></span>}<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">ae</span> != <span class="var">end</span>) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">arg</span> {<span class="var">ab</span>, <span class="var">ae</span>};<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">macro found</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">continue</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">macro argument</span>)</span><br/>
</code></div>
<ul><li>
Argument des Makros wird von Klammern umschlossen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">macro found</span>)</span><br/>
<span class="in1"></span><span class="var">i</span> = <span class="var">ae</span>;<br/>
<span class="in1"></span><span class="type">bool</span> <span class="var">outside</span> = !<span class="var">frag</span>;<br/>
<span class="in1"></span><span class="var">do</span> {<br/>
<span class="in2"></span><span class="keyword">if</span> (! <span class="var">frag</span> &amp;&amp; ! <span class="var">blockLimit</span>) { <span class="keyword">break</span>; }<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">do macro</span>)</span>;<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">default expansion</span>)</span>;<br/>
<span class="in1"></span>} <span class="keyword">while</span> (<span class="num">false</span>);<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">blockLimit</span> &amp;&amp; <span class="var">outside</span> &amp;&amp; <span class="var">frag</span>) {<br/>
<span class="in2"></span>--<span class="var">blockLimit</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">macro found</span>)</span><br/>
</code></div>
<ul><li>
Besondere Makros werden zuerst ausgewertet
</li><li>
Wenn diese Auswertung nicht greift, wird die Standard-Expandierung
  verwendet
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">global elements</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">expand_macro_arg</span>(<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">f</span>, <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">arg</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">b</span> = <span class="var">arg</span>.<span class="fn">begin</span>();<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">e</span> = <span class="var">arg</span>.<span class="fn">end</span>();<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">expand loop</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">global elements</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">expand loop</span>)</span><br/>
<span class="in1"></span><span class="keyword">while</span> (<span class="var">b</span> != <span class="var">e</span>) {<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">x</span> = <span class="type">std</span>::<span class="fn">find</span>(<span class="var">b</span>, <span class="var">e</span>, <span class="str">'@'</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">x</span> != <span class="var">e</span>) {<br/>
<span class="in3"></span><span class="macro">@put(<span class="name">expand inner</span>)</span>;<br/>
<span class="in3"></span><span class="var">b</span> = <span class="var">x</span> + <span class="num">1</span>;<br/>
<span class="in3"></span><span class="keyword">if</span> (<span class="var">b</span> != <span class="var">e</span>) {<br/>
<span class="in4"></span><span class="var">f</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in5"></span>*<span class="var">b</span>,<br/>
<span class="in5"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in5"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in4"></span>);<br/>
<span class="in4"></span>++<span class="var">b</span>;<br/>
<span class="in3"></span>}<br/>
<span class="in2"></span>} <span class="keyword">else</span> {<br/>
<span class="in3"></span><span class="macro">@put(<span class="name">expand rest</span>)</span>;<br/>
<span class="in3"></span><span class="var">b</span> = <span class="var">e</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">expand loop</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">expand inner</span>)</span><br/>
<span class="in1"></span><span class="var">f</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> { <span class="var">b</span>, <span class="var">x</span> },<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in1"></span>);<br/>
<span class="macro">@end(<span class="name">expand inner</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">expand rest</span>)</span><br/>
<span class="in1"></span><span class="var">f</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> { <span class="var">b</span>, <span class="var">e</span> },<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in1"></span>);<br/>
<span class="in1"></span><span class="var">b</span> = <span class="var">e</span>;<br/>
<span class="macro">@end(<span class="name">expand rest</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">default expansion</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>) {<br/>
<span class="in2"></span><span class="fn">expand_macro_arg</span>(<span class="var">frag</span>, <span class="var">arg</span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">default expansion</span>)</span><br/>
</code></div>
<ul><li>
Wenn das Makro nicht behandelt wurde, dann muss es sich um eine
  Formatierung handeln, die nur in Fragmenten vorkommen darf
</li><li>
Es wird einfach nur das Argument ausgegeben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"def"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>, <span class="str">"@def("</span> &lt;&lt; <span class="var">arg</span> &lt;&lt; <span class="str">") in frag ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span>);<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="var">inputs</span>.<span class="fn">get_local</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isPopulatedFrag</span>(<span class="var">frag</span>)) {<br/>
<span class="in3"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"frag ["</span> &lt;&lt; <span class="var">arg</span> &lt;&lt; <span class="str">"] already defined\n"</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Erzeugt ein neues Fragment
</li><li>
Das Fragment darf nicht mehrfach definiert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"end"</span> || <span class="var">name</span> == <span class="str">"End"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">'@'</span> &lt;&lt; <span class="var">name</span> &lt;&lt; <span class="str">"("</span> &lt;&lt; <span class="var">arg</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">") not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">frag names must match</span>)</span>;<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="num">nullptr</span>;<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Bei einem schließenden Befehl wird das aktuelle Fragment unterbrochen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">frag names must match</span>)</span><br/>
<span class="in1"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>-&gt;<span class="var">name</span> == <span class="var">arg</span>,<br/>
<span class="in2"></span><span class="str">"closing ["</span> &lt;&lt; <span class="var">arg</span> &lt;&lt;<br/>
<span class="in2"></span><span class="str">"] != ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span><br/>
<span class="in1"></span>);<br/>
<span class="macro">@end(<span class="name">frag names must match</span>)</span><br/>
</code></div>
<ul><li>
Wenn der öffnende und schließende Name nicht passt, wird die
  Abarbeitung abgebrochen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"add"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>, <span class="str">"add in frag "</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span>);<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="var">inputs</span>.<span class="fn">get_local</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (! <span class="fn">isPopulatedFrag</span>(<span class="var">frag</span>)) {<br/>
<span class="in3"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"frag ["</span> &lt;&lt; <span class="var">arg</span> &lt;&lt; <span class="str">"] not defined\n"</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Bei einem öffnenden Befehl wird das passende Fragment gesucht
</li><li>
Weitere Bytes können zu diesem Fragment hinzugefügt werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"put"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@put not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">sub</span> = <span class="var">inputs</span>.<span class="fn">get_local</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">sub</span>) {<br/>
<span class="in3"></span><span class="macro">@mul(<span class="name">check frag ex. count</span>)</span>;<br/>
<span class="in3"></span><span class="var">sub</span>-&gt;<span class="fn">addExpand</span>();<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<span class="var">sub</span>);<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Bei einem <code>@<span class="var">put</span></code> wird das Fragment gesucht und eingebunden
</li><li>
Ggf. wird das Fragment dabei auch erzeugt, um später befüllt zu werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">check frag ex. count</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">sub</span>-&gt;<span class="fn">expands</span>()) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"multiple expands of ["</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">sub</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">"]\n"</span>;<br/>
<span class="in1"></span>}<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">sub</span>-&gt;<span class="fn">multiples</span>()) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"expand after mult of ["</span><br/>
<span class="in3"></span>&lt;&lt; <span class="var">sub</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">"]\n"</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">check frag ex. count</span>)</span><br/>
</code></div>
<ul><li>
Wenn das Fragment bereits expandiert wurde, dann wird eine Meldung
  ausgegeben
</li><li>
Wenn das Fragment bereits im Mehrfach-Modus ausgegeben wurde, wird
  ebenfalls eine Meldung ausgegeben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"inc"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"include in frag ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (! <span class="var">inputs</span>.<span class="fn">has</span>(<span class="var">arg</span>)) {<br/>
<span class="in3"></span><span class="var">inputs</span>.<span class="fn">push</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Wenn eine Datei eingebunden werden soll, dann wird sie geöffnet und
  auf den Stapel der offenen Dateien gelegt
</li><li>
Wenn die Datei bereits geöffnet wurde, dann wird sie ignoriert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"mul"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@mul not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">sub</span> = <span class="var">inputs</span>.<span class="fn">get_local</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">sub</span>) {<br/>
<span class="in3"></span><span class="macro">@mul(<span class="name">check for prev expands</span>)</span>;<br/>
<span class="in3"></span><span class="var">sub</span>-&gt;<span class="fn">addMultiple</span>();<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<span class="var">sub</span>);<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Mit einem <code>@<span class="var">mul</span></code> Befehl kann ein Fragment an mehreren Stellen
  expandiert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">check for prev expands</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">sub</span>-&gt;<span class="fn">expands</span>()) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"multiple after "</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"expand of ["</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">sub</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">"]\n"</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">check for prev expands</span>)</span><br/>
</code></div>
<ul><li>
Es ist ein Fehler, wenn das Fragment bereits mit <code>@<span class="var">put</span></code> eingebunden
  wurde
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"Def"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>, <span class="str">"@Def in frag ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span>);<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="var">inputs</span>.<span class="fn">get_global</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isPopulatedFrag</span>(<span class="var">frag</span>)) {<br/>
<span class="in3"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"Frag ["</span> &lt;&lt; <span class="var">arg</span> &lt;&lt; <span class="str">"] already defined\n"</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Erzeugt ein neues Fragment im globalen Namensraum
</li><li>
Das Fragment darf nicht mehrfach definiert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"Add"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>, <span class="str">"@Add in frag ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span>);<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="var">inputs</span>.<span class="fn">get_global</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (! <span class="fn">isPopulatedFrag</span>(<span class="var">frag</span>)) {<br/>
<span class="in3"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"{{"</span> &lt;&lt; <span class="var">line</span> &lt;&lt; <span class="str">"}}\n"</span>;<br/>
<span class="in3"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"Frag ["</span> &lt;&lt; <span class="var">arg</span> &lt;&lt; <span class="str">"] not defined\n"</span>;<br/>
<span class="in3"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>() &lt;&lt; <span class="str">':'</span> &lt;&lt; <span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>() &lt;&lt; <span class="str">'\n'</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Erweitert ein global definiertes Fragment
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"rep"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@rep in frag ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="var">inputs</span>.<span class="fn">get_local</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">clear frag</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Bei einem <code>@<span class="var">rep</span></code> wird der Inhalt eines Fragments zurückgesetzt
</li><li>
Das Fragment muss bereits vorhanden sein
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"Rep"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(! <span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@Rep in frag ["</span> &lt;&lt; <span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt; <span class="str">']'</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="var">frag</span> = <span class="var">inputs</span>.<span class="fn">get_global</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">clear frag</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Bei einem <code>@<span class="var">rep</span></code> wird der Inhalt eines Fragments zurückgesetzt
</li><li>
Das Fragment muss bereits vorhanden sein
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">clear frag</span>)</span><br/>
<span class="in1"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>, <span class="str">"frag ["</span> &lt;&lt;<br/>
<span class="in2"></span><span class="var">name</span> &lt;&lt;<br/>
<span class="in2"></span><span class="str">"] not defined"</span><br/>
<span class="in1"></span>);<br/>
<span class="in1"></span><span class="var">frag</span>-&gt;<span class="fn">clear</span>();<br/>
<span class="macro">@end(<span class="name">clear frag</span>)</span><br/>
</code></div>
<ul><li>
Löscht das aktuelle Fragment
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"Put"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@Put not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">sub</span> = <span class="var">inputs</span>.<span class="fn">get_global</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">sub</span>) {<br/>
<span class="in3"></span><span class="macro">@mul(<span class="name">check frag ex. count</span>)</span>;<br/>
<span class="in3"></span><span class="var">sub</span>-&gt;<span class="fn">addExpand</span>();<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<span class="var">sub</span>);<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Bei einem <code>@<span class="type">Put</span></code> wird das Fragment in den umschließenden
  <code><span class="type">FragMap</span></code>s gesucht
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"Mul"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@Mul not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">sub</span> = <span class="var">inputs</span>.<span class="fn">get_global</span>(<span class="var">arg</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">sub</span>) {<br/>
<span class="in3"></span><span class="macro">@mul(<span class="name">check for prev expands</span>)</span>;<br/>
<span class="in3"></span><span class="var">sub</span>-&gt;<span class="fn">addMultiple</span>();<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<span class="var">sub</span>);<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
<code>@<span class="type">Mul</span></code> expandiert ein globales Fragment an mehreren Stellen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"priv"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@priv not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">process private frag</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Private Bezeichner werden durch einen Hash erweitert
</li><li>
Um sie global unique zu machen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">includes</span>)</span><br/>
<span class="in1"></span><span class="keyword">#include</span> &lt;<span class="var">functional</span>&gt;<br/>
<span class="in1"></span><span class="keyword">#include</span> &lt;<span class="var">sstream</span>&gt;<br/>
<span class="macro">@end(<span class="name">includes</span>)</span><br/>
</code></div>
<ul><li>
Enthält Hash-Funktion
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process private frag</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">hash</span>&lt;<span class="type">std</span>::<span class="type">string</span>&gt; <span class="var">h</span>;<br/>
<span class="in1"></span><span class="type">unsigned</span> <span class="var">cur</span> {<br/>
<span class="in2"></span><span class="fn">h</span>(<span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>() +<br/>
<span class="in3"></span><span class="str">':'</span> + <span class="var">arg</span>) &amp;<br/>
<span class="in4"></span><span class="num">0x7fffffff</span><br/>
<span class="in1"></span>};<br/>
<span class="macro">@end(<span class="name">process private frag</span>)</span><br/>
</code></div>
<ul><li>
Der Hash wird aus dem aktuellen Dateinamen
</li><li>
Und dem aktuellen Bezeichner berechnet
</li><li>
Zum Schluss wird er auf eine positive Zahl maskiert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">process private frag</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">ostringstream</span> <span class="var">hashed</span>;<br/>
<span class="in1"></span><span class="var">hashed</span> &lt;&lt; <span class="str">"_private_"</span> &lt;&lt;<br/>
<span class="in2"></span><span class="var">cur</span> &lt;&lt; <span class="str">'_'</span> &lt;&lt;<br/>
<span class="in2"></span><span class="var">name</span>;<br/>
<span class="in1"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in2"></span><span class="var">hashed</span>.<span class="fn">str</span>(),<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in1"></span>);<br/>
<span class="macro">@end(<span class="name">process private frag</span>)</span><br/>
</code></div>
<ul><li>
Zuerst werden eventuell zwischengespeicherte Zeichen ausgegeben
</li><li>
Dann kommt der neue Bezeichner
</li><li>
Dieser besteht aus einem konstanten Präfix
</li><li>
Dem Hash-Wert
</li><li>
Und dem alten Bezeichner
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">do macro</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">name</span> == <span class="str">"magic"</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT_MSG</span>(<span class="var">frag</span>,<br/>
<span class="in3"></span><span class="str">"@magic not in frag"</span><br/>
<span class="in2"></span>);<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">process magic frag</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">break</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">do macro</span>)</span><br/>
</code></div>
<ul><li>
Der <code>@<span class="var">magic</span></code>-Befehl erzeugt einen Hash-Wert
</li><li>
Der sich aus dem Dateinamen und dem Argument des Befehls
  zusammen setzt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">process magic frag</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">hash</span>&lt;<span class="type">std</span>::<span class="type">string</span>&gt; <span class="var">h</span>;<br/>
<span class="in1"></span><span class="type">unsigned</span> <span class="var">cur</span> {<br/>
<span class="in2"></span><span class="fn">h</span>(<span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>() +<br/>
<span class="in3"></span><span class="str">':'</span> + <span class="var">arg</span>) &amp;<br/>
<span class="in4"></span><span class="num">0x7fffffff</span><br/>
<span class="in1"></span>};<br/>
<span class="macro">@end(<span class="name">process magic frag</span>)</span><br/>
</code></div>
<ul><li>
Berechnet Hash-Wert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">process magic frag</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">ostringstream</span> <span class="var">value</span>;<br/>
<span class="in1"></span><span class="var">value</span> &lt;&lt; <span class="var">cur</span>;<br/>
<span class="in1"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in2"></span><span class="var">value</span>.<span class="fn">str</span>(),<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">input</span>().<span class="fn">path</span>(),<br/>
<span class="in2"></span><span class="var">inputs</span>.<span class="fn">cur</span>().<span class="fn">line</span>()<br/>
<span class="in1"></span>);<br/>
<span class="macro">@end(<span class="name">process magic frag</span>)</span><br/>
</code></div>
<ul><li>
Gibt den Hash-Wert aus
</li><li>
Vorher wird noch eventuell gespeicherte Zeichen ausgegeben
</li></ul>
</div>
</div>
<h1>Fragmente serialisieren</h1>
<div class="slides">
<div>
<div>
<h1>Fragmente serialisieren</h1>
</div>
<ul><li>
Fragmente, die Dateien spezifizieren werden in diese Dateien
  rausgeschrieben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">serialize fragments</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">auto</span> &amp;<span class="var">i</span> : <span class="var">root</span>) {<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">frag</span> { &amp;<span class="var">i</span>.<span class="var">second</span> };<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">serialize frag</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">serialize fragments</span>)</span><br/>
</code></div>
<ul><li>
Fragmente, die mit <code><span class="var">file</span>:</code> beginnen, werden in die entsprechenden
  Dateien rausgeschrieben
</li><li>
Zusätzlich wird geprüft, ob Fragmente zu selten oder zu oft expandiert
  wurden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">serialize fragments</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">auto</span> &amp;<span class="var">j</span> : <span class="var">inputs</span>) {<br/>
<span class="in2"></span><span class="keyword">for</span> (<span class="type">auto</span> &amp;<span class="var">i</span> : <span class="var">j</span>.<span class="var">frags</span>) {<br/>
<span class="in3"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">frag</span> {<br/>
<span class="in4"></span>&amp;<span class="var">i</span>.<span class="var">second</span><br/>
<span class="in3"></span>};<br/>
<span class="in3"></span><span class="macro">@mul(<span class="name">serialize frag</span>)</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">serialize fragments</span>)</span><br/>
</code></div>
<ul><li>
Auch alle lokalen Fragmente bearbeiten
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">serialize frag</span>)</span> {<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>-&gt;<span class="fn">isFile</span>()) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">write in file</span>)</span>;<br/>
<span class="in1"></span>}<br/>
} <span class="macro">@end(<span class="name">serialize frag</span>)</span><br/>
</code></div>
<ul><li>
Wenn der Name eines Fragments mit <code><span class="var">file</span>: </code> beginnt, dann wird es in
  die passende Datei geschrieben
</li><li>
Zusätzlich zählt das als eine Expansion
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">serialize frag</span>)</span> {<br/>
<span class="in1"></span><span class="type">int</span> <span class="var">sum</span> {<br/>
<span class="in2"></span><span class="var">frag</span>-&gt;<span class="fn">expands</span>()<br/>
<span class="in3"></span>+ <span class="var">frag</span>-&gt;<span class="fn">multiples</span>()<br/>
<span class="in1"></span>};<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">sum</span> &lt;= <span class="num">0</span>) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"frag ["</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"] not called\n"</span>;<br/>
<span class="in1"></span>}<br/>
} <span class="macro">@end(<span class="name">serialize frag</span>)</span><br/>
</code></div>
<ul><li>
Ein Fragment wurde nicht aufgerufen
</li><li>
Dies wird mit einer Meldung protokolliert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">serialize frag</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>-&gt;<span class="fn">multiples</span>() == <span class="num">1</span>) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"multiple frag ["</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"] only used once\n"</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">serialize frag</span>)</span><br/>
</code></div>
<ul><li>
Ein Fragment das zur mehrfachen Verwendung deklariert wurde, wird nur
  einmal verwendet
</li><li>
Dies wird mit einer Meldung protokolliert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">serialize frag</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (! <span class="fn">isPopulatedFrag</span>(<span class="var">frag</span>)) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">cerr</span> &lt;&lt; <span class="str">"frag ["</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">frag</span>-&gt;<span class="var">name</span> &lt;&lt;<br/>
<span class="in3"></span><span class="str">"] not populated\n"</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">serialize frag</span>)</span><br/>
</code></div>
<ul><li>
Für jedes Fragment, das nicht befüllt wurde wird eine Meldung
  ausgegeben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">write in file</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">ofstream</span> <span class="fn">out</span>(<br/>
<span class="in2"></span><span class="var">frag</span>-&gt;<span class="var">name</span>.<span class="fn">substr</span>(<span class="num">6</span>).<span class="fn">c_str</span>()<br/>
<span class="in1"></span>);<br/>
<span class="in1"></span><span class="fn">serializeFrag</span>(*<span class="var">frag</span>, <span class="var">out</span>, <span class="num">false</span>);<br/>
<span class="in1"></span><span class="var">out</span>.<span class="fn">close</span>();<br/>
<span class="macro">@end(<span class="name">write in file</span>)</span><br/>
</code></div>
<ul><li>
Das Fragment wird in die entsprechende Datei geschrieben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">serialize fragments</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">auto</span> &amp;<span class="var">i</span> : <span class="var">root</span>) {<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">frag</span> { &amp;<span class="var">i</span>.<span class="var">second</span> };<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">serialize cmd</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">serialize fragments</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">serialize fragments</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">auto</span> &amp;<span class="var">j</span> : <span class="var">inputs</span>) {<br/>
<span class="in2"></span><span class="keyword">for</span> (<span class="type">auto</span> &amp;<span class="var">i</span> : <span class="var">j</span>.<span class="var">frags</span>) {<br/>
<span class="in3"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">frag</span> {<br/>
<span class="in4"></span>&amp;<span class="var">i</span>.<span class="var">second</span><br/>
<span class="in3"></span>};<br/>
<span class="in3"></span><span class="macro">@mul(<span class="name">serialize cmd</span>)</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">serialize fragments</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">serialize cmd</span>)</span> {<br/>
<span class="in1"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">cmd</span> { <span class="var">frag</span>-&gt;<span class="fn">cmd</span>() };<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">cmd</span>.<span class="fn">size</span>()) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">write cmd in file</span>)</span>;<br/>
<span class="in1"></span>}<br/>
} <span class="macro">@end(<span class="name">serialize cmd</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">write cmd in file</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">ostringstream</span> <span class="var">out</span> {};<br/>
<span class="in1"></span><span class="fn">serializeFrag</span>(*<span class="var">frag</span>, <span class="var">out</span>, <span class="num">false</span>);<br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">o</span> { <span class="var">out</span>.<span class="fn">str</span>() };<br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">FILE</span> *<span class="var">f</span> {<br/>
<span class="in2"></span><span class="fn">popen</span>(<span class="var">cmd</span>.<span class="fn">c_str</span>(), <span class="str">"w"</span>)<br/>
<span class="in1"></span>};<br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">f</span>) {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="fn">fwrite</span>(<span class="var">o</span>.<span class="fn">c_str</span>(), <span class="var">o</span>.<span class="fn">size</span>(), <span class="num">1</span>, <span class="var">f</span>);<br/>
<span class="in2"></span><span class="fn">pclose</span>(<span class="var">f</span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">write cmd in file</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@inc(<span class="name"><a href="html.html">html.x</a></span>)</span><br/>
</code></div>
<ul><li>
Die Generierung liegt in einer eigenen Datei
</li></ul>
</div>
</body>
</html>
