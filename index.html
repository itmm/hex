<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<title>HTML Extractor</title>
		<link rel="stylesheet" type="text/css"
			href="slides/slides.css">
	</head>
	<body>
		<h1>HTML Extractor</h1>

		<p>
			Dieses Dokument enthält eine Präsentation, welche die
			Entwicklung des <emph>HTML Extractors</emph>
			(<code>hex</code>) beschreibt.
			Sie enthält zusätzlich den gesamten Source-Code von
			<code>hex</code>.
		</p><p>
			Es handelt sich um den Versuch eines neuen
			Programmier-Konzeptes: des Slideware-Programming (SWP).
			Viel Spass.
		</p>

		<div class="slides">
			<div class="row">
				<div class="slide title">
					<h1>HTML Extractor</h1>
				</div>
				<ul class="notes">
					<li>
						<code>hex</code> extrahiert Source-Code aus
						HTML-Präsentationen
					</li><li>
						In der Präsentation kann der Schritt für Schritt
						eingeführt werden
					</li><li>
						Es ist die Aufgabe von <code>hex</code>, daraus
						ein ausführbares Programm zu generieren
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>Slideware Programming (SWP)</h1>
				</div>
				<ul class="notes">
					<li>
						Aus dem Source-Code, der in einer
						HTML-Präsentation enthalten ist, kann ein
						ausführbares Programm generiert werden
					</li><li>
						Dabei wird das Programm schrittweise aufgebaut
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>SWP &ne; Literate Programming</h1>
				</div>
				<ul class="notes">
					<li>
						SWP beschreibt nicht nur ein fertiges Programm,
					</li><li>
						Sondern wie das Programm aufgebaut wird
					</li><li>
						Zu jedem Zeitpunkt muss das bisher beschriebene
						Programm ausführbar sein,
					</li><li>
						Wenn nicht definierte Makros zu nichts
						expandieren.
					</li>
				</ul>
			</div>
		</div>
		<h1>Definition des Ablaufs</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="expand">@expand(<span class="macro-name">global elements</span>)</span><br/>
					<br/>
					<span class="type">int</span> <span class="fn">main</span>(<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">argc</span>,<br/>
					<span class="in1"></span><span class="type">const char **</span><span class="var">argv</span><br/>
					) {<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">perform unit-tests</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">process arguments</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">process HTML file</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">serialize fragments</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">compile program</span>)</span>;<br/>
					}<br/>
				</code></div>
				<ul class="notes">
					<li>
						Bei jedem Start werden alle Unit-Tests
						ausgeführt (um eine umfangreiche Testabdeckung
						zu sichern)
					</li><li>
						Eventuell werden Parameter von der Kommandozeile
						ausgewertet
					</li><li>
						Dann wird ein Parse-Graph aus Fragmenten
						aufgebaut
					</li><li>
						Und das daraus resultiernde Programm übersetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>Was macht <code class="expand">@expand</code>?</h1>
				</div>
				<ul class="notes">
					<li>
						<code class="expand">@expand</code>-Blöcke
						beschreiben Makro-Aufrufe.
					</li><li>
						Der Wert des Makros mit dem Namen in Klammern
						wird anstelle des Aufrufs im endgültigen
						Programm gesetzt.
					</li><li>
						Diese Makros bilden ein zentrales Element von
						<code>hex</code>.
					</li><li>
						Sie können mit
						<code class="add">@add</code>-<code class="end">@end</code>-Sequenzen
						definiert oder erweitert werden.
					</li>
				</ul>
			</div>
		</div>
		<h1>Makros</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">global elements</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">includes</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">define logging</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">define macro</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">global elements</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						System-Dateien werden vor der Definition von
						Strukturen und Funktionen eingebunden.
					</li><li>
						Auch müssen Macros für das Logging vor den
						Funktionen definiert werden, die sie verwenden
					</li><li>
						Makros sind global sichtbare Strukturen.
						Und das daraus resultiernde Programm übersetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry</span>;<br/>
					<br/>
					<span class="in1"></span><span class="type">struct Macro</span> {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">link</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">firstEntry</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">lastEntry</span>;<br/>
					<span class="in2"></span><span class="type">char </span><span class="var">name</span><span class="type">[]</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Die Makros werden in einfach verketteten Listen
						gesammelt
					</li><li>
						Genauso werden die Einträge eines Makros in
						einer einfach verketteten Liste organisiert
					</li><li>
						Um schnell Einträge einfügen zu können, gibt es
						auch einen Verweis auf das letzte Element
					</li><li>
						Je nach Namen werden für ein Makro
						unterschiedlich viele Bytes im Heap angefordert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">stdlib.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						<code class="include-name">stdlib.h</code> wird für die Definition
						von <code class="keyword">NULL</code> benötigt
					</li>
				</ul>
			</div>
		</div>
		<h2>Neues Makro anlegen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">allocMacro(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">nameBegin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">nameEnd</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">allocate macro on heap</span>)</span>;<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">firstEntry</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">copy macro name</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Die Zeiger werden mit
						<code class="keyword">NULL</code> initializiert
					</li><li>
						<code class="var">lastEntry</code> wird erst
						initialisiert, wenn
						<code class="var">firstEntry</code> gesetzt wird
					</li><li>
						Der Name wird über zwei Zeiger übergeben, muss
						also nicht mit einem Null-Byte terminiert sein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">stdio.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
					<span class="add">@add(<span class="macro-name">define logging</span>)</span><br/>
					<span class="in1"></span><span
						class="define">#define <span class="name">ASSERT</span>(<span class="var">COND</span>) \</span><br/>
					<span class="in2"></span><span class="define"><span class="keyword">if</span> (! (<span class="var">COND</span>)) {\ </span><br/>
					<span class="in3"></span><span class="define"><span class="fn">fprintf</span>(<span class="var">stderr</span>, \</span><br/>
					<span class="in4"></span><span class="define"><span class="str">"%s:%d FAILED\n"</span>, \</span><br/>
					<span class="in4"></span><span class="define">__FILE__, __LINE__ 
						\</span><br/>
					<span class="in3"></span>); \</span><br/>
					<span class="in3"></span><span class="define"><span class="fn">exit</span>(<span class="var">EXIT_FAILURE</span>); \</span><br/>
					<span class="in2"></span><span class="define">}</span><br/>
					<span class="end">@end(<span class="macro-name">define logging</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Wenn Bedingung falsch ist, wird Fehlermeldung
						ausgegeben
					</li><li>
						Und das Programm beendet
					</li><li>
						Datei und Zeile des Tests wird ausgegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">allocate macro on heap</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">nameBegin</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">nameBegin</span> &lt;= <span class="var">nameEnd</span>);<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">nameLength</span> =<br/>
  					<span class="in2"></span><span class="var">nameEnd</span> - <span class="var">nameBegin</span>;<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">macroSize</span> = <span class="keyword">sizeof</span>(<span class="type">struct Macro</span>)<br/>
   					<span class="in2"></span>+ <span class="var">nameLength</span> + 1;<br/>
					<span class="in1"></span><span class="var">result</span> = <span class="var">malloc</span>(<span class="var">macroSize</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>
					<span class="end">@end(<span class="macro-name">allocate macro on heap</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Die Zeiger werden mit
						<code class="keyword">NULL</code> initializiert
					</li><li>
						<code class="var">lastEntry</code> wird erst
						initialisiert, wenn
						<code class="var">firstEntry</code> gesetzt wird
					</li><li>
						Der Name wird über zwei Zeiger übergeben, muss
						also nicht mit einem Null-Byte terminiert sein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">string.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
					<span class="add">@add(<span class="macro-name">copy macro name</span>)</span><br/>
					<span class="in1"></span><span class="fn">memcpy</span>(<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">name</span>, <span class="var">nameBegin</span>,<br/>
		 			<span class="in2"></span><span class="var">nameLength</span><br/>
					<span class="in1"></span>);<br/>
					<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">name</span>[<span class="var">nameLength</span>] = <span class="str">'\0'<span>;<br/>
					<span class="end">@end(<span class="macro-name">copy macro name</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Der Name wird direkt in die das Makro kopiert
					</li><li>
						Der Name wird mit einem Null-Byte abgeschlossen
					</li>
				</ul>
			</div>
		</div>
		<h2>Makros freigeben</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">freeMacro(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">while</span> (<span class="var">macro</span>) {<br/>
					<span class="in3"></span><span class="type">struct Macro *</span><span class="var">link</span> =<br/>
					<span class="in4"></span><span class="var">macro</span>-&gt;<span class="var">link</span>;<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="expand-name">free macros entries</span>)</span>;<br/>
					<span class="in3"></span><span class="fn">free</span>(<span class="var">macro</span>);<br/>
					<span class="in3"></span><span class="var">macro</span> = <span class="var">link</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span
							class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Mit einem Makro werden auch alle verketteten
						Makros freigegeben
					</li><li>
						Die Freigabe der einzelnen Einträge wird später
						definiert
					</li>
				</ul>
			</div>
		</div>
		<h2>Unit Tests</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">perform unit tests</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="expand-name">macro unit tests</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">perform unit tests</span>)</span><br/>
					<br/>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">allocTestMacro</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">name</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="fn">allocMacro</span>(<br/>
					<span class="in3"></span><span class="var">name</span>, <span class="var">name</span> + <span class="fn">strlen</span>(<span class="var">name</span>)<br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Für Unit-Tests gibt es einen einfacheren
						Konstruktor
					</li><li>
						Die Länge des Namens wird anhand des Null-Bytes
						berechnet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">testMacroName</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">name</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="var">name</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
	   				<span class="in3"></span><span class="fn">strcmp</span>(<span class="var">macro</span>-&gt;<span class="var">name</span>, <span class="var">name</span>) == 0<br/>
  					<span class="in2"></span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						<code class="fn">testMacroName</code> prüft, ob
						der Name korrekt in ein Makro kopiert wurde.
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span><span class="fn">testMacroName</span>(<span class="str">"abc"</span>);<br/>
					<span class="in1"></span><span class="fn">testMacroName</span>(<span class="str">""</span>);<br/>
					<span class="in1"></span><span class="fn">testMacroName</span>(<span class="str">"A c"</span>);<br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="str">"ab"</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">macro</span>-&gt;<span class="var">link</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">macro</span>-&gt;<span class="var">firstEntry</span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Zum einen wird getestet, ob die Namen korrekt
						kopiert werden
					</li><li>
						Zum anderen wird sichergestellt, dass die
						Verweise <code class="keyword">NULL</code> sind
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Einträge</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry</span> {<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">link</span>;<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>;<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueEnd</span>;<br/>
					<span class="in2"></span><span class="type">char </span><span class="var">value</span><span class="type">[]</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag kann entweder auf ein anderes Makro
						verweisen (wenn dieses an der aktuellen Stelle
						expandiert werden soll)
					</li><li>
						Oder er enthält Bytes, die beim Expandieren
						direkt expandiert werden
					</li><li>
						Die Länge des Byte-Arrays wird über einen Zeiger
						angezeigt (damit auch Null-Bytes verwendet
						werden können)
					</li><li>
						Wenn ein Eintrag sowohl Daten als auch ein Makro
						enthält, so wird zuerst der Text ausgegeben
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Eintrag anlegen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry *</span><span class="fn">allocMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueBegin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueEnd</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">allocate entry on heap</span>);<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">copy entry values</span>);<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Wie beim Macro werden die
						<code class="var">link</code> Verweise auf
						<code class="keyword">NULL</code> initialisiert
					</li><li>
						Sowohl <code class="var">macro</code> als auch
						<code class="var">valueBegin</code> sind
						optional
					</li><li>
						Die Größe des Eintrags hängt von der Größe der
						Bytes ab, die kopiert werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">allocate entry on heap</span>)</span><br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">valueLength</span> = 0;<br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">valueBegin</span> &lt;= <span class="var">valueEnd</span>);<br/>
					<span class="in2"></span><span class="var">valueLength</span> =<br/>
	   				<span class="in3"></span><span class="var">valueEnd</span> - <span class="var">valueBegin</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">entrySize</span> = <span class="var">valueLength</span> +<br/>
					<span class="in2"></span><span class="keyword">sizeof</span>(<span class="type">struct MacroEntry</span>);<br/>
					<span class="in1"></span><span class="var">result</span> = <span class="var">malloc</span>(<span class="var">entrySize</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>
					<span class="end">@end(<span class="macro-name">allocate entry on heap</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Die Größe der Struktur wird um die Anzahl der zu
						kopierenden Bytes vergrößert
					</li><li>
						Wenn nicht genug Speicher vorhanden ist, dann
						wird das Programm beendet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">copy entry values</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
					<span class="in2"></span><span class="fn">memcpy</span>(<br/>
					<span class="in3"></span><span class="var">result</span>-&gt;<span class="var">value</span>, <span class="var">valueBegin</span>,<br/>
		 			<span class="in3"></span><span class="var">valueLength</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">valueEnd</span> =<br/>
					<span class="in2"></span><span class="var">result<span>-&gt;<span class="var">value</value> + <span class="var">valueLength</span>;<br/>
					<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">macro</span> = <span class="var">macro</span>;<br/>
					<span class="end">@end(<span class="macro-name">copy entry values</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Die Bytes werden nur kopiert, wenn welche
						übergeben wurden
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Einträge freigeben</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">freeMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">while</span> (<span class="var">entry</span>) {<br/>
					<span class="in3"></span><span class="type">struct MacroEntry *</span><span class="var">link</span> =<br/>
					<span class="in4"></span><span class="var">entry</span>-&gt;<span class="var">link</span>;<br/>
					<span class="in3"></span><span class="fn">free</span>(<span class="var">entry</span>);<br/>
					<span class="in3"></span><span class="var">entry</span> = <span class="var">link</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Eintrag freigegeben wird, so werden
						auch alle verlinkten Einträge freigegeben
					</li><li>
						Referenzierte Makros werden nicht mit
						freigegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry</span>;<br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">freeMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span><br/>
					<span class="in1"></span>);<br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
					<br/>
					<span class="add">@add(<span class="macro-name">free macros entries</span>)</span><br/>
					<span class="in1"></span><span class="fn">freeMacroEntry</span>(<span class="var">macro</span>-&gt;<span class="var">firstEntry</span>);<br/>
					<span class="end">@end(<span class="macro-name">free macros entries</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Makro freigegeben wird, so werden auch
						die anhängenden Einträge freigegeben
					</li><li>
						Damit die Funktion im
						<code class="fn">freeMacro</code> sichtbar ist,
						wird sie in der Include-Sektion definiert
					</li>
				</ul>
			</div>
		</div>
	</body>
</html>
