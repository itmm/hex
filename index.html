<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<title>HTML Extractor</title>
		<link rel="stylesheet" type="text/css"
			href="slides/slides.css">
	</head>
	<body>
		<h1>HTML Extractor</h1>

		<p>
			Dieses Dokument enthält eine Präsentation, welche die
			Entwicklung des <emph>HTML Extractors</emph>
			(<code>hex</code>) beschreibt.
			Sie enthält zusätzlich den gesamten Source-Code von
			<code>hex</code>.
		</p><p>
			Es handelt sich um den Versuch eines neuen
			Programmier-Konzeptes: des Slideware-Programming (SWP).
			Viel Spass.
		</p>

		<div class="slides">
			<div class="row">
				<div class="slide title">
					<h1>HTML Extractor</h1>
				</div>
				<ul class="notes">
					<li>
						<code>hex</code> extrahiert Source-Code aus
						HTML-Präsentationen
					</li><li>
						In der Präsentation kann der Schritt für Schritt
						eingeführt werden
					</li><li>
						Es ist die Aufgabe von <code>hex</code>, daraus
						ein ausführbares Programm zu generieren
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>Slideware Programming (SWP)</h1>
				</div>
				<ul class="notes">
					<li>
						Aus dem Source-Code, der in einer
						HTML-Präsentation enthalten ist, kann ein
						ausführbares Programm generiert werden
					</li><li>
						Dabei wird das Programm schrittweise aufgebaut
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>SWP &ne; Literate Programming</h1>
				</div>
				<ul class="notes">
					<li>
						SWP beschreibt nicht nur ein fertiges Programm,
					</li><li>
						Sondern wie das Programm aufgebaut wird
					</li><li>
						Zu jedem Zeitpunkt muss das bisher beschriebene
						Programm ausführbar sein,
					</li><li>
						Wenn nicht definierte Makros zu nichts
						expandieren.
					</li><li>
						So kann das Verständnis für ein Programm
						schrittweise erarbeitet werden
					</li>
				</ul>
			</div>
		</div>
		<h1>Definition des Ablaufs</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">MAIN</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">global elements</span>)</span><br/>
					<span class="in1"></span><span class="type">int</span> <span class="fn">main</span>(<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">argc</span>, <span class="type">const char **</span><span class="var">argv</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">main body</span>)</span><br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">MAIN</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Das Hauptprogramm besteht aus der
						<code lang="fn">main</code>-Funktion
					</li><li>
						Zusätzlich müssen Objekte im globalen Scope
						definiert werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">main body</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">perform unit-tests</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">process arguments</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">read source file</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">write HTML file</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">serialize fragments</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">compile program</span>)</span>;<br/>
					<span class="expand">@expand(<span class="macro-name">main body</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Bei jedem Start werden alle Unit-Tests
						ausgeführt (um eine umfangreiche Testabdeckung
						zu sichern)
					</li><li>
						Eventuell werden Parameter von der Kommandozeile
						ausgewertet
					</li><li>
						Dann wird ein Parse-Graph aus Fragmenten
						aufgebaut
					</li><li>
						Und das daraus resultiernde Programm übersetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>Was macht <code class="expand">@expand</code>?</h1>
				</div>
				<ul class="notes">
					<li>
						<code class="expand">@expand</code>-Blöcke
						beschreiben Makro-Aufrufe.
					</li><li>
						Der Wert des Makros mit dem Namen in Klammern
						wird anstelle des Aufrufs im endgültigen
						Programm gesetzt.
					</li><li>
						Diese Makros bilden ein zentrales Element von
						<code>hex</code>.
					</li><li>
						Sie können mit
						<code class="add">@add</code>-<code class="end">@end</code>-Sequenzen
						definiert oder erweitert werden.
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">global elements</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">includes</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">define logging</span>)</span>;<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">forward declarations</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">global elements</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						System-Dateien werden vor der Definition von
						Strukturen und Funktionen eingebunden.
					</li><li>
						Auch müssen Macros für das Logging vor den
						Funktionen definiert werden, die sie verwenden
					</li>
				</ul>
			</div>
		</div>
		<h1>Minimale Vorbereitung für das Parsen</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">stdio.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
					<br/>
				</code></div>
				<ul class="notes">
					<li>
						Standard File-Funktionen werden vom Programm
						benötigt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">process arguments</span>)</span><br/>
					<span class="in1"></span><span class="type">FILE *</span><span class="var">input</span> = <span class="var">stdin</span>;<br/>
					<span class="end">@end(<span class="macro-name">process arguments</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Source-Code für die Slideware muss aus einer
						Datei geladen werden
					</li><li>
						Der Name kann über die Kommandozeile gesetzt
						werden
					</li><li>
						Aber bis das implementiert ist, nehmen wird
						eine sinnvolle Vorgabe
					</li>
				</ul>
			</div>
		</div>
		<h1>Makros</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">global elements</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">define macro</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">global elements</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Makros sind global sichtbare Strukturen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry</span>;<br/>
					<br/>
					<span class="in1"></span><span class="type">struct Macro</span> {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">link</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">firstEntry</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">lastEntry</span>;<br/>
					<span class="in2"></span><span class="type">char </span><span class="var">name</span><span class="type">[]</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Die Makros werden in einfach verketteten Listen
						gesammelt
					</li><li>
						Genauso werden die Einträge eines Makros in
						einer einfach verketteten Liste organisiert
					</li><li>
						Um schnell Einträge einfügen zu können, gibt es
						auch einen Verweis auf das letzte Element
					</li><li>
						Je nach Namen werden für ein Makro
						unterschiedlich viele Bytes im Heap angefordert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">stdlib.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						<code class="include-name">stdlib.h</code> wird für die Definition
						von <code class="keyword">NULL</code> benötigt
					</li>
				</ul>
			</div>
		</div>
		<h2>Neues Makro anlegen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">allocMacro</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">nameBegin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">nameEnd</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">allocate macro on heap</span>)</span>;<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">firstEntry</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">copy macro name</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Die Zeiger werden mit
						<code class="keyword">NULL</code> initializiert
					</li><li>
						<code class="var">lastEntry</code> wird erst
						initialisiert, wenn
						<code class="var">firstEntry</code> gesetzt wird
					</li><li>
						Der Name wird über zwei Zeiger übergeben, muss
						also nicht mit einem Null-Byte terminiert sein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define logging</span>)</span><br/>
					<span class="in1"></span><span class="define">#define <span class="name">ASSERT</span>(<span class="var">COND</span>) \</span><br/>
					<span class="in2"></span><span class="define"><span class="keyword">if</span> (! (<span class="var">COND</span>)) {\ </span><br/>
					<span class="in3"></span><span class="define"><span class="fn">fprintf</span>(<span class="var">stderr</span>, \</span><br/>
					<span class="in4"></span><span class="define"><span class="str">"%s:%d FAILED\n"</span>, \</span><br/>
					<span class="in4"></span><span class="define">__FILE__, __LINE__); \</span><br/>
					<span class="in3"></span><span class="define"><span class="fn">exit</span>(<span class="var">EXIT_FAILURE</span>); \</span><br/>
					<span class="in2"></span><span class="define">}</span><br/>
					<span class="end">@end(<span class="macro-name">define logging</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn Bedingung falsch ist, wird Fehlermeldung
						ausgegeben
					</li><li>
						Und das Programm beendet
					</li><li>
						Datei und Zeile des Tests wird ausgegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">allocate macro on heap</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">nameBegin</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">nameBegin</span> &lt;= <span class="var">nameEnd</span>);<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">nameLength</span> =<br/>
  					<span class="in2"></span><span class="var">nameEnd</span> - <span class="var">nameBegin</span>;<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">macroSize</span> = <span class="keyword">sizeof</span>(<span class="type">struct Macro</span>)<br/>
   					<span class="in2"></span>+ <span class="var">nameLength</span> + 1;<br/>
					<span class="in1"></span><span class="var">result</span> = <span class="var">malloc</span>(<span class="var">macroSize</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>
					<span class="end">@end(<span class="macro-name">allocate macro on heap</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Die Zeiger werden mit
						<code class="keyword">NULL</code> initializiert
					</li><li>
						<code class="var">lastEntry</code> wird erst
						initialisiert, wenn
						<code class="var">firstEntry</code> gesetzt wird
					</li><li>
						Der Name wird über zwei Zeiger übergeben, muss
						also nicht mit einem Null-Byte terminiert sein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">string.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
					<br/>
					<span class="add">@add(<span class="macro-name">copy macro name</span>)</span><br/>
					<span class="in1"></span><span class="fn">memcpy</span>(<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">name</span>, <span class="var">nameBegin</span>,<br/>
		 			<span class="in2"></span><span class="var">nameLength</span><br/>
					<span class="in1"></span>);<br/>
					<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">name</span>[<span class="var">nameLength</span>] = <span class="str">'\0'</span>;<br/>
					<span class="end">@end(<span class="macro-name">copy macro name</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Name wird direkt in die das Makro kopiert
					</li><li>
						Der Name wird mit einem Null-Byte abgeschlossen
					</li>
				</ul>
			</div>
		</div>
		<h2>Makros freigeben</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">freeMacro</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">while</span> (<span class="var">macro</span>) {<br/>
					<span class="in3"></span><span class="type">struct Macro *</span><span class="var">link</span> =<br/>
					<span class="in4"></span><span class="var">macro</span>-&gt;<span class="var">link</span>;<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">free macros entries</span>)</span>;<br/>
					<span class="in3"></span><span class="fn">free</span>(<span class="var">macro</span>);<br/>
					<span class="in3"></span><span class="var">macro</span> = <span class="var">link</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Mit einem Makro werden auch alle verketteten
						Makros freigegeben
					</li><li>
						Die Freigabe der einzelnen Einträge wird später
						definiert
					</li>
				</ul>
			</div>
		</div>
		<h2>Unit Tests</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">perform unit tests</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">macro unit tests</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">perform unit tests</span>)</span><br/>
					<br/>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">allocTestMacro</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">name</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="fn">allocMacro</span>(<br/>
					<span class="in3"></span><span class="var">name</span>, <span class="var">name</span> + <span class="fn">strlen</span>(<span class="var">name</span>)<br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Für Unit-Tests gibt es einen einfacheren
						Konstruktor
					</li><li>
						Die Länge des Namens wird anhand des Null-Bytes
						berechnet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">testMacroName</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">name</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="var">name</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
	   				<span class="in3"></span><span class="fn">strcmp</span>(<span class="var">macro</span>-&gt;<span class="var">name</span>, <span class="var">name</span>) == 0<br/>
  					<span class="in2"></span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						<code class="fn">testMacroName</code> prüft, ob
						der Name korrekt in ein Makro kopiert wurde.
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span><span class="fn">testMacroName</span>(<span class="str">"abc"</span>);<br/>
					<span class="in1"></span><span class="fn">testMacroName</span>(<span class="str">""</span>);<br/>
					<span class="in1"></span><span class="fn">testMacroName</span>(<span class="str">"A c"</span>);<br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="str">"ab"</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">macro</span>-&gt;<span class="var">link</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">macro</span>-&gt;<span class="var">firstEntry</span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zum einen wird getestet, ob die Namen korrekt
						kopiert werden
					</li><li>
						Zum anderen wird sichergestellt, dass die
						Verweise <code class="keyword">NULL</code> sind
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Einträge</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry</span> {<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">link</span>;<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>;<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueEnd</span>;<br/>
					<span class="in2"></span><span class="type">char </span><span class="var">value</span><span class="type">[]</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag kann entweder auf ein anderes Makro
						verweisen (wenn dieses an der aktuellen Stelle
						expandiert werden soll)
					</li><li>
						Oder er enthält Bytes, die beim Expandieren
						direkt expandiert werden
					</li><li>
						Die Länge des Byte-Arrays wird über einen Zeiger
						angezeigt (damit auch Null-Bytes verwendet
						werden können)
					</li><li>
						Wenn ein Eintrag sowohl Daten als auch ein Makro
						enthält, so wird zuerst der Text ausgegeben
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Eintrag anlegen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry *</span><span class="fn">allocMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueBegin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueEnd</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">allocate entry on heap</span>)</span>;<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">copy entry values</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wie beim Macro werden die
						<code class="var">link</code> Verweise auf
						<code class="keyword">NULL</code> initialisiert
					</li><li>
						Sowohl <code class="var">macro</code> als auch
						<code class="var">valueBegin</code> sind
						optional
					</li><li>
						Die Größe des Eintrags hängt von der Größe der
						Bytes ab, die kopiert werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">allocate entry on heap</span>)</span><br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">valueLength</span> = 0;<br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">valueBegin</span> &lt;= <span class="var">valueEnd</span>);<br/>
					<span class="in2"></span><span class="var">valueLength</span> =<br/>
	   				<span class="in3"></span><span class="var">valueEnd</span> - <span class="var">valueBegin</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">entrySize</span> = <span class="var">valueLength</span> +<br/>
					<span class="in2"></span><span class="keyword">sizeof</span>(<span class="type">struct MacroEntry</span>);<br/>
					<span class="in1"></span><span class="var">result</span> = <span class="var">malloc</span>(<span class="var">entrySize</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>
					<span class="end">@end(<span class="macro-name">allocate entry on heap</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Die Größe der Struktur wird um die Anzahl der zu
						kopierenden Bytes vergrößert
					</li><li>
						Wenn nicht genug Speicher vorhanden ist, dann
						wird das Programm beendet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">copy entry values</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
					<span class="in2"></span><span class="fn">memcpy</span>(<br/>
					<span class="in3"></span><span class="var">result</span>-&gt;<span class="var">value</span>, <span class="var">valueBegin</span>,<br/>
		 			<span class="in3"></span><span class="var">valueLength</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">valueEnd</span> =<br/>
					<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">value</span> + <span class="var">valueLength</span>;<br/>
					<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">macro</span> = <span class="var">macro</span>;<br/>
					<span class="end">@end(<span class="macro-name">copy entry values</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Die Bytes werden nur kopiert, wenn welche
						übergeben wurden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry *</span><br/>
					<span class="in1"></span><span class="fn">allocEmptyMacroEntry</span>() {<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="fn">allocMacroEntry</span>(<br/>
					<span class="in3"></span><span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Für Tests ist es praktisch, leere Einträge
						anzulegen
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Einträge freigeben</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">freeMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">while</span> (<span class="var">entry</span>) {<br/>
					<span class="in3"></span><span class="type">struct MacroEntry *</span><span class="var">link</span> =<br/>
					<span class="in4"></span><span class="var">entry</span>-&gt;<span class="var">link</span>;<br/>
					<span class="in3"></span><span class="fn">free</span>(<span class="var">entry</span>);<br/>
					<span class="in3"></span><span class="var">entry</span> = <span class="var">link</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Eintrag freigegeben wird, so werden
						auch alle verlinkten Einträge freigegeben
					</li><li>
						Referenzierte Makros werden nicht mit
						freigegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">forward declarations</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry</span>;<br/>
					<span class="in1"></span><span class="keyword">void</span> <span class="fn">freeMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span><br/>
					<span class="in1"></span>);<br/>
					<span class="end">@end(<span class="macro-name">forward declarations</span>)</span><br/>
					<br/>
					<span class="add">@add(<span class="macro-name">free macros entries</span>)</span><br/>
					<span class="in1"></span><span class="fn">freeMacroEntry</span>(<span class="var">macro</span>-&gt;<span class="var">firstEntry</span>);<br/>
					<span class="end">@end(<span class="macro-name">free macros entries</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Makro freigegeben wird, so werden auch
						die anhängenden Einträge freigegeben
					</li><li>
						Damit die Funktion im
						<code class="fn">freeMacro</code> sichtbar ist,
						wird sie in der Include-Sektion definiert
					</li>
				</ul>
			</div>
		</div>
		<h2>Auf Attribute zugreifen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">int</span> <span class="fn">getMacroEntryValueSize</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="keyword">if</span> (! <span class="var">entry</span>) {<br/>
					<span class="in3"></span><span class="keyword">return</span> <span class="num">0</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">entry</span>-&gt;<span class="var">valueEnd</span> -<br/>
  					<span class="in3"></span><span class="var">entry</span>-&gt;<span class="var">value</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Liefert die Anzahl der enthaltenen Bytes
					</li>
				</ul>
			</div>
		</div>
		<h2>Unit Tests</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocEmptyMacroEntry</span>();<br/>
					<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">macro</span>);<br/>
					<br/>
					<span class="in2"></span><span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein leerer Eintrag hat keinen Nachfolger
					</li><li>
						Und kein Makro
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocEmptyMacroEntry</span>();<br/>
					<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in3"></span><span class="fn">getMacroEntryValueSize</span>(<br/>
					<span class="in4"></span><span class="var">entry</span>) == <span class="num">0);</span><br/>
					<br/>
					<span class="in2"></span><span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein leerer Eintrag hat keine Bytes
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry *</span><br/>
					<span class="in1"></span><span class="fn">allocTestMacroEntry</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">value</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span> = <span class="var">value</span> +<br/>
					<span class="in3"></span><span class="fn">strlen</span>(<span class="var">value</span>);<br/>
					<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="fn">allocMacroEntry</span>(<br/>
					<span class="in3"></span><span class="keyword">NULL</span>, <span class="var">value</span>, <span class="var">end</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Test-Konstruktor bekommt eine
						Null-terminierte Zeichenkette als Argument
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacroEntry</span>(<span class="str">"abc"</span>);<br/>
					<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in3"></span><span class="fn">getMacroEntryValueSize</span>(<br/>
					<span class="in4"></span><span class="var">entry</span>) == <span class="num">3);</span><br/>
					<br/>
					<span class="in2"></span><span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag hat die korrekte Anzahl an Bytes
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacroEntry</span>(<span class="str">"abc"</span>);<br/>
					<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in3"></span><span class="fn">memcmp</span>(<span class="var">entry</span>-&gt;<span class="var">value</span>,<br/>
					<span class="in4"></span><span class="str">"abc"</span>, <span class="num">3</span>) == <span class="num">0);</span><br/>
					<br/>
					<span class="in2"></span><span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Die Bytes eines Eintrags stimmen überein
					</li>
				</ul>
			</div>
		</div>
		<h2>Einträge zu Makros hinzufügen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">addEntryToMacro</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">assert add entry</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">if</span> (<span class="var">macro</span>-&gt;<span class="var">firstEntry</span>) {<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">append entry</span>)</span>;<br/>
					<span class="in2"></span>} <span class="keyword">else</span> {<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">set first entry</span>)</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag wird entweder an das Ende der Liste
						der Einträge angehängt
					</li><li>
						Oder als neuer Kopf der Liste gesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">assert add entry</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>
					<span class="end">@end(<span class="macro-name">assert add entry</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Makro darf nicht
						<code class="keyword">NULL</code> sein
					</li><li>
						Eintrag darf nicht
						<code class="keyword">NULL</code> sein
					</li><li>
						Eintrag darf noch nicht in einer anderen Liste
						hängen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">append entry</span>)</span><br/>
					<span class="in1"></span><span class="var">macro</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">link</span> = <span class="var">entry</span>;<br/>
					<span class="in1"></span><span class="var">macro</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>
					<span class="end">@end(<span class="macro-name">append entry</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Da es schon Einträge gibt, muss es bereits einen
						letzten geben
					</li><li>
						Dessen neuer Nachfolger ist der neue Eintrag
					</li><li>
						Der neue Eintrag wird zum neuen letzten Eintrag
					</li><li>
						Der Nachfolger von
						<code class="var">entry</code> ist bereits
						<code class="keyword">NULL</code>
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">set first entry</span>)</span><br/>
					<span class="in1"></span><span class="var">macro</span>-&gt;<span class="var">firstEntry</span> = <span class="var">entry</span>;<br/>
					<span class="in1"></span><span class="var">macro</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>
					<span class="end">@end(<span class="macro-name">set first entry</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der erste Eintrag wird auch als letzter Eintrag
						gesetzt
					</li><li>
						Der Nachfolger von
						<code class="var">entry</code> ist bereits
						<code class="keyword">NULL</code>
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocEmptyMacroEntry</span>();<br/>
					<span class="in2"></span><span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>

					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in3"></span><span class="var">macro</span>-&gt;<span class="var">firstEntry</span> == <span class="var">entry</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der erste Eintrag im Makro wird gesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocEmptyMacroEntry</span>();<br/>
					<span class="in2"></span><span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>

					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in3"></span><span class="var">macro</span>-&gt;<span class="var">lastEntry</span> == <span class="var">entry</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der letzte Eintrag im Makro wird gesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">first</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">second</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">add two entries</span>)</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">check first of 2</span>)</span>;<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zwei Einträge werden an ein Makro angehängt
					</li><li>
						Der erste Eintrag muss gesetzt bleiben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">add two entries</span>)</span><br/>
					<span class="in1"></span><span class="var">macro</span> = <span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
					<span class="in1"></span><span class="var">first</span> = <span class="fn">allocEmptyMacroEntry</span>();<br/>
					<span class="in1"></span><span class="var">second</span> = <span class="fn">allocEmptyMacroEntry</span>();<br/>
					<br/>
					<span class="in1"></span><span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">first</span>);<br/>
					<span class="in1"></span><span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">second</span>);<br/>

					<span class="end">@end(<span class="macro-name">add two entries</span>)</span><br/>
					<br/>
					<span class="add">@add(<span class="macro-name">check first of 2</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> == <span class="var">first</span>);<br/>
					<span class="expand">@expand(<span class="macro-name">check first of 2</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zwei Einträge werden an ein Makro angehängt
					</li><li>
						Der erste Eintrag muss gesetzt bleiben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">first</span>;<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">second</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">add two entries</span>)</span>;<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in3"></span><span class="var">macro</span>-&gt;<span class="var">lastEntry</span> == <span class="var">second</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zwei Einträge werden an ein Makro angehängt
					</li><li>
						Der letzte Eintrag muss gesetzt werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">addBytesToMacro</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">value</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">valueEnd</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in3"></span><span class="fn">allocMacroEntry</span>(<br/>
					<span class="in4"></span><span class="keyword">NULL</span>, <span class="var">value</span>, <span class="var">valueEnd</span><br/>
					<span class="in3"></span>);<br/>
					<span class="in2"></span><span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Für die Daten wird ein neuer Eintrag angelegt
					</li><li>
						Dieser wird an das Makro angehängt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">define cycle check</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">addMacroToMacro</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">child</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">child</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">avoid macro cycles</span>)</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">reuse last entry</span>)</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">add macro entry</span>)</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Bevor ein Makro hinzugefügt werden kann, muss
						sichergestellt werden, dass kein Zykel entsteht
					</li><li>
						Ein Zykel liegt vor, wenn
						<code class="var">macro</code> gleich
						<code class="var">child</code> ist
					</li><li>
						Oder bereits direkt oder indirekt zu
						<code class="var">child</code> hinzugefügt wurde
					</li><li>
						Falls der letzte Eintrag noch kein Makro hat,
						wird dieser Eintrag verwendet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">reuse last entry</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> &amp;&amp;<br/>
					<span class="in2"></span>! <span class="var">macro</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">macro</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="var">macro</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">macro</span> = <span class="var">child</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">reuse last entry</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn das Makro-Attribut im letzten Eintrag noch
						nicht benutzt wird, kann dieses verwendet werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">add macro entry</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in2"></span><span class="fn">allocMacroEntry</span>(<br/>
					<span class="in3"></span><span class="var">child</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span><span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>
					<span class="end">@end(<span class="macro-name">add macro entry</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Sonst muss ein neuer Eintrag mit dem Makro
						angelegt werden
					</li>
				</ul>
			</div>
		</div>
		<h2>Makros serialisieren</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">typedef</span> <span class="type">void</span> <span class="type">Consumer</span>(<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">begin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span>,<br/>
					<span class="in2"></span><span class="type">void *</span><span class="var">context</span><br/>
					<span class="in1"></span>);<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						<span class="type">Callback</span> Instanzen
						werden als Callbacks verwendet, um Byte-Folgen
						zu konsumieren
					</li><li>
						Ein freier Kontext-Parameter wird mit übergeben
					</li><li>
						Damit lassen sich objekt-ähnliche Strukturen
						realisieren
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">serializeMacro</span>(<br/>
  					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro,</span><br/>
  					<span class="in2"></span><span class="type">Consumer</span> <span class="var">consumer</span>,<br/>
  					<span class="in2"></span><span class="type">void *</span> <span class="var">context</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">consumer</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">iterate entries</span>)</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Jeder Eintrag wird nacheinander bearbeitet
					</li><li>
						Makros in Einträgen werden rekursiv ausgegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">iterate entries</span>)</span><br/>
  					<span class="in1"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
  					<span class="in2"></span><span class="var">macro</span>-&gt;<span class="var">firstEntry</span>;<br/>
					<span class="in1"></span><span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">serialize bytes</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">if</span> (<span class="var">entry</span>-&gt;<span class="var">macro</span>) {<br/>
					<span class="in3"></span><span class="fn">serializeMacro</span>(<span class="var">entry</span>-&gt;<span class="var">macro</span>,<br/>
 					<span class="in4"></span><span class="var">consumer</span>, <span class="var">context</span><br/>
					<span class="in3"></span>);<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">iterate entries</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Für jeden Eintrag werden zuerst die Bytes
						ausgegeben
					</li><li>
						Dann wird rekursiv das Makro ausgegeben, falls
						vorhanden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">serialize bytes</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="fn">getMacroEntryValueSize</span>(<span class="var">entry</span>)) {<br/>
					<span class="in2"></span><span class="var">consumer</span>(<br/>
	   				<span class="in3"></span><span class="var">entry</span>-&gt;<span class="var">value</span>,<br/>
					<span class="in3"></span><span class="var">entry</span>-&gt;<span class="var">valueEnd</span>,<br/>
					<span class="in3"></span><span class="var">context</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">serialize bytes</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn es Bytes in dem Eintrag gibt, wird der
						<code class="var">consumer</code> mit ihnen
						aufgerufen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct TestConsumerContext</span> {<br/>
					<span class="in2"></span><span class="type">char *</span><span class="var">current</span>;<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span>;<br/>
					<span class="in2"></span><span class="type">char </span><span class="var">buffer</span><span class="type">[]</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zum Testen gibt es einen speziellen
						<code class="type">Consumer</code>.
					</li><li>
						Dessen Kontext enthält einen Buffer.
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">testConsumer</span> (<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">begin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span>,<br/>
					<span class="in2"></span><span class="type">void *</span><span class="var">context</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">begin</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">begin</span> &lt;= <span class="var">end</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">context</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">add to test consumer</span>)</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Test Consumer fügt die übergegebenen Daten im
						Buffer des Kontexts ein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">add to test consumer</span>)</span><br/>
					<span class="in1"></span><span class="type">struct TestConsumerContext *</span><span class="var">ctx</span> =<br/>
					<span class="in2"></span><span class="var">context</span>;<br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">length</span> = <span class="var">end</span> - <span class="var">begin</span>;<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<br/>
					<span class="in2"></span><span class="var">ctx</span>-&gt;<span class="var">current</span> + <span class="var">length</span> &lt;= <span class="var">ctx</span>-&gt;<span class="var">end</span><br/>
					<span class="in1"></span>);<br/>
					<span class="in1"></span><span class="fn">memcpy</span>(<span class="var">ctx</span>-&gt;<span class="var">current</span>, <span class="var">begin</span>, <span class="var">length</span>);<br/>
					<span class="in1"></span><span class="var">ctx</span>-&gt;<span class="var">current</span> += <span class="var">length</span>;<br/>
					<span class="end">@end(<span class="macro-name">add to test consumer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn genügend Platz im Buffer ist, werden die
						Bytes hineinkopiert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct TestConsumerContext *</span><br/>
					<span class="in1"></span><span class="fn">allocTestConsumerContext</span>(<span class="type">int</span> <span class="var">size</span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">size</span> &gt;= 0);<br/>
					<span class="in2"></span><span class="type">struct TestConsumerContext *</span><br/>
					<span class="in2"></span><span class="var">context</span> = <span class="fn">malloc</span>(<span class="var">size</span> + <span class="keyword">sizeof</span>(<br/>
					<span class="in3"></span><span class="type">struct TestConsumerContext</span>));<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">context</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">init test consumer</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">context</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Buffer wird direkt in der Struktur angelegt
					</li><li>
						Die Strukturen können nur auf dem Heap angelegt
						werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">init test consumer</span>)</span><br/>
					<span class="in1"></span><span class="var">context</span>-&gt;<span class="var">current</span> =
					<span class="var">context</span>-&gt;<span class="var">buffer</span>;<br/>
					<span class="in1"></span><span class="var">context</span>-&gt;<span class="var">end</span> =<br/>
					<span class="in2"></span><span class="var">context</span>-&gt;<span class="var">buffer</span> + <span class="var">size</span>;<br/>
					<span class="end">@end(<span class="macro-name">init test consumer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zum schnellen Zugriff wird ein Zeiger auf das
						aktuelle Ende und das Ende des Buffers
						abgelegt
					</li><li>
						Die Größe des Buffers kann beim Einfügen nicht
						überschritten werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">testMacro</span>(<span class="type">struct Macro *</span><br/>
					<span class="in2"></span><span class="var">macro</span>, <span class="type">const char *</span><span class="var">expected</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">size</span> = <span class="fn">strlen</span>(<span class="var">expected</span>);<br/>
					<span class="in2"></span><span class="type">struct TestConsumerContext *</span><br/>
					<span class="in2"></span><span class="var">context</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestConsumerContext</span>(<br/>
					<span class="in4"></span><span class="var">size</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">serialize test macro</span>)</span>;<br/>
					<span class="in2"></span><span class="fn">free</span>(<span class="var">context</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Diese Hilfsfunktion prüft ob die Serialisierung
						eines Makros der Erwartung entspricht
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">serialize test macro</span>)</span><br/>
					<span class="in1"></span><span class="fn">serializeMacro</span>(<span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="var">testConsumer</span>, <span class="var">context</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">context</span>-&gt;<span class="var">current</span> -<br/>
					<span class="in2"></span><span class="var">context</span>-&gt;<span class="var">buffer</span> == <span class="var">size</span>);<br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="fn">memcmp</span>(<span class="var">expected</span>,<br/>
					<span class="in2"></span><span class="var">context</span>-&gt;<span class="var">buffer</span>, <span class="var">size</span>) == 0);<br/>
					<span class="end">@end(<span class="macro-name">serialize test macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Serialisiert das Makro
					</li><li>
						Der Buffer muss die erwarteten Werte enthalten
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">addStringToMacro</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">str</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">size</span> = <span class="fn">strlen</span>(<span class="var">str</span>);<br/>
					<span class="in2"></span><span class="fn">addBytesToMacro</span>(<br/>
					<span class="in3"></span><span class="var">macro</span>, <span class="var">str</span>, <span class="var">str</span> + <span class="var">size</span><br/>
					<span class="in2"></span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Zu Testzwecken kann eine Null-terminierte
						Zeichenkette hinzugefügt werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
					<span class="in2"></span><span class="fn">addStringToMacro</span>(<span class="var">macro</span>, <span class="str">"abc"</span>);<br/>
					<span class="in2"></span><span class="fn">addStringToMacro</span>(<span class="var">macro</span>, <span class="str">"def"</span>);<br/>
					<span class="in2"></span><span class="fn">testMacro</span>(<span class="var">macro</span>, <span class="str">"abcdef"</span>);<br/>
					<span class="in2"></span><span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Prüft, ob zwei Strings richtig serialisiert
						werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">macro unit tests</span>)</span> {<br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="var">a</span> =<br/>
					<span class="in2"></span><span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="var">b</span> =<br/>
					<span class="in2"></span><span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
					<span class="in1"></span><span class="fn">addStringToMacro</span>(<span class="var">a</span>, <span class="str">"abc"</span>);<br/>
					<span class="in1"></span><span class="fn">addMacroToMacro</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>
					<span class="in1"></span><span class="fn">addStringToMacro</span>(<span class="var">b</span>, <span class="str">"def"</span>);<br/>
					<span class="in1"></span><span class="fn">addMacroToMacro</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>
					<span class="in1"></span><span class="fn">testMacro</span>(<span class="var">b</span>, <span class="str">"abcdefabc"</span>);<br/>
					<span class="in1"></span><span class="fn">freeMacro</span>(<span class="var">a</span>); <span class="fn">freeMacro</span>(<span class="var">b</span>);<br/>
					} <span class="end">@end(<span class="macro-name">macro unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Prüft, ob Makros expandiert werden
					</li>
				</ul>
			</div>
		</div>
		<h2>Zykel im Makro-Graph finden</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">includes</span>)</span><br/>
					<span class="in1"></span><span class="include">#include &lt;<span class="include-name">stdbool.h</span>&gt;</span><br/>
					<span class="end">@end(<span class="macro-name">includes</span>)</span><br/>
				</code></div>
				<ul class="notes">
					<li>
						Boolesche Datenwerte werden benötigt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define cycle check</span>)</span><br/>
					<span class="in1"></span><span class="type">bool</span> <span class="fn">isMacroInMacro</span>(<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">needle</span>,<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">haystack</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">needle</span>);<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">haystack</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">check cycle macro</span>)</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">check cycle entries</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="keyword">false</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define cycle check</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn das Makro das gesuchte ist, dann wurde ein
						Zykel gefunden
					</li><li>
						Danach wird über alle Einträge gesucht
					</li><li>
						Wenn das Makro dort nicht gefunden wurde, dann
						ist es nicht enthalten
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">avoid macro cycles</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(! <span class="fn">isMacroInMacro</span>(<br/>
					<span class="in2"></span><span class="var">macro</span>, <span class="var">child</span><br/>
					<span class="in1"></span>));<br/>
					<span class="end">@end(<span class="macro-name">avoid macro cycles</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein Makro darf nur hinzugefügt werden, wenn es
						den Container nict bereits enthält
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">check cycle macro</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">needle</span> == <span class="var">haystack</span>) {<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="keyword">true</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">check cycle macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn der Container selbst das gesuchte Makro ist,
						liefert die Funktion
						<code class="keyword">true</code> zurück
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">check cycle entries</span>)</span><br/>
					<span class="in1"></span><span class="type">struct MacroEntry *</span><span class="var">entry</span> =<br/>
					<span class="in2"></span><span class="var">haystack</span>-&gt;<span class="var">firstEntry</span>;<br/>
					<span class="in1"></span><span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-><span class="var">link</span>) {<br/>
					<span class="in2"></span><span class="keyword">if</span> (! <span class="var">entry</span>-&gt;<span class="var">macro</span>) { <span class="keyword">continue</span>; }<br/>
					<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isMacroInMacro</span>(<br/>
					<span class="in3"></span><span class="var">needle</span>, <span class="var">entry</span>-&gt;<span class="var">macro</span><br/>
					<span class="in2"></span>)) {<br/>
					<span class="in3"></span><span class="keyword">return</span> <span class="keyword">true</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">check cycle entries</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Alle Makros in den Einträgen werden rekursiv
						untersucht
					</li><li>
						Damit wird der ganze Graph durchsucht
					</li>
				</ul>
			</div>
		</div>
		<h2>Macro-Collection</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="define">#define <span class="name">MACRO_SLOTS</span> 128</span><br/>
					<br/>
					<span class="in1"></span><span class="type">struct MacroMap</span> {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macros</span><span class="type">[</span><br/>
					<span class="in3"></span><span class="type">MACRO_SLOTS</span><br/>
					<span class="in2"></span><span class="type">]</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Eine Kollektion von Makros ist ein Array von
						Makro-Ketten
					</li><li>
						Alle Felder müssen mit
						<code class="keyword">NULL</code> initialisiert
						werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">clearMacroMap</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroMap *</span><span class="var">map</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct Macro **</span><span class="var">cur</span> = <span class="var">map</span>-&gt;<span class="var">macros</span>;<br/>
					<span class="in2"></span><span class="type">struct Macro **</span><span class="var">end</span> =<br/>
					<span class="in3"></span><span class="var">cur</span> + <span class="var">MACRO_SLOTS</span>;<br/>
					<span class="in2"></span><span class="keyword">for</span> (; <span class="var">cur</span> &lt; <span class="var">end</span>; ++<span class="var">cur</span>) {<br/>
					<span class="in3"></span><span class="fn">freeMacro</span>(*<span class="var">cur</span>); *<span class="var">cur</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Um den Speicher freizugeben, wird jeder Slot
						gelöscht
					</li><li>
						und auf <code class="keyword">NULL</code>
						gesetzt um wieder verwendet zu werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">int</span> <span class="fn">calcHash</span>(<span class="type">const char *</span><span class="var">begin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">begin</span>);<br/>
					<span class="in2"></span><span class="type">unsigned</span> <span class="var">hash</span> = <span class="num">0xf1e2d3c4</span>;<br/>
					<span class="in2"></span><span class="keyword">while</span> (*<span class="var">begin</span> &amp;&amp; <span class="var">begin</span> != <span class="var">end</span>) {<br/>
					<span class="in3"></span><span class="var">hash</span> ^= *<span class="var">begin</span>++;<br/>
					<span class="in3"></span><span class="var">hash</span> = (<span class="var">hash</span> &lt;&lt; 3) |<br/>
					<span class="in4"></span>(<span class="var">hash</span> &gt;&gt; 29);<br/>
					<span class="in2"></span>}<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">hash</span> % <span class="var">MACRO_SLOTS</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Hash wird über den Namen des Makros erstellt
					</li><li>
						Der Name kann entweder durch ein Null-Byte
						abgeschlossen werden
					</li><li>
						Oder ein Ende wird direkt angegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">allocMacroInMap</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroMap *</span><span class="var">map</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">begin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> =<br/>
					<span class="in3"></span><span class="fn">allocMacro</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">insert in slot</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">macro</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein neues Makro wird erstellt
					</li><li>
						Und in der Hash-Map abgelegt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">insert in slot</span>)</span><br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
					<span class="in1"></span><span class="var">macro</span>-&gt;<span class="var">link</span> = <span class="var">map</span>-&gt;<span class="var">macros</span>[<span class="var">hash</span>];<br/>
					<span class="in1"></span><span class="var">map</span>-&gt;<span class="var">macros</span>[<span class="var">hash</span>] = <span class="var">macro</span>;
					<span class="end">@end(<span class="macro-name">insert in slot</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Makros werden im Slot eingefügt
					</li><li>
						Neue Makros überlagern alte Slots mit gleichem
						Namen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">findMacroInMap</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroMap *</span><span class="var">map</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">begin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> = <span class="fn">NULL</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">find macro in slot</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">macro</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Liefert das erste Makro mit dem übergebenen
						Namen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">find macro in slot</span>)</span><br/>
					<span class="in1"></span><span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
					<span class="in1"></span><span class="var">macro</span> = <span class="var">map</span>-&gt;<span class="var">macros</span>[<span class="var">hash</span>];<br/>
					<span class="in1"></span><span class="keyword">for</span> (; <span class="var">macro</span>; <span class="var">macro</span> = <span class="var">macro</span>-&gt;<span class="var">link</span>) {<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">a</span> = <span class="var">begin</span>;<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">b</span> = <span class="var">macro</span>-&gt;<span class="var">name</span>;<br/>
					<span class="in2"></span><span class="keyword">while</span> (<span class="var">a</span> != <span class="var">end</span>) {<br/>
					<span class="in3"></span><span class="keyword">if</span> (*<span class="var">a</span>++ != *<span class="var">b</span>++) { <span class="keyword">break</span>; }<br/>
					<span class="in2"></span>}<br/>
					<span class="in2"></span><span class="keyword">if</span> (<span class="var">a</span> == <span class="var">end</span> &amp;&amp; ! *<span class="var">b</span>) {<br/>
					<span class="in3"></span><span class="keyword">return</span> <span class="var">macro</span>; }<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">find macro in slot</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Im passenden Hash-Slot werden die Namen der
						Makros verglichen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define macro</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span><span class="fn">getMacroInMap</span>(<br/>
					<span class="in2"></span><span class="type">struct MacroMap *</span><span class="var">map</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">begin</span>,<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">struct Macro *</span><span class="var">macro</span> = NULL;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">get macro find</span>)</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">get macro alloc</span>)</span>;<br/>
					<span class="in2"></span><span class="keyword">return</span> <span class="var">macro</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define macro</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Liefert Makro mit angegebenen Namen oder legt
						ein neues Makro mit diesem Namen an
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">get macro find</span>)</span><br/>
					<span class="in1"></span><span class="var">macro</span> = <span class="fn">findMacroInMap</span>(<br/>
					<span class="in2"></span><span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
					<span class="in1"></span>);<br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
					0{}<span class="keyword">return</span> <span class="var">macro</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">get macro find</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn das Makro in der Kollektion vorhanden ist,
						wird dieses verwendet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">get macro alloc</span>)</span><br/>
					<span class="in1"></span><span class="var">macro</span> = <span class="fn">allocMacroInMap</span>(<br/>
					<span class="in2"></span><span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
					<span class="in1"></span>);<br/>
					<span class="end">@end(<span class="macro-name">get macro alloc</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Sonst wird ein neues Makro angelegt
					</li>
				</ul>
			</div>
		</div>
		<h1>Buffer</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">global elements</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">define buffer</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">global elements</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Makros sind global sichtbare Strukturen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">perform unit tests</span>)</span><br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">buffer unit tests</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">perform unit tests</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Buffer haben ihre eigenen Unit Tests
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define buffer</span>)</span><br/>
					<span class="in1"></span>#define INIT_BUFFER_SIZE 16<br/>
					<br/>
					<span class="in1"></span><span class="type">struct Buffer</span> {<br/>
					<span class="in2"></span><span class="type">char</span> <span class="var">initial</span><span class="type">[INIT_BUFFER_SIZE]</span>;<br/>
					<span class="in2"></span><span class="type">char *</span><span class="var">buffer</span>;<br/>
					<span class="in2"></span><span class="type">char *</span><span class="var">current</span>;<br/>
					<span class="in2"></span><span class="type">const char *</span><span class="var">end</span>;<br/>
					<span class="in1"></span>};<br/>
					<span class="end">@end(<span class="macro-name">define buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Ein Buffer kann bis zu
						<code>INIT_BUFFER_SIZE</code> bytes aufnehmen
					</li><li>
						Bei weiteren Bytes wird der Speicher im Heap
						angelegt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define buffer</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">addToBuffer</span>(<br/>
					<span class="in2"></span><span class="type">struct Buffer *</span><span class="var">buffer</span>, <span class="type">char</span> ch<br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">buffer</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">may initialize buffer</span>)</span><br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">assure buffer size</span>)</span><br/>
					<span class="in2"></span>*<span class="var">buffer</span>-><span class="var">current</span>++ = <span class="var">ch</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn die Struktur leer ist, muss sie auf den
						interenen Buffer initialisiert werden
					</li><li>
						Zusätzlich muss sicher gestellt werden, dass ein
						weiteres Byte angefügt werden kann
					</li><li>
						Dann wird das Byte angefügt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">may initialize buffer</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (! <span class="var">buffer</span>-&gt;<span class="var">buffer</span>) {<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span> =<br/>
					<span class="in3"></span><span class="var">buffer</span>-&gt;<span class="var">initial</span>;<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">current</span> =<br/>
					<span class="in3"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span>;<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">end</span> =<br/>
					<span class="in3"></span><span class="var">buffer</span>-&gt;<span class="var">initial</span> +<br/>
					<span class="in4"></span>INIT_BUFFER_SIZE;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">may initialize buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn der interne Buffer nicht gesetzt ist, wird
						er auf den enthaltenen Bereich gesetzt
					</li><li>
						Das stellt sicher, dass ein initialisierter
						Buffer keinen Speicher im Heap belegt
					</li><li>
						Mit <code class="fn">eraseBuffer</code> kann
						ggf. vorhandener Heap-Speicher freigegeben werden
					</li><li>
						Und der Buffer trotzdem weiter benutzt werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">assure buffer size</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">current</span> &gt;= <span class="var">buffer</span>-&gt;<span class="var">end</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">size</span> = <span class="var">buffer</span>-&gt;<span class="var">current</span> -<br/>
					<span class="in3"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span>;<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">newSize</span> = <span class="num">2</span> * <span class="var">size</span>;<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">reallocate buffer</span>)</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">assure buffer size</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn der Buffer ausgeschöpft ist, dann wird seine
						Größe verdoppelt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">reallocate buffer</span>)</span><br/>
					<span class="in1"></span><span class="type">char *</span><span class="var">newBuffer</span>;<br/>
					<span class="in1"></span><span class="keyword">if</span> (<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span> == <span class="var">buffer</span>-&gt;<span class="var">initial</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="var">newBuffer</span> = <span class="fn">malloc</span>(<span class="var">newSize</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">copy initial buffer</span>)</span>;<br/>
					<span class="in1"></span>} <span class="keyword">else</span> {<br/>
					<span class="in2"></span><span class="var">newBuffer</span> = <span class="fn">realloc</span>(<br/>
					<span class="in3"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span>, <span class="var">newSize</span>);<br/>
					<span class="in1"></span>}<br/>
					<span class="in1"></span><span class="expand">@expand(<span class="macro-name">adjust buffer pointers</span>)</span>;<br/>
					<span class="end">@end(<span class="macro-name">reallocate buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn der initiale Buffer ausgeschöpft ist, muss
						neuer Speicher angelegt und manuell befüllt
						werden
					</li><li>
						Andernfalls kann der Speicherblock im Heap 
						vergrößert werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">copy initial buffer</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">newBuffer</span>);<br/>
					<span class="in1"></span><span class="fn">memcpy</span>(<br/>
					<span class="in2"></span><span class="var">newBuffer</span>, <span class="var">buffer</span>-&gt;<span class="var">buffer</span>, <span class="var">size</span>
					<span class="in1"></span>);<br/>
					<span class="end">@end(<span class="macro-name">copy initial buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Vom initialen Buffer werden die Werte direkt
						kopiert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">adjust buffer pointers</span>)</span><br/>
					<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">newBuffer</span>);<br/>
					<span class="in1"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span> = <span class="var">newBuffer</span>;<br/>
					<span class="in1"></span><span class="var">buffer</span>-&gt;<span class="var">current</span> = <span class="var">newBuffer</span> + <span class="var">size</span>;<br/>
					<span class="in1"></span><span class="var">buffer</span>-&gt;<span class="var">end</span> = <span class="var">newBuffer</span> + <span class="var">newSize</span>;<br/>
					<span class="end">@end(<span class="macro-name">adjust buffer pointers</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define buffer</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">resetBuffer</span>(<br/>
					<span class="in2"></span><span class="type">struct Buffer *</span><span class="var">buffer</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">buffer</span>);<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">current</span> = <span class="var">buffer</span>-&gt;<span class="var">buffer</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Um einen Buffer wieder zu verwenden, der
						<code class="var">current</code> muss auf
						<code class="var">buffer</code> zurück
						gesetzt werden
					</li><li>
						Das funktioniert auch, wenn der initiale Buffer
						verwendet wird
					</li><li>
						Oder die Zeiger noch
						<code class="keyword">NULL</code> sind
					</li><li>
						Es wird kein Speicher freigegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">define buffer</span>)</span><br/>
					<span class="in1"></span><span class="type">void</span> <span class="fn">eraseBuffer</span>(<br/>
					<span class="in2"></span><span class="type">struct Buffer *</span><span class="var">buffer</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">buffer</span>);<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">erase heap buffer</span>)</span>;<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">current</span> = <span class="var">buffer</span>-&gt;<span class="var">buffer</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">define buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Buffer auf dem Heap angelegt wurde,
						wird dieser freigegeben
					</li><li>
						Zusätzlich wird der aktuelle Zeiger auf den
						Anfang zurückgesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">erease heap buffer</span>)</span><br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">buffer</span>-&gt;<span class="var">buffer</span> &amp;&amp;<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span> != <span class="var">buffer</span>-&gt;<span class="var">initial</span><br/>
					<span class="in1"></span>) {<br/>
					<span class="in2"></span><span class="fn">free</span>(<span class="var">buffer</span>-&gt;<span class="var">buffer</span>);<br/>
					<span class="in2"></span><span class="var">buffer</span>-&gt;<span class="var">buffer</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">erase buffer</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn wir nicht den internen Buffer verwenden,
						wird der Buffer freigegeben
					</li><li>
						Und der Buffer-Zeiger wird gelöscht
					</li>
				</ul>
			</div>
		</div>
		<h1>Input Dateien lesen</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">read source file</span>)</span><br/>
					<span class="in1"></span>{<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">additional read vars</span>)</span>;<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">last</span> = <span class="fn">fgetc</span>(<span class="var">input</span>);<br/>
					<span class="in2"></span><span class="type">int</span> <span class="var">ch</span> = <span class="fn">fgetc</span>(<span class="var">input</span>);<br/>
					<span class="in2"></span><span class="keyword">while</span> (<span class="var">ch</span> != <span class="var">EOF</span>) {<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">process current char</span>)</span>;<br/>
					<span class="in3"></span><span class="var">last</span> = <span class="var">ch</span>; <span class="var">ch</span> = <span class="fn">fgetc</span>(<span class="var">input</span>);<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">read source file</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Neben dem aktuellen Zeichen wird auch das letzte
						Zeichen aufgehoben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">process current char</span>)</span><br/>
					<span class="in1"></span><span class="keyword">switch</span> (<span class="var">ch</span>) {<br/>
					<span class="in2"></span><span class="keyword">case</span> <span class="str">'{'</span>:<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">process open brace</span>)</span>;<br/>
					<span class="in3"></span><span class="keyword">break</span>;<br/>
					<span class="in2"></span><span class="keyword">case</span> '}':<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">process close brace</span>)</span>;<br/>
					<span class="in3"></span><span class="keyword">break</span>;<br/>
					<span class="in2"></span><span class="keyword">default</span>:<br/>
					<span class="in3"></span><span class="expand">@expand(<span class="macro-name">process other char</span>)</span>;<br/>
					<span class="in1"></span>}<br/>
					<span class="end">@end(<span class="macro-name">process current char</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Beim Parsen kommt es nur auf das Öffnen und
						Schließen von Mengenklammern an
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">additional read vars</span>)</span><br/>
					<span class="in1"></span><span class="type">struct Macro *</span> <span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
					<span class="end">@end(<span class="macro-name">additional read vars</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wir unterscheiden, ob wir in einem Code-Block
						sind, oder außerhalb
					</li><li>
						In einem Code sind wir sogar in einem Makro,
						dessen Inhalt gelesen wird
					</li><li>
						Am Anfang sind wir außerhalb eines Code-Blocks
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">additional read vars</span>)</span><br/>
					<span class="in1"></span><span class="type">char</span> <span class="var">openCh</span> = <span class="str">'\0'</span>;<br/>
					<span class="end">@end(<span class="macro-name">additional read vars</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Der Befehl vor einer öffnenden Mengenklammer
						wird in dieser Variable zwischengespeichert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">additional read vars</span>)</span><br/>
					<span class="in1"></span><span class="type">char</span> <span class="var">name</span><span class="type">[128]</span>;<br/>
					<span class="in1"></span><span class="type">char *</span><span class="var">nameCur</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in1"></span><span class="type">const char *</span><span class="var">nameEnd</span> = <span class="var">name</span> +<br/>
					<span class="in2"></span><span class="keyword">sizeof</span>(<span class="var">name</span>);<br/>
					<span class="end">@end(<span class="macro-name">additional read vars</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn <code class="var">nameCur</code> gesetzt
						ist, dann wird ein Name in Buffer gelesen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">process close brace</span>)</span> {<br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">nameCur</span>) {<br/>
					<span class="in2"></span><span class="expand">@expand(<span class="macro-name">process macro name</span>)</span>;<br/>
					<span class="in2"></span><span class="var">nameCur</span> = <span class="keyword">NULL</span>;<br/>
					<span class="in1"></span>}<br/>
					} <span class="end">@end(<span class="macro-name">process close brace</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Bei einer schließenden Mengenklammer wird der
						Makro-Name ausgewertet
					</li><li>
						Danach wird der Namenszeiger zurückgesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">process other char</span>)</span> {<br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">nameCur</span>) {<br/>
					<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">nameCur</span> &lt; <span class="var">nameEnd</span>);<br/>
					<span class="in2"></span>*<span class="var">nameCur</span>++ = <span class="var">ch</span>;<br/>
					<span class="in2"></span><span class="keyword">break</span>;<br/>
					<span class="in1"></span>}<br/>
					} <span class="end">@end(<span class="macro-name">process other char</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Name geparst wird, dann der Namensbuffer
						entsprechend erweitert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">process other char</span>)</span> {<br/>
					<span class="in1"></span><span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
					<span class="in2"></span><span class="fn">putchar</span>(<span class="var">last</span>);<br/>
					<span class="in1"></span>}<br/>
					} <span class="end">@end(<span class="macro-name">process other char</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn es ein aktuelles Makro gibt, dann müssen
						sonstige Zeichen dort angefügt werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					<span class="add">@add(<span class="macro-name">process open brace</span>)</span> {<br/>
					<span class="in1"></span><span class="keyword">if</span> (! <span class="var">macro</span>) {<br/>
					<span class="in2"></span><span class="keyword">if</span> (<span class="var">last</span> == <span class="str">'a'</span>) {<br/>
					<span class="in3"></span><span class="var">openCh</span> = <span class="var">last</span>;<br/>
					<span class="in3"></span><span class="var">nameCur</span> = <span class="var">name</span>;<br/>
					<span class="in2"></span>}<br/>
					<span class="in1"></span>}<br/>
					} <span class="end">@end(<span class="macro-name">process open brace</span>)</span>
				</code></div>
				<ul class="notes">
					<li>
						Wenn außerhalb eines Makros die Folge
						<code>a</code><code>{</code>
						gelesen wird, dann beginnt ein 
						<code class="add">@add</code> Fragment
					</li><li>
						Es folgt der Name des Makros bis zum nächsten
						<code>}</code>
					</li>
				</ul>
			</div>
		</div>
	</body>
</html>
