<!doctype html>
<html lang="de"l>
<head>
<meta charset="utf-8">
<title>HTML Extractor</title><link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>HTML Extractor</h1>
<div class="slides">
<div><div>
<h1>HTML Extractor</h1>
</div>
<ul><li>
 Dieses Dokument ist eine Präsentation, welche die Entwicklung des
  <b>HTML Extractors</b> (<code>hx</code>) beschreibt</li><li>
 Es enthält zusätzlich den gesamten Source-Code von <code>hx</code></li><li>
 Es handelt sich um den Versuch eines neuen Programmier-Konzeptes:
  das <b>Slideware-Programming</b> (SWP).</li><li>
 Viel Spass.</li></ul></div>
</div>
<h2>Funktionsweise von `hx`</h2>
<div class="slides">
<div><div>
<h2>Funktionsweise von `hx`</h2>
</div>
<ul><li>
 <code>hx</code> generiert Source-Code und HTML-Präsentationen aus einem
  Basis-Format</li><li>
 Dieses lehnt an Markdown an und hat die Datei-Endung <code>.x</code></li><li>
 Die Präsentationen bauen Schritt für Schritt das Programm auf</li><li>
 <code>hx</code> kann ebenfalls navigierbare Verweise in die Präsentation einbauen</li></ul></div>
</div>
<h2>Slideware Programming (SWP)</h2>
<div class="slides">
<div><div>
<h2>Slideware Programming (SWP)</h2>
</div>
<ul><li>
 Aus dem Source-Code, der vollständing in einer HTML-Präsentation
  enthalten ist, kann ein ausführbares Programm generiert werden</li><li>
 Dabei wird das Programm schrittweise aufgebaut</li></ul></div>
</div>
<h2>SWP ≠ Literate Programming</h2>
<div class="slides">
<div><div>
<h2>SWP ≠ Literate Programming</h2>
</div>
<ul><li>
 SWP beschreibt nicht nur ein fertiges Programm</li><li>
 Sondern wie das Programm aufgebaut wird</li><li>
 Zu jedem Zeitpunkt muss das bisher beschriebene Programm ausführbar
  sein</li><li>
 Nicht definierte Makros werden zu nichts expandieren</li><li>
 So kann das Verständnis für ein Programm schrittweise erarbeitet
  werden</li></ul></div>
</div>
<h1>Definition des Ablaufs</h1>
<div class="slides">
<div><div>
<h1>Definition des Ablaufs</h1>
</div>
<ul><li>
 Zuerst wird das Haupt-Programm in ganz groben Pinselstrichen skizziert</li><li>
 Nach und nach werden die einzelnen Elemente mit Leben gefüllt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">file: hx.c)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="fn">main</span>(<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">argc</span>, <span class="type">const char **</span><span class="var">argv</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">main body)</span></span><br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">file: hx.c)</span></span><br/>
</code>
</div>
<ul><li>
 Das Hauptprogramm besteht aus der <code><span class="fn">main</span></code>-Funktion</li><li>
 Zusätzlich wird ein Fragment definiert, in welchem globale Elemente
  definiert werden können</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">main body)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">perform unit-tests)</span></span>;<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">process arguments)</span></span>;<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">read source file)</span></span>;<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">serialize fragments)</span></span>;<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">write HTML file)</span></span>;<br/>

<span class="end">@end(<span class="name">main body)</span></span><br/>
</code>
</div>
<ul><li>
 Bei jedem Start werden alle Unit-Tests ausgeführt (um eine umfangreiche
  Testabdeckung zu sichern)</li><li>
 Parameter von der Kommandozeile werden ausgewertet</li><li>
 Dann wird ein Parse-Graph aus Fragmenten aufgebaut</li><li>
 Und das daraus resultierende Programm generiert und übersetzt</li><li>
 Zum Schluss wird die HTML-Präsentation der Seiten in einem zweiten
  Durchgang herausgeschrieben</li></ul></div>
</div>
<h2>Was macht `@expand`?</h2>
<div class="slides">
<div><div>
<h2>Was macht `@expand`?</h2>
</div>
<ul><li>
 <code>@expand</code>-Blöcke beschreiben Makro-Aufrufe</li><li>
 Der Wert des Makros mit dem Namen in Klammern wird anstelle des Aufrufs
  im endgültigen Programm gesetzt</li><li>
 Diese Makros bilden ein zentrales Element von <code>hx</code></li><li>
 Sie können mit <code>@def</code>-<code>@end</code>-Sequenzen definiert werden</li><li>
 Oder mit <code>@add</code>-<code>@end</code> erweitert werden</li><li>
 Ein <code>@expand</code> darf nur einmal aufgelöst werden</li><li>
 Für mehrfache Auflösungen muss <code>@mulitple</code> verwendet werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">includes)</span></span>;<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">define logging)</span></span>;<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">forward declarations)</span></span>;<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 System-Dateien werden vor der Definition von Strukturen und Funktionen
  eingebunden</li><li>
 Auch müssen Macros für das Logging vor den Funktionen definiert werden,
  die sie verwenden</li></ul></div>
</div>
<h1>Minimale Vorbereitung für das Parsen</h1>
<div class="slides">
<div><div>
<h1>Minimale Vorbereitung für das Parsen</h1>
</div>
<ul><li>
 In diesem Abschnitt wird die Grundlage gelegt, um Dateien lesen zu
  können</li><li>
 Während des Lesens kann die aktuelle Datei unterbrochen und zuerst
  eine weitere Datei gelesen werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">includes)</span></span><br/>
<span class="in1"></span>
#include &lt;stdio.h&gt;<br/>
<span class="in1"></span>
#include &lt;stdlib.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>
</code>
</div>
<ul><li>
 Standard File-Funktionen werden vom Programm benötigt</li><li>
 Standard Bibliothek wird für dynamische Speicherverwaltung benötigt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Input</span> {<br/>
<span class="in2"></span>
<span class="type">struct Input *</span><span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="type">FILE *</span><span class="var">file</span>;<br/>
<span class="in2"></span>
<span class="type">char</span> <span class="var">name</span>[];<br/>
<span class="in1"></span>
};<br/>

<br/>
<span class="in1"></span>
<span class="type">struct Input *</span><span class="var">input</span> = <span class="keyword">NULL</span>;<br/>
<span class="in1"></span>
<span class="type">struct Input *</span><span class="var">used</span> = <span class="keyword">NULL</span>;<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 Es gibt immer eine aktuelle Datei, die gerade gelesen wird</li><li>
 Mitten während des Lesens können andere Dateien eingelesen (inkludiert)
  werden</li><li>
 Daher gibt es einen Stapel offener Dateien</li><li>
 Aus der letzten wird aktuell gelesen</li><li>
 Eine Liste aller gelesenen Dateien wird in <code><span class="var">used</span></code> verwaltet</li><li>
 Damit wird verhindert, dass eine Datei mehrfach gelesen wird</li><li>
 Auch signalisiert es der HTML-Ausgabe, welche Dateien generiert
  werden müssen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">pushPath</span>(<span class="type">const char *</span><span class="var">path</span>) {<br/>
<span class="in2"></span>
<span class="type">FILE *</span><span class="var">f</span> = <span class="fn">fopen</span>(<span class="var">path</span>, <span class="str">"r"</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check file for path)</span></span>;<br/>
<span class="in2"></span>
<span class="type">int</span> len = <span class="fn">strlen</span>(<span class="var">path</span>) + <span class="num">1</span>;<br/>
<span class="in2"></span>
<span class="type">struct Input *</span><span class="var">i</span> = <span class="fn">malloc</span>(<br/>
<span class="in3"></span>
<span class="fn">sizeof</span>(<span class="type">struct Input</span>) + <span class="var">len</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check memory for input)</span></span>;<br/>
<span class="in2"></span>
<span class="var">i</span>-&gt;<span class="var">link</span> = <span class="var">input</span>;<br/>
<span class="in2"></span>
<span class="var">i</span>-&gt;<span class="var">file</span> = <span class="var">f</span>;<br/>
<span class="in2"></span>
<span class="fn">memcpy</span>(<span class="var">i</span>-&gt;<span class="var">name</span>, <span class="var">path</span>, <span class="var">len</span>);<br/>
<span class="in2"></span>
<span class="var">input</span> = <span class="var">i</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 Dateien werden über ihren Pfad identifiziert</li><li>
 Dieser wird als Name gespeichert</li><li>
 Die Struktur wird dynamisch so groß gewählt, dass der Name hinein
  passt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">check file for path)</span></span><br/>
<span class="in1"></span>
ASSERT(<br/>
<span class="in2"></span>
f, "can't open [%s]", path<br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">check file for path)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn die Datei nicht geöffnet werden kann, bricht das Programm ab</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">check memory for input)</span></span><br/>
<span class="in1"></span>
ASSERT(<br/>
<span class="in2"></span>
i,<br/>
<span class="in2"></span>
"no memory for input"<br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">check memory for input)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn kein Speicher für die <code><span class="type">struct Input</span></code> vorhanden ist bricht das
  Programm ab</li></ul></div>
</div>
<h1>Kommandozeile</h1>
<div class="slides">
<div><div>
<h1>Kommandozeile</h1>
</div>
<ul><li>
 Die Kommandozeile wird Element für Element abgearbeitet</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
const char *stylesheet =<br/>
<span class="in2"></span>
"slides/slides.css";<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 Für die HTML-Ausgabe wird eine Stylesheet-Datei benötigt</li><li>
 Über die Kommandozeile kann eine alternative Datei angegeben werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process arguments)</span></span><br/>
<span class="in1"></span>
<span class="type">bool</span> someFile = false;<br/>
<span class="in1"></span>
for (int i = 1; i &lt; argc; ++i) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">process argument)</span></span>;<br/>
<span class="in2"></span>
ASSERT(<br/>
<span class="in3"></span>
false,<br/>
<span class="in3"></span>
"unknown argument [%s]",<br/>
<span class="in3"></span>
argv[i]<br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process arguments)</span></span><br/>
</code>
</div>
<ul><li>
 Die Argumente werden einzeln durchgegangen</li><li>
 Wenn sie nicht verwendet werden, bricht das Programm ab</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process argument)</span></span> {<br/>
<span class="in1"></span>
const char prefix[] = "--css";<br/>
<span class="in1"></span>
int len = sizeof(prefix) - 1;<br/>
<span class="in1"></span>
if (memcmp(argv[i], prefix, len) == 0) {<br/>
<span class="in2"></span>
stylesheet = argv[i] + len;<br/>
<span class="in2"></span>
continue;<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">process argument)</span></span><br/>
</code>
</div>
<ul><li>
 Der Pfad zur Stylesheet-Datei kann über die Kommandozeile gesetzt
  werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process argument)</span></span><br/>
<span class="in1"></span>
if (! someFile) {<br/>
<span class="in2"></span>
<span class="fn">pushPath</span>(<span class="var">argv</span>[<span class="num">1</span>]);<br/>
<span class="in2"></span>
someFile = true;<br/>
<span class="in2"></span>
continue;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process argument)</span></span><br/>
</code>
</div>
<ul><li>
 Ansonsten wird das Argument als Pfad der <code>.x</code>-Datei interpretiert</li><li>
 Aus dieser werden HTML-Slides und Source-Code generiert</li><li>
 Es kann nur eine Datei angegeben werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process arguments)</span></span><br/>
<span class="in1"></span>
if (! someFile) {<br/>
<span class="in2"></span>
<span class="fn">pushPath</span>(<span class="str">"index.x"</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process arguments)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn kein Pfad angegeben wurde, wird <code>index.x</code> als Vorgabe verwendet</li></ul></div>
</div>
<h1>Nächstes Zeichen</h1>
<div class="slides">
<div><div>
<h1>Nächstes Zeichen</h1>
</div>
<ul><li>
 Die Funktion <code><span class="fn">nextCh</span></code> liest das nächste Zeichen aus der aktuellen
  Datei</li><li>
 Wenn das Dateiende erreicht ist, wird die nächste Datei aus dem
  Stapel der offenen Dateien geholt</li><li>
 Erst wenn die letzte Datei fertig gelesen wurde, wird ein <code><span class="keyword">EOF</span></code>
  zurück geliefert</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="fn">nextCh</span>() {<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">ch</span> = <span class="keyword">EOF</span>;<br/>
<span class="in2"></span>
<span class="keyword">while</span> (<span class="var">input</span>) {<br/>
<span class="in3"></span>
<span class="var">ch</span> = <span class="fn">fgetc</span>(<span class="var">input</span>-&gt;<span class="var">file</span>);<br/>
<span class="in3"></span>
<span class="keyword">if</span> (<span class="var">ch</span> != <span class="keyword">EOF</span>) { <span class="keyword">break</span>; }<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">get next input file)</span></span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">ch</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn kein <code><span class="keyword">EOF</span></code> gelesen wurde, dann wird das Zeichen zurück
  geliefert</li><li>
 Ansonsten wird aus der nächsten Datei ein Zeichen gelesen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">get next input file)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Input *</span><span class="var">n</span> = <span class="var">input</span>-&gt;<span class="var">link</span>;<br/>
<span class="in1"></span>
<span class="fn">fclose</span>(<span class="var">input</span>-&gt;<span class="var">file</span>);<br/>
<span class="in1"></span>
<span class="var">input</span>-&gt;<span class="var">link</span> = <span class="var">used</span>;<br/>
<span class="in1"></span>
<span class="var">used</span> = <span class="var">input</span>;<br/>
<span class="in1"></span>
<span class="var">input</span> = <span class="var">n</span>;<br/>

<span class="end">@end(<span class="name">get next input file)</span></span><br/>
</code>
</div>
<ul><li>
 Die aktuelle Datei wird geschlossen und in die Liste der bereits
  verarbeiteten Dateien eingereiht</li><li>
 Dann wird der Vorgänger zur aktuellen Datei erklärt</li></ul></div>
</div>
<h1>Buffer</h1>
<div class="slides">
<div><div>
<h1>Buffer</h1>
</div>
<ul><li>
 Einfache Implementierung in C eines Byte-Vektors</li><li>
 Der dynamisch wachsen kann</li></ul></div>
<div><div>
<code>

<span class="include">@include(<span class="name"><a href="buffer.html">buffer.x</a>)</span></span><br/>
</code>
</div>
<ul><li>
 Buffer werden in einer eigenen Datei definiert</li></ul></div>
</div>
<h1>Makros</h1>
<div class="slides">
<div><div>
<h1>Makros</h1>
</div>
<ul><li>
 Makros können während des Parsens erweitert, ersetzt und angewendet
  werden</li><li>
 Ein Haupt-Vorteil von <code>hx</code> gegenüber anderen Makro-Präprozessoren ist
  die Möglichkeit, Makros vor der Definition zu verwenden</li><li>
 Und Makros an mehreren Stellen zu erweitern</li></ul></div>
<div><div>
<code>

<span class="include">@include(<span class="name"><a href="macros.html">macros.x</a>)</span></span><br/>
</code>
</div>
<ul><li>
 Makros werden in einer eigenen Datei definiert</li></ul></div>
</div>
<h1>Eingabe-Dateien lesen</h1>
<div class="slides">
<div><div>
<h1>Eingabe-Dateien lesen</h1>
</div>
<ul><li>
 In diesem Abschnitt werden die Eingabe-Dateien gelesen, um die Makros
  aufzubauen und alle notwendigen Beziehungen zwischen den einzelnen
  Folien zu finden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">read source file)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">global source vars)</span></span>;<br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">additional read vars)</span></span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">last</span> = <span class="fn">nextCh</span>();<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">ch</span> = <span class="var">last</span> != <span class="keyword">EOF</span> ? <span class="fn">nextCh</span>() : <span class="keyword">EOF</span>;<br/>
<span class="in2"></span>
<span class="keyword">while</span> (<span class="var">ch</span> != <span class="var">EOF</span>) {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">process current char)</span></span>;<br/>
<span class="in3"></span>
<span class="var">last</span> = <span class="var">ch</span>; <span class="var">ch</span> = <span class="fn">nextCh</span>();<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">read source file)</span></span><br/>

<br/>
</code>
</div>
<ul><li>
 Neben dem aktuellen Zeichen wird auch das letzte Zeichen aufgehoben</li><li>
 Dabei kann <code>hx</code> auch mit einer leeren Eingabe-Datei umgehen (wenn
  schon das erste Zeichen ein <code><span class="keyword">EOF</span></code> ist)</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process current char)</span></span><br/>
<span class="in1"></span>
<span class="keyword">switch</span> (<span class="var">ch</span>) {<br/>
<span class="in2"></span>
<span class="keyword">case</span> '{':<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">process open brace)</span></span>;<br/>
<span class="in3"></span>
<span class="keyword">break</span>;<br/>
<span class="in2"></span>
<span class="keyword">case</span> '}': {<br/>
<span class="in3"></span>
<span class="type">bool</span> <span class="var">processed</span> = <span class="keyword">false</span>;<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">process close brace)</span></span>;<br/>
<span class="in3"></span>
<span class="keyword">break</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">default</span>:<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">process other char)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process current char)</span></span><br/>
</code>
</div>
<ul><li>
 Beim Parsen kommt es nur auf das Öffnen und Schließen von
  Mengenklammern an</li><li>
 Diese bestimmen den Anfang und das Ende von Makro-Sequenzen</li><li>
 Welche die Bearbeitung der sonstigen Zeichen steuern</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">additional read vars)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Macro *</span> <span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
<span class="in1"></span>
<span class="type">struct Buffer</span> <span class="var">buffer</span> = {};<br/>

<span class="end">@end(<span class="name">additional read vars)</span></span><br/>
</code>
</div>
<ul><li>
 Wir unterscheiden, ob wir in einem Code-Block sind, oder außerhalb</li><li>
 In einem Code sind wir sogar in einem Makro, dessen Inhalt gerade
  gelesen wird</li><li>
 Am Anfang sind wir außerhalb eines Code-Blocks</li><li>
 In einem Code-Block ist <code><span class="var">macro</span></code> nicht <code><span class="keyword">NULL</span></code></li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">additional read vars)</span></span><br/>
<span class="in1"></span>
<span class="type">char</span> <span class="var">openCh</span> = <span class="str">'\0'</span>;<br/>

<span class="end">@end(<span class="name">additional read vars)</span></span><br/>
</code>
</div>
<ul><li>
 Das Zeichenvor einer öffnenden Mengenklammer wird in <code><span class="var">openCh</span></code>
  zwischengespeichert</li><li>
 Es beschreibt, welcher Befehl ausgeführt werden soll</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">additional read vars)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Buffer</span> <span class="var">name</span> = {};<br/>

<span class="end">@end(<span class="name">additional read vars)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn <code><span class="var">name</span></code> aktiv ist, dann wird ein Name in Buffer gelesen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process close brace)</span></span> {<br/>
<span class="in1"></span>
<span class="keyword">if</span> (isActiveBuffer(&<span class="var">name</span>)) {<br/>
<span class="in2"></span>
<span class="fn">addToBuffer</span>(&<span class="var">name</span>, <span class="str">'\0'</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">process macro name)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">eraseBuffer</span>(&<span class="var">name</span>);<br/>
<span class="in2"></span>
<span class="var">last</span> = <span class="var">ch</span>;<br/>
<span class="in2"></span>
<span class="var">ch</span> = <span class="fn">nextCh</span>();<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">process close brace)</span></span><br/>
</code>
</div>
<ul><li>
 Bei einer schließenden Mengenklammer wird der Makro-Name ausgewertet</li><li>
 Danach wird der Namenszeiger zurückgesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process other char)</span></span> {<br/>
<span class="in1"></span>
<span class="keyword">if</span> (isActiveBuffer(&<span class="var">name</span>)) {<br/>
<span class="in2"></span>
<span class="fn">addToBuffer</span>(&<span class="var">name</span>, <span class="var">ch</span>);<br/>
<span class="in2"></span>
<span class="keyword">break</span>;<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">process other char)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn ein Name geparst wird, dann der Namensbuffer entsprechend
  erweitert</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process other char)</span></span> {<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
<span class="in2"></span>
<span class="fn">addToBuffer</span>(&<span class="var">buffer</span>, <span class="var">last</span>);<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">process other char)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn es ein aktuelles Makro gibt, dann müssen sonstige Zeichen dort
  angefügt werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process open brace)</span></span> {<br/>
<span class="in1"></span>
<span class="keyword">if</span> (! <span class="var">macro</span>) {<br/>
<span class="in2"></span>
<span class="keyword">static</span> <span class="type">const char</span> <span class="var">valids</span>[] = <span class="str">"adir"</span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="fn">strchr</span>(<span class="var">valids</span>, <span class="var">last</span>)) {<br/>
<span class="in3"></span>
<span class="var">openCh</span> = <span class="var">last</span>;<br/>
<span class="in3"></span>
<span class="fn">activateBuffer</span>(&<span class="var">name</span>);<br/>
<span class="in3"></span>
<span class="keyword">break</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">process open brace)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn außerhalb eines Makros die Folge <code>a</code>, <code>{</code> gelesen wird, dann
  beginnt ein <code>@add</code>-Fragment</li><li>
 Falls ein <code>i</code>, <code>{</code> gelesen wird, dann muss eine andere Datei mit
  <code>@include</code> eingebunden werden</li><li>
 Es folgt der Name des Makros oder der Pfad der Datei bis zum nächsten
  <code>}</code></li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">global source vars)</span></span><br/>
<span class="in1"></span>
<span class="type">struct MacroMap</span> <span class="var">macros</span> = {};<br/>

<span class="end">@end(<span class="name">global source vars)</span></span><br/>
</code>
</div>
<ul><li>
 Kollektion mit allen Makros wird für folgende Schritte sichtbar
  angelegt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'d'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">macro</span>, "def in macro");<br/>
<span class="in2"></span>
<span class="var">macro</span> = <span class="fn">findMacroInMap</span>(<br/>
<span class="in3"></span>
&<span class="var">macros</span>, <span class="var">name</span>.<span class="var">buffer</span>, <span class="var">name</span>.<span class="var">current</span> - 1<br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
if (isPopulatedMacro(macro)) {<br/>
<span class="in3"></span>
printf("macro [%s] already defined\n", name.current);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
if (! macro) {<br/>
<span class="in3"></span>
<span class="var">macro</span> = <span class="fn">allocMacroInMap</span>(<br/>
<span class="in4"></span>
&<span class="var">macros</span>, <span class="var">name</span>.<span class="var">buffer</span>, <span class="var">name</span>.<span class="var">current</span> - 1<br/>
<span class="in3"></span>
);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Erzeugt eine neues Makro</li><li>
 Das Makro darf nicht bereits vorhanden sein</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'a'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">macro</span>, "add in macro");<br/>
<span class="in2"></span>
<span class="var">macro</span> = <span class="fn">findMacroInMap</span>(<br/>
<span class="in3"></span>
&<span class="var">macros</span>, <span class="var">name</span>.<span class="var">buffer</span>, <span class="var">name</span>.<span class="var">current</span> - 1<br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
if (! isPopulatedMacro(macro)) {<br/>
<span class="in3"></span>
printf("macro [%s] not defined\n",name.buffer);<br/>
<span class="in3"></span>
macro = getMacroInMap(&macros, name.buffer, name.current - 1);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Bei einem öffnenden Makro wird das passende Makro gesucht</li><li>
 Weitere Bytes können zu diesem Makro hinzugefügt werden</li><li>
 Das Makro muss bereits vorhanden sein</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'r'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">macro</span>, "replace in macro");<br/>
<span class="in2"></span>
<span class="var">macro</span> = <span class="fn">getMacroInMap</span>(<br/>
<span class="in3"></span>
&<span class="var">macros</span>, <span class="var">name</span>.<span class="var">buffer</span>, <span class="var">name</span>.<span class="var">current</span> - 1<br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "macro %s not defined", name.buffer);<br/>
<span class="in2"></span>
<span class="fn">freeMacrosEntries</span>(<span class="var">macro</span>);<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Bei einem <code>@replace</code> wird der Inhalt eines Makros zurückgesetzt</li><li>
 Das Makro muss bereits vorhanden sein</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'x'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "end not in macro");<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">macro names must match)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">flush macro buffer)</span></span>;<br/>
<span class="in2"></span>
<span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Bei einem schließenden Makro wird das aktuelle Makro unterbrochen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">macro names must match)</span></span><br/>
<span class="in1"></span>
ASSERT(<br/>
<span class="in2"></span>
! strcmp(macro-&gt;name, name.buffer),<br/>
<span class="in2"></span>
"closing [%s] != [%s]",<br/>
<span class="in2"></span>
name.buffer, macro-&gt;name<br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">macro names must match)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">global source vars)</span></span><br/>
<span class="in1"></span>
<span class="type">bool</span> <span class="fn">alreadyUsed</span>(<span class="type">const char *</span><span class="var">name</span>) {<br/>
<span class="in2"></span>
<span class="keyword">for</span> (<span class="type">struct Input *</span><span class="var">u</span> = <span class="var">used</span>; <span class="var">u</span>; <span class="var">u</span> =<br/>
<span class="in2"></span>
<span class="var">u</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in3"></span>
if (strcmp(u-&gt;name, name) == 0) {<br/>
<span class="in4"></span>
return true;<br/>
<span class="in3"></span>
}<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="keyword">false</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">global source vars)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'i'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">macro</span>, "include in macro");<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="fn">alreadyUsed</span>(<span class="var">name</span>.<span class="var">buffer</span>)) {<br/>
<span class="in3"></span>
<span class="fn">pushPath</span>(<span class="var">name</span>.<span class="var">buffer</span>);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn eine Datei eingebunden werden soll, dann wird sie geöffnet und auf
  den Stapel der offenen Dateien gelegt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'e'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "expand not in macro");<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">flush macro buffer)</span></span>;<br/>
<span class="in2"></span>
<span class="type">struct Macro *</span><span class="var">sub</span> =<br/>
<span class="in3"></span>
<span class="fn">getMacroInMap</span>(<br/>
<span class="in4"></span>
&<span class="var">macros</span>, <span class="var">name</span>.buffer, <span class="var">name</span>.current - 1);<br/>
<span class="in2"></span>
if (sub-&gt;expands) {<br/>
<span class="in3"></span>
printf("multiple expands of [%s]\n", sub-&gt;name);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
if (sub-&gt;multiples) {<br/>
<span class="in3"></span>
printf("expand after mult of [%s]\n", sub-&gt;name);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
++sub-&gt;expands;<br/>
<span class="in2"></span>
<span class="fn">addMacroToMacro</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>, <span class="var">sub</span>);<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'E'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "multiple not in macro");<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">flush macro buffer)</span></span>;<br/>
<span class="in2"></span>
<span class="type">struct Macro *</span><span class="var">sub</span> =<br/>
<span class="in3"></span>
<span class="fn">getMacroInMap</span>(<br/>
<span class="in4"></span>
&<span class="var">macros</span>, <span class="var">name</span>.buffer, <span class="var">name</span>.current - 1);<br/>
<span class="in2"></span>
if (sub-&gt;expands) {<br/>
<span class="in3"></span>
printf("multiple after expand of [%s]\n", sub-&gt;name);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
++sub-&gt;multiples;<br/>
<span class="in2"></span>
<span class="fn">addMacroToMacro</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>, <span class="var">sub</span>);<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'p'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "private not in macro");<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">process private macro)</span></span>;<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Die Implementierung wird später durch eine sinnvollere ersetzt</li><li>
 Daher ist der zugehörige Code in einem eigenen Fragment gekapselt</li><li>
 Dieses kann später ersetzt werden</li><li>
 Nachdem diese Funktionalität implementiert wurde</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process private macro)</span></span><br/>
<span class="in1"></span>
<span class="type">static char</span> <span class="var">prefix</span>[] = "_private_";<br/>
<span class="in1"></span>
<span class="expand">@multiple(<span class="name">flush macro buffer)</span></span>;<br/>
<span class="in1"></span>
<span class="fn">addBytesToMacro</span>(<br/>
<span class="in2"></span>
<span class="var">macro</span>, <span class="var">prefix</span>, <span class="var">prefix</span> + <span class="fn">sizeof</span>(<span class="var">prefix</span>) - 1<br/>
<span class="in1"></span>
);<br/>
<span class="in1"></span>
<span class="fn">addBytesToMacro</span>(<br/>
<span class="in2"></span>
<span class="var">macro</span>, <span class="var">name</span>.buffer, <span class="var">name</span>.current - 1<br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">process private macro)</span></span><br/>
</code>
</div>
<ul><li>
 Erstmal nur ein konstanter String, um private Bezeichner zu
  verstecken</li><li>
 Später soll ein individueller Hash integriert werden</li><li>
 Der vom Dateinamen abhängt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">openCh</span> == <span class="str">'m'</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "magic not in macro");<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">process magic macro)</span></span>;<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Auch die Implementierung des magci-Makros soll später ersetzt werden</li><li>
 Daher wird es in einem eigenen Fragment gekapselt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">process magic macro)</span></span><br/>
<span class="in1"></span>
<span class="type">static char</span> <span class="var">magic</span>[] = "2478325";<br/>
<span class="in1"></span>
<span class="expand">@multiple(<span class="name">flush macro buffer)</span></span>;<br/>
<span class="in1"></span>
<span class="fn">addBytesToMacro</span>(<br/>
<span class="in2"></span>
<span class="var">macro</span>, <span class="var">magic</span>, <span class="var">magic</span> + <span class="fn">sizeof</span>(<span class="var">magic</span>) - 1<br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">process magic macro)</span></span><br/>
</code>
</div>
<ul><li>
 Die provisorische Version liefert nur eine konstante Zahl</li><li>
 Aber auch hier sollte eigentlich ein Hash geliefert werden</li><li>
 Der vom Dateinamen und vom Argument abhängt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">flush macro buffer)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<br/>
<span class="in2"></span>
<span class="var">buffer</span>.<span class="var">buffer</span> != <span class="var">buffer</span>.<span class="var">current</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">addBytesToMacro</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>, <span class="var">buffer</span>.<span class="var">buffer</span>,<br/>
<span class="in3"></span>
<span class="var">buffer</span>.<span class="var">current</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">resetBuffer</span>(&<span class="var">buffer</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">flush macro buffer)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">process open brace)</span></span> {<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
<span class="in2"></span>
<span class="type">bool</span> <span class="var">valid</span> = <span class="keyword">false</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check valid names)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">valid</span>) {<br/>
<span class="in3"></span>
<span class="var">openCh</span> = <span class="var">last</span>;<br/>
<span class="in3"></span>
activateBuffer(&name);<br/>
<span class="in3"></span>
<span class="keyword">break</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">process open brace)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">check valid names)</span></span><br/>
<span class="in1"></span>
<span class="keyword">static</span> <span class="type">const char</span> <span class="var">valids</span>[] =<br/>
<span class="in2"></span>
<span class="str">"123456fvsntkxeEpm"</span>;<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="fn">strchr</span>(<span class="var">valids</span>, <span class="var">last</span>)) {<br/>
<span class="in2"></span>
<span class="var">valid</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">check valid names)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">process macro name)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (! <span class="var">processed</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>, "unknown macro %s", name.buffer);<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">c</span> = <span class="var">name</span>.buffer;<br/>
<span class="in2"></span>
<span class="keyword">for</span> (; <span class="var">c</span> != <span class="var">name.current</span> - 1; ++<span class="var">c</span>) {<br/>
<span class="in3"></span>
<span class="fn">addToBuffer</span>(&<span class="var">buffer</span>, *<span class="var">c</span>);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="var">processed</span> = <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process macro name)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">process open brace)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
<span class="in2"></span>
<span class="fn">addToBuffer</span>(&<span class="var">buffer</span>, <span class="var">last</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process open brace)</span></span><br/>

<br/>

<span class="add">@add(<span class="name">process close brace)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">macro</span> && ! <span class="var">processed</span>) {<br/>
<span class="in2"></span>
<span class="fn">addToBuffer</span>(&<span class="var">buffer</span>, <span class="var">last</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">process close brace)</span></span><br/>
</code>
</div>
<ul><li>
 Entities werden in einer eigenen Datei expandiert</li></ul></div>
</div>
<h1>Fragmente serialisieren</h1>
<div class="slides">
<div><div>
<h1>Fragmente serialisieren</h1>
</div>
<ul><li>
 Fragmente, die Dateien spezifizieren werden in diese Dateien
  rausgeschrieben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize fragments)</span></span> {<br/>
<span class="in1"></span>
<span class="type">struct Macro **</span><span class="var">cur</span> = <span class="var">macros</span>.<span class="var">macros</span>;<br/>
<span class="in1"></span>
<span class="type">struct Macro **</span><span class="var">end</span> =<br/>
<span class="in2"></span>
<span class="var">cur</span> + <span class="var">MACRO_SLOTS</span>;<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">cur</span> &lt; <span class="var">end</span>; ++<span class="var">cur</span>) {<br/>
<span class="in2"></span>
<span class="type">struct Macro *</span><span class="var">macro</span> = *<span class="var">cur</span>;<br/>
<span class="in2"></span>
<span class="keyword">for</span> (; <span class="var">macro</span>; <span class="var">macro</span> = <span class="var">macro</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">serialize macro)</span></span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">serialize fragments)</span></span><br/>
</code>
</div>
<ul><li>
 Fragmente, die mit <code>file:</code> beginnen, werden in die entsprechenden
  Dateien rausgeschrieben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize macro)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (! <span class="fn">memcmp</span>(<br/>
<span class="in2"></span>
<span class="str">"file: "</span>, macro-&gt;name, <span class="num">6</span><br/>
<span class="in1"></span>
)) {<br/>
<span class="in2"></span>
++<span class="var">macro</span>-&gt;<span class="var">expands</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">write in file)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">serialize macro)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">serialize macro)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (macro-&gt;expands + macro-&gt;multiples &lt;= 0) {<br/>
<span class="in2"></span>
printf("macro [%s] not called\n", macro-&gt;name);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">serialize macro)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">serialize macro)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (macro-&gt;multiples == 1) {<br/>
<span class="in2"></span>
printf("multiple macro [%s] only used once\n", macro-&gt;name);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">serialize macro)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">serialize macro)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (! isPopulatedMacro(macro)) {<br/>
<span class="in2"></span>
printf("macro [%s] not populated\n", macro-&gt;name);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">serialize macro)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">write in file)</span></span><br/>
<span class="in1"></span>
<span class="type">FILE *</span><span class="var">f</span> = <span class="fn">fopen</span>(<span class="var">macro</span>-&gt;<span class="var">name</span> + <span class="num">6</span>, "w");<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">f</span>, "can't open %s", <span class="var">macro</span>-&gt;<span class="var">name</span> + <span class="num">6</span>);<br/>
<span class="in1"></span>
<span class="fn">serializeMacro</span>(<span class="var">macro</span>, <span class="var">f</span>);<br/>
<span class="in1"></span>
<span class="fn">fclose</span>(<span class="var">f</span>);<br/>

<span class="end">@end(<span class="name">write in file)</span></span><br/>
</code>
</div>
<ul><li>
 Das Fragment wird in die entsprechende Datei geschrieben</li><li>
 Dabei werden HTML-Entitäten aufgelöst</li></ul></div>
</div>
<h1>HTML generieren</h1>
<div class="slides">
<div><div>
<h1>HTML generieren</h1>
</div>
<ul><li>
 Aus <code>hx</code>-Dateien wird ein HTML-Foliensatz generiert</li></ul></div>
<div><div>
<code>

<span class="include">@include(<span class="name"><a href="html.html">html.x</a>)</span></span><br/>
</code>
</div>
<ul><li>
 Die Generierung liegt in einer eigenen Datei</li></ul></div>
