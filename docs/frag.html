<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>Fragmente</title>
<link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>Fragmente</h1>
<div class="slides">
<div>
<div>
<h1>Fragmente</h1>
</div>
<ul><li>
Fragmente bilden einen gerichteten azyklischen Graph
</li><li>
Die Infix-Traversierung dieses Graphen bildet die generierten  Source-Code Dateien
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Add(<span class="name">input prereqs</span>)</span><br/>
<span class="in1"></span><span class="keyword">class</span> <span class="type">Frag</span>;<br/>
<br/>
<span class="in1"></span><span class="type">struct</span> <span class="type">Write_State</span> {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">source_name</span> = {};<br/>
<span class="in2"></span><span class="type">bool</span> <span class="var">in_macro</span> = <span class="num">false</span>;<br/>
<span class="in2"></span><span class="type">bool</span> <span class="var">c_style</span>;<br/>
<br/>
<span class="in2"></span><span class="fn">Write_State</span>(<span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">f</span>);<br/>
<span class="in1"></span>};<br/>
<span class="macro">@End(<span class="name">input prereqs</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@Add(<span class="name">input prereqs</span>)</span><br/>
<span class="in1"></span><span class="macro">@Put(<span class="name">frag prereqs</span>)</span>;<br/>
<span class="in1"></span><span class="macro">@put(<span class="name">define frag</span>)</span>;<br/>
<span class="macro">@end(<span class="name">input prereqs</span>)</span><br/>
</code></div>
<ul><li>
Fragmente sind global sichtbare Strukturen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="keyword">class</span> <span class="type">FragEntry</span> {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">_str</span>;<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">_file</span>;<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">_first_line</span>;<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">_last_line</span>;<br/>
<span class="in1"></span><span class="keyword">public</span>:<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">frag</span>;<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">entry methods</span>)</span>;<br/>
<span class="in1"></span>};<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Ein Eintrag kann entweder auf ein anderes Fragment verweisen (wenn  dieses an der aktuellen Stelle expandiert werden soll)
</li><li>
Oder er enthält Bytes, die beim Expandieren direkt expandiert werden
</li><li>
Wenn ein Eintrag sowohl Daten als auch ein Fragment enthält, so wird  zuerst das Fragment ausgegeben
</li><li>
So können die Bytes leicht erweitert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">entry methods</span>)</span><br/>
<span class="in1"></span><span class="fn">FragEntry</span>(<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span> = <span class="num">nullptr</span><br/>
<span class="in1"></span>):<br/>
<span class="in2"></span><span class="var">_first_line</span> { -<span class="num">1</span> },<br/>
<span class="in2"></span><span class="var">frag</span> { <span class="var">frag</span> }<br/>
<span class="in1"></span>{}<br/>
<span class="macro">@end(<span class="name">entry methods</span>)</span><br/>
</code></div>
<ul><li>
Ein Eintrag kann direkt mit einem Fragment initialisiert werden
</li><li>
Dies kann auch leer sein
</li><li>
Die Zeichenkette ist immer leer
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">entry methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">update_state</span>(<span class="type">Write_State</span> &amp;<span class="var">state</span>) <span class="type">const</span> {<br/>
<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">c</span> { <span class="var">_str</span>.<span class="fn">end</span>() };<br/>
<span class="in2"></span><span class="type">auto</span> <span class="var">b</span> { <span class="var">_str</span>.<span class="fn">begin</span>() };<br/>
<span class="in2"></span><span class="type">bool</span> <span class="var">some_nl</span> { <span class="num">false</span> };<br/>
<span class="in2"></span><span class="keyword">while</span> (<span class="var">b</span> != <span class="var">c</span>) {<br/>
<span class="in3"></span>--<span class="var">c</span>;<br/>
<span class="in3"></span><span class="keyword">if</span> (*<span class="var">c</span> == <span class="str">'\n'</span> || *<span class="var">c</span> == <span class="str">'\r'</span>) {<br/>
<span class="in4"></span><span class="var">some_nl</span> = <span class="num">true</span>;<br/>
<span class="in4"></span><span class="keyword">continue</span>;<br/>
<span class="in3"></span>}<br/>
<span class="in3"></span><span class="keyword">if</span> (*<span class="var">c</span> &lt;= <span class="str">' '</span>) { <span class="keyword">continue</span>; }<br/>
<span class="in3"></span><span class="keyword">if</span> (*<span class="var">c</span> == <span class="str">'\\'</span>) {<br/>
<span class="in4"></span><span class="keyword">if</span> (<span class="var">some_nl</span>) {<br/>
<span class="in5"></span><span class="var">state</span>.<span class="var">in_macro</span> = <span class="num">true</span>;<br/>
<span class="in5"></span><span class="keyword">return</span>;<br/>
<span class="in4"></span>}<br/>
<span class="in3"></span>}<br/>
<span class="in3"></span><span class="keyword">break</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">b</span> != <span class="var">c</span> &amp;&amp; *<span class="var">c</span> &gt; <span class="str">' '</span>) {<br/>
<span class="in3"></span><span class="var">state</span>.<span class="var">in_macro</span> = <span class="num">false</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">string</span> <span class="fn">str</span>(<span class="type">Write_State</span> &amp;<span class="var">state</span>) <span class="type">const</span> {<br/>
<span class="in2"></span><span class="type">bool</span> <span class="var">old</span> { <span class="var">state</span>.<span class="var">in_macro</span> };<br/>
<span class="in2"></span><span class="fn">update_state</span>(<span class="var">state</span>);<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">old</span>) { <span class="keyword">return</span> <span class="var">_str</span>; }<br/>
<span class="in2"></span><span class="keyword">if</span> (! <span class="var">state</span>.<span class="var">c_style</span>) { <span class="keyword">return</span> <span class="var">_str</span>; }<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">_first_line</span> &lt; <span class="num">1</span>) { <span class="keyword">return</span> <span class="var">_str</span>; }<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">_str</span>.<span class="fn">empty</span>()) { <span class="keyword">return</span> <span class="var">_str</span>; };<br/>
<span class="in2"></span><span class="type">std</span>::<span class="var">ostringstream</span> <span class="var">oss</span>;<br/>
<span class="in2"></span><span class="var">oss</span> &lt;&lt; <span class="str">"\n#line "</span> &lt;&lt;<br/>
<span class="in3"></span><span class="var">_first_line</span> &lt;&lt; <span class="str">" \""</span> &lt;&lt; <span class="var">_file</span> &lt;&lt; <span class="str">"\"\n"</span> &lt;&lt; <span class="var">_str</span>;<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">oss</span>.<span class="fn">str</span>();<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">entry methods</span>)</span><br/>
</code></div>
<ul><li>
Auf die Bytes kann mit <code><span class="fn">str</span>()</code> nur lesend zugegriffen werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">entry methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">add</span>(<br/>
<span class="in2"></span><span class="type">char</span> <span class="var">ch</span>, <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">file</span>,<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">copy file and line</span>)</span>;<br/>
<span class="in2"></span><span class="var">_str</span> += <span class="var">ch</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">entry methods</span>)</span><br/>
</code></div>
<ul><li>
Beim Anfügen eines Zeichens werden Dateiname und erste Zeile  aktualisiert
</li><li>
Wenn sie noch nicht gesetzt sind
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">copy file and line</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<br/>
<span class="in2"></span><span class="var">_file</span>.<span class="fn">empty</span>() || <span class="var">_first_line</span> &lt;= <span class="num">0</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="var">_file</span> = <span class="var">file</span>;<br/>
<span class="in2"></span><span class="var">_first_line</span> = <span class="var">line</span>;<br/>
<span class="in1"></span>}<br/>
<span class="in1"></span><span class="var">_last_line</span> = <span class="var">line</span>;<br/>
<span class="macro">@end(<span class="name">copy file and line</span>)</span><br/>
</code></div>
<ul><li>
Wenn Dateiname oder erste Zeile nicht gesetzt sind, dann setzt die  Methode beide
</li><li>
Die letzte Zeile wird immer gesetzt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">entry methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">add</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">value</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">file</span>,<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">copy file and line</span>)</span>;<br/>
<span class="in2"></span><span class="var">_str</span> += <span class="var">value</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">entry methods</span>)</span><br/>
</code></div>
<ul><li>
Bytes können direkt hinzugefügt werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">entry methods</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">canAdd</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">file</span>,<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">can add</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">entry methods</span>)</span><br/>
</code></div>
<ul><li>
Prüft ob Zeichen aus einer bestimmten Datei und Zeile an den Eintrag  angefügt werden können
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">can add</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<br/>
<span class="in2"></span>! <span class="var">_file</span>.<span class="fn">empty</span>() &amp;&amp; <span class="var">file</span> != <span class="var">_file</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">can add</span>)</span><br/>
</code></div>
<ul><li>
Wenn sich die Dateinamen unterscheiden, können die Zeichen nicht  angefügt werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">can add</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<br/>
<span class="in2"></span><span class="var">_last_line</span> &gt; <span class="num">0</span> &amp;&amp;<br/>
<span class="in2"></span><span class="var">_last_line</span> != <span class="var">line</span> &amp;&amp;<br/>
<span class="in2"></span><span class="var">_last_line</span> + <span class="num">1</span> != <span class="var">line</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">can add</span>)</span><br/>
</code></div>
<ul><li>
Wenn die letzte Zeile nicht zur neuen Zeile passt, können die Zeichen  nicht angefügt werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">can add</span>)</span><br/>
<span class="in1"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>
<span class="macro">@end(<span class="name">can add</span>)</span><br/>
</code></div>
<ul><li>
Ansonsten können die Zeichen angefügt werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Add(<span class="name">includes</span>)</span><br/>
<span class="in1"></span><span class="keyword">#include</span> &lt;<span class="type">vector</span>&gt;<br/>
<span class="macro">@end(<span class="name">includes</span>)</span><br/>
</code></div>
<ul><li>
Das Fragment legt die Einträge in einem Vektor ab
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="keyword">class</span> <span class="type">Frag</span> {<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">vector</span>&lt;<span class="type">FragEntry</span>&gt; <span class="var">_entries</span>;<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">_expands</span>;<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">_multiples</span>;<br/>
<span class="in1"></span><span class="keyword">public</span>:<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">name</span>;<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">frag methods</span>)</span>;<br/>
<span class="in1"></span>};<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Die Einträge eines Fragments werden in einem Vektor gesammelt
</li><li>
Das Fragment zählt wie häufig es mit <code>@<span class="var">put</span></code>, <code>@<span class="var">globexpand</span></code> und  <code>@<span class="var">multiple</span></code>, <code>@<span class="var">globmult</span></code> aufgerufen wurde, um Struktur-Fehler zu  erkennen
</li></ul>
</div>
</div>
<h1>Neues Fragment anlegen</h1>
<div class="slides">
<div>
<div>
<h1>Neues Fragment anlegen</h1>
</div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">isFile</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">static</span> <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">prefix</span> {<br/>
<span class="in3"></span><span class="str">"file: "</span><br/>
<span class="in2"></span>};<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">p</span> {<br/>
<span class="in3"></span><span class="var">name</span>.<span class="fn">substr</span>(<span class="num">0</span>, <span class="var">prefix</span>.<span class="fn">size</span>())<br/>
<span class="in2"></span>};<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">p</span> == <span class="var">prefix</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Beschreibt das Fragment eine Datei?
</li><li>
Nur wenn sein Name mit der Zeichenkette <code><span class="str">file: </span></code> beginnt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="type">string</span> <span class="fn">cmd</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">static</span> <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">prefix</span> {<br/>
<span class="in3"></span><span class="str">"| "</span><br/>
<span class="in2"></span>};<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">string</span> <span class="var">p</span> {<br/>
<span class="in3"></span><span class="var">name</span>.<span class="fn">substr</span>(<span class="num">0</span>, <span class="var">prefix</span>.<span class="fn">size</span>())<br/>
<span class="in2"></span>};<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">p</span> == <span class="var">prefix</span> ?<br/>
<span class="in3"></span><span class="var">name</span>.<span class="fn">substr</span>(<span class="var">prefix</span>.<span class="fn">size</span>()) :<br/>
<span class="in3"></span><span class="type">std</span>::<span class="type">string</span> {};<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="fn">Frag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">name</span><br/>
<span class="in1"></span>):<br/>
<span class="in2"></span><span class="var">_entries</span> {},<br/>
<span class="in2"></span><span class="var">_expands</span> { <span class="num">0</span> },<br/>
<span class="in2"></span><span class="var">_multiples</span> { <span class="num">0</span> },<br/>
<span class="in2"></span><span class="var">name</span> { <span class="var">name</span> }<br/>
<span class="in1"></span>{<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isFile</span>()) { ++<span class="var">_expands</span>; }<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="fn">cmd</span>().<span class="fn">size</span>()) { ++<span class="var">_expands</span>; }<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Dateien gelten als einmal expandiert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">clear</span>() {<br/>
<span class="in2"></span><span class="var">_entries</span>.<span class="fn">clear</span>();<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Löscht alle Einträge
</li><li>
wird von <code>@<span class="var">replace</span></code>, <code>@<span class="var">globrep</span></code> verwendet
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">empty</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">_entries</span>.<span class="fn">empty</span>();<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Ein Fragment ist leer, wenn es keine Einträge enthält
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">Write_State</span>::<span class="fn">Write_State</span>(<span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">f</span>):<br/>
<span class="in2"></span><span class="var">c_style</span> { <span class="var">f</span>.<span class="fn">is_c_style</span>() }<br/>
<span class="in1"></span>{ }<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
</div>
</div>
<h1>Unit Tests</h1>
<div class="slides">
<div>
<div>
<h1>Unit Tests</h1>
</div>
</div>
<div><div>
<code>
<span class="macro">@Def(<span class="name">perform unit-tests</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">unit tests</span>)</span>;<br/>
<span class="macro">@end(<span class="name">perform unit-tests</span>)</span><br/>
</code></div>
<ul><li>
Fragmente haben einen eigenes Unit-Test Fragment
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">testFragName</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">name</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="type">Frag</span> <span class="fn">f</span>(<span class="var">name</span>);<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>.<span class="var">name</span> == <span class="var">name</span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
<code><span class="var">testFragName</span></code> prüft, ob der Name korrekt in ein Fragment kopiert  wurde
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">unit tests</span>)</span><br/>
<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">"abc"</span>);<br/>
<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">""</span>);<br/>
<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">"A c"</span>);<br/>
<span class="in1"></span>{<br/>
<span class="in2"></span><span class="type">Frag</span> <span class="var">f</span> { <span class="str">"ab"</span> };<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>.<span class="fn">empty</span>());<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">unit tests</span>)</span><br/>
</code></div>
<ul><li>
Zum einen wird getestet, ob die Namen korrekt kopiert werden
</li><li>
Zum anderen wird sichergestellt, dass die Verweise <code><span class="num">nullptr</span></code> sind
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">isPopulatedFrag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">f</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">f</span> &amp;&amp; ! <span class="var">f</span>-&gt;<span class="fn">empty</span>();<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Prüft, ob ein Fragment nicht leer ist
</li></ul>
</div>
</div>
<h1>Unit Tests</h1>
<div class="slides">
<div>
<div>
<h1>Unit Tests</h1>
</div>
<ul><li>
Testet Fragmente
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">unit tests</span>)</span><br/>
<span class="in1"></span>{<br/>
<span class="in2"></span><span class="type">FragEntry</span> <span class="var">entry</span>;<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>.<span class="var">frag</span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">unit tests</span>)</span><br/>
</code></div>
<ul><li>
Ein leerer Eintrag hat keinen Nachfolger
</li><li>
Und kein Fragment
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">unit tests</span>)</span><br/>
<span class="in1"></span>{<br/>
<span class="in2"></span><span class="type">Frag</span> <span class="var">f</span> { <span class="str">""</span> };<br/>
<span class="in2"></span><span class="type">Write_State</span> <span class="var">s</span> { <span class="var">f</span> };<br/>
<span class="in2"></span><span class="type">FragEntry</span> <span class="var">entry</span>;<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>.<span class="fn">str</span>(<span class="var">s</span>).<span class="fn">empty</span>());<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">unit tests</span>)</span><br/>
</code></div>
<ul><li>
Ein leerer Eintrag hat keine Bytes
</li></ul>
</div>
</div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
<div class="slides">
<div>
<div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
</div>
<ul><li>
fügt Text oder Fragmente an ein Fragment an
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">add</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">value</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">file</span>,<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">value</span>.<span class="fn">empty</span>()) { <span class="keyword">return</span>; }<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">assure frag entry</span>)</span>;<br/>
<span class="in2"></span><span class="var">_entries</span>.<span class="fn">back</span>().<span class="fn">add</span>(<br/>
<span class="in3"></span><span class="var">value</span>, <span class="var">file</span>, <span class="var">line</span><br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Wenn der Text leer ist, fügt die Methode nichts an
</li><li>
Ansonsten stellt die Methode sicher, dass der letzte Eintrag valide  ist
</li><li>
An diesen wird der Text angefügt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">assure frag entry</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">_entries</span>.<span class="fn">empty</span>()) {<br/>
<span class="in2"></span><span class="var">_entries</span>.<span class="fn">push_back</span>(<span class="type">FragEntry</span> {});<br/>
<span class="in1"></span>} <span class="keyword">else</span> <span class="keyword">if</span> (<br/>
<span class="in2"></span>! <span class="var">_entries</span>.<span class="fn">back</span>().<span class="fn">canAdd</span>(<br/>
<span class="in3"></span><span class="var">file</span>, <span class="var">line</span><br/>
<span class="in2"></span>)<br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="var">_entries</span>.<span class="fn">push_back</span>(<span class="type">FragEntry</span> {});<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">assure frag entry</span>)</span><br/>
</code></div>
<ul><li>
Wenn es noch keine Einträge gibt, legt die Methode einen an
</li><li>
Wenn der letzte Eintrag unpassende Dateinamen oder Zeilennummern hat,  dann legt die Methode einen neuen Eintrag an
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">add</span>(<br/>
<span class="in2"></span><span class="type">char</span> <span class="var">ch</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">file</span>,<br/>
<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@mul(<span class="name">assure frag entry</span>)</span>;<br/>
<span class="in2"></span><span class="var">_entries</span>.<span class="fn">back</span>().<span class="fn">add</span>(<br/>
<span class="in3"></span><span class="var">ch</span>, <span class="var">file</span>, <span class="var">line</span><br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Die Methode stellt sicher, dass der letzte Eintrag valide ist
</li><li>
An diesen wird das Zeichen angefügt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">Frag</span> &amp;<span class="fn">add</span>(<span class="type">Frag</span> *<span class="var">child</span>);<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Die <code><span class="fn">add</span></code>-Methode muss sicherstellen, dass keine Zykel entstehen
</li><li>
Da es die notwendigen Methoden noch nicht gibt, wird die Methode  außerhalb der Klasse definiert
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="macro">@put(<span class="name">define cycle check</span>)</span><br/>
<span class="in1"></span><span class="type">Frag</span> &amp;<span class="type">Frag</span>::<span class="fn">add</span>(<span class="type">Frag</span> *<span class="var">child</span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">child</span>);<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">avoid frag cycles</span>)</span>;<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">add frag entry</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">return</span> *<span class="var">this</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Bevor ein Fragment hinzugefügt werden kann, muss sichergestellt  werden,  dass kein Zykel entsteht
</li><li>
Ein Zykel liegt vor, wenn <code><span class="var">frag</span></code> gleich <code><span class="var">child</span></code> ist
</li><li>
Oder bereits direkt oder indirekt zu <code><span class="var">child</span></code> hinzugefügt wurde
</li><li>
Falls der letzte Eintrag noch kein Fragment hat, wird dieser Eintrag  verwendet
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">add frag entry</span>)</span><br/>
<span class="in1"></span><span class="var">_entries</span>.<span class="fn">push_back</span>(<br/>
<span class="in2"></span><span class="type">FragEntry</span> { <span class="var">child</span> }<br/>
<span class="in1"></span>);<br/>
<span class="macro">@end(<span class="name">add frag entry</span>)</span><br/>
</code></div>
<ul><li>
Für das Kind wird ein neuer Eintrag an das Fragment angefügt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">auto</span> <span class="fn">begin</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">_entries</span>.<span class="fn">cbegin</span>();<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Beginn eines konstanten Iterators auf den Einträgen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">auto</span> <span class="fn">end</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">_entries</span>.<span class="fn">cend</span>();<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Ende eines konstanten Iterators auf den Einträgen
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">int</span> <span class="fn">expands</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">_expands</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Anzahl der <code>@<span class="var">put</span></code> und <code>@<span class="var">globexpand</span></code> Aufrufe
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">addExpand</span>() {<br/>
<span class="in2"></span>++<span class="var">_expands</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Fügt <code>@<span class="var">put</span></code> oder <code>@<span class="var">globexpand</span></code> hinzu
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">int</span> <span class="fn">multiples</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="var">_multiples</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Anzahl der <code>@<span class="var">multiple</span></code> und <code>@<span class="var">globmult</span></code> Aufrufe
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">addMultiple</span>() {<br/>
<span class="in2"></span>++<span class="var">_multiples</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
<ul><li>
Fügt <code>@<span class="var">multiple</span></code> oder <code>@<span class="var">globmult</span></code> hinzu
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">frag methods</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">is_c_style</span>() <span class="type">const</span> {<br/>
<span class="in2"></span><span class="keyword">static</span> <span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> <span class="var">extensions</span>[] = {<br/>
<span class="in3"></span><span class="str">".c"</span>, <span class="str">".h"</span>, <span class="str">".cpp"</span><br/>
<span class="in2"></span>};<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> *<span class="var">end</span> = <span class="var">extensions</span> + <span class="fn">sizeof</span>(<span class="var">extensions</span>)/<span class="fn">sizeof</span>(*<span class="var">extensions</span>);<br/>
<span class="in2"></span><span class="keyword">for</span> (<span class="type">auto</span> <span class="var">i</span> = <span class="var">extensions</span>; <span class="var">i</span> != <span class="var">end</span>; ++<span class="var">i</span>) {<br/>
<span class="in3"></span><span class="keyword">if</span> (<span class="var">name</span>.<span class="fn">length</span>() &gt; <span class="var">i</span>-&gt;<span class="fn">length</span>()) {<br/>
<span class="in4"></span><span class="keyword">if</span> (<span class="var">name</span>.<span class="fn">substr</span>(<span class="var">name</span>.<span class="fn">length</span>() - <span class="var">i</span>-&gt;<span class="fn">length</span>()) == *<span class="var">i</span>) {<br/>
<span class="in5"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>
<span class="in4"></span>}<br/>
<span class="in3"></span>}<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">frag methods</span>)</span><br/>
</code></div>
</div>
</div>
<h1>Fragmente serialisieren</h1>
<div class="slides">
<div>
<div>
<h1>Fragmente serialisieren</h1>
</div>
<ul><li>
Serialisiert Fragmente in einen <code><span class="type">std</span>::<span class="type">ostream</span></code>
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">serializeFrag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">frag</span>,<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">ostream</span> &amp;<span class="var">out</span>,<br/>
<span class="in2"></span><span class="type">Write_State</span> &amp;<span class="var">state</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">iterate entries</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Jeder Eintrag wird nacheinander bearbeitet
</li><li>
Fragmente in Einträgen werden rekursiv ausgegeben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">serializeFrag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">f</span>,<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">ostream</span> &amp;<span class="var">out</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="type">Write_State</span> <span class="var">state</span> { <span class="var">f</span> };<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="fn">serializeFrag</span>(<br/>
<span class="in3"></span><span class="var">f</span>, <span class="var">out</span>, <span class="var">state</span><br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">iterate entries</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">const</span> <span class="type">auto</span> &amp;<span class="var">entry</span> : <span class="var">frag</span>) {<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">entry</span>.<span class="var">frag</span>) {<br/>
<span class="in3"></span><span class="fn">serializeFrag</span>(<br/>
<span class="in4"></span>*<span class="var">entry</span>.<span class="var">frag</span>, <span class="var">out</span>,<br/>
<span class="in4"></span><span class="var">state</span><br/>
<span class="in3"></span>);<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="var">out</span> &lt;&lt; <span class="var">entry</span>.<span class="fn">str</span>(<span class="var">state</span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">iterate entries</span>)</span><br/>
</code></div>
<ul><li>
Rekursiv wird das Fragment ausgegeben, falls vorhanden
</li><li>
Dann werden die Bytes des Eintrags ausgegeben
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">check_frag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">f</span>,<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">istream</span> &amp;<span class="keyword">in</span>,<br/>
<span class="in2"></span><span class="type">Write_State</span> &amp;<span class="var">state</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">check entries</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">check_frag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">f</span>,<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">istream</span> &amp;<span class="keyword">in</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="type">Write_State</span> <span class="var">state</span> { <span class="var">f</span> };<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="fn">check_frag</span>(<br/>
<span class="in3"></span><span class="var">f</span>, <span class="keyword">in</span>, <span class="var">state</span><br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">check entries</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">const</span> <span class="type">auto</span> &amp;<span class="var">entry</span> : <span class="var">f</span>) {<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="var">entry</span>.<span class="var">frag</span>) {<br/>
<span class="in3"></span><span class="keyword">if</span> (!<span class="fn">check_frag</span>(<br/>
<span class="in4"></span>*<span class="var">entry</span>.<span class="var">frag</span>, <span class="keyword">in</span>,<br/>
<span class="in4"></span><span class="var">state</span><br/>
<span class="in3"></span>)) {<br/>
<span class="in4"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in3"></span>}<br/>
<span class="in2"></span>}<br/>
<span class="in2"></span><span class="keyword">for</span> (<span class="type">const</span> <span class="type">auto</span> &amp;<span class="var">i</span> : <span class="var">entry</span>.<span class="fn">str</span>(<span class="var">state</span>)) {<br/>
<span class="in3"></span><span class="keyword">if</span> (<span class="keyword">in</span>.<span class="fn">get</span>() != <span class="var">i</span>) {<br/>
<span class="in4"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in3"></span>}<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">check entries</span>)</span><br/>
</code></div>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">testFrag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> &amp;<span class="var">frag</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">expected</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">serialize test frag</span>)</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Diese Hilfsfunktion prüft ob die Serialisierung eines Fragments der  Erwartung entspricht
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Add(<span class="name">includes</span>)</span><br/>
<span class="in1"></span><span class="keyword">#include</span> &lt;<span class="var">sstream</span>&gt;<br/>
<span class="macro">@end(<span class="name">includes</span>)</span><br/>
</code></div>
<ul><li>
<code><span class="fn">testFrag</span></code> benötigt <code><span class="type">std</span>::<span class="var">ostringstream</span></code>
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">serialize test frag</span>)</span><br/>
<span class="in1"></span><span class="type">std</span>::<span class="var">ostringstream</span> <span class="var">buffer</span>;<br/>
<span class="in1"></span><span class="fn">serializeFrag</span>(<span class="var">frag</span>, <span class="var">buffer</span>);<br/>
<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">buffer</span>.<span class="fn">str</span>() == <span class="var">expected</span>);<br/>
<span class="macro">@end(<span class="name">serialize test frag</span>)</span><br/>
</code></div>
<ul><li>
Serialisiert das Fragment
</li><li>
Der Buffer muss die erwarteten Werte enthalten
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="type">void</span> <span class="fn">addStringToFrag</span>(<br/>
<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">std</span>::<span class="type">string</span> &amp;<span class="var">str</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="var">frag</span>-&gt;<span class="fn">add</span>(<br/>
<span class="in3"></span><span class="var">str</span>, <span class="type">std</span>::<span class="type">string</span> {}, <span class="num">0</span><br/>
<span class="in2"></span>);<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Zu Testzwecken kann eine Null-terminierte Zeichenkette hinzugefügt  werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">unit tests</span>)</span> {<br/>
<span class="in1"></span><span class="type">Frag</span> <span class="var">frag</span> { <span class="str">""</span> };<br/>
<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">frag</span>, <span class="str">"abc"</span>);<br/>
<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">frag</span>, <span class="str">"def"</span>);<br/>
<span class="in1"></span><span class="fn">testFrag</span>(<span class="var">frag</span>, <span class="str">"abcdef"</span>);<br/>
} <span class="macro">@end(<span class="name">unit tests</span>)</span><br/>
</code></div>
<ul><li>
Prüft, ob zwei Strings richtig serialisiert werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">unit tests</span>)</span> {<br/>
<span class="in1"></span><span class="type">Frag</span> <span class="var">a</span> { <span class="str">""</span> };<br/>
<span class="in1"></span><span class="type">Frag</span> <span class="var">b</span> { <span class="str">""</span> };<br/>
<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">a</span>, <span class="str">"abc"</span>);<br/>
<span class="in1"></span><span class="var">b</span>.<span class="fn">add</span>(&amp;<span class="var">a</span>);<br/>
<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">b</span>, <span class="str">"def"</span>);<br/>
<span class="in1"></span><span class="var">b</span>.<span class="fn">add</span>(&amp;<span class="var">a</span>);<br/>
<span class="in1"></span><span class="fn">testFrag</span>(<span class="var">b</span>, <span class="str">"abcdefabc"</span>);<br/>
} <span class="macro">@end(<span class="name">unit tests</span>)</span><br/>
</code></div>
<ul><li>
Prüft, ob Fragmente expandiert werden
</li></ul>
</div>
</div>
<h1>Zykel im Fragment-Graph finden</h1>
<div class="slides">
<div>
<div>
<h1>Zykel im Fragment-Graph finden</h1>
</div>
<ul><li>
Prüft ob das Hinzufügen eines Fragments zu einem Zykel führt
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">define cycle check</span>)</span><br/>
<span class="in1"></span><span class="type">bool</span> <span class="fn">isFragInFrag</span>(<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">needle</span>,<br/>
<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">haystack</span><br/>
<span class="in1"></span>) {<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">needle</span>);<br/>
<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">haystack</span>);<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">check cycle frag</span>)</span>;<br/>
<span class="in2"></span><span class="macro">@put(<span class="name">check cycle entries</span>)</span>;<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">define cycle check</span>)</span><br/>
</code></div>
<ul><li>
Wenn das Fragment das gesuchte ist, dann wurde ein Zykel gefunden
</li><li>
Danach wird über alle Einträge gesucht
</li><li>
Wenn das Fragment dort nicht gefunden wurde, dann ist es nicht  enthalten
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">avoid frag cycles</span>)</span><br/>
<span class="in1"></span><span class="fn">ASSERT</span>(! <span class="fn">isFragInFrag</span>(<br/>
<span class="in2"></span><span class="var">this</span>, <span class="var">child</span><br/>
<span class="in1"></span>));<br/>
<span class="macro">@end(<span class="name">avoid frag cycles</span>)</span><br/>
</code></div>
<ul><li>
Ein Fragment darf nur hinzugefügt werden, wenn es den Container nicht  bereits enthält
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">check cycle frag</span>)</span><br/>
<span class="in1"></span><span class="keyword">if</span> (<span class="var">needle</span> == <span class="var">haystack</span>) {<br/>
<span class="in2"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">check cycle frag</span>)</span><br/>
</code></div>
<ul><li>
Wenn der Container selbst das gesuchte Fragment ist, liefert die  Funktion <code><span class="num">true</span></code> zurück
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@def(<span class="name">check cycle entries</span>)</span><br/>
<span class="in1"></span><span class="keyword">for</span> (<span class="type">const</span> <span class="type">auto</span> &amp;<span class="var">i</span> : *<span class="var">haystack</span>)  {<br/>
<span class="in2"></span><span class="keyword">if</span> (! <span class="var">i</span>.<span class="var">frag</span>) { <span class="keyword">continue</span>; }<br/>
<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isFragInFrag</span>(<br/>
<span class="in3"></span><span class="var">needle</span>, <span class="var">i</span>.<span class="var">frag</span><br/>
<span class="in2"></span>)) {<br/>
<span class="in3"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>
<span class="in2"></span>}<br/>
<span class="in1"></span>}<br/>
<span class="macro">@end(<span class="name">check cycle entries</span>)</span><br/>
</code></div>
<ul><li>
Alle Fragment in den Einträgen werden rekursiv untersucht
</li><li>
Damit wird der ganze Graph durchsucht
</li></ul>
</div>
</div>
<h1>Fragment-Kollektion</h1>
<div class="slides">
<div>
<div>
<h1>Fragment-Kollektion</h1>
</div>
<ul><li>
Kollektion von Fragmenten, die in mehreren Hierarchien organisiert  werden
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@Add(<span class="name">includes</span>)</span><br/>
<span class="in1"></span><span class="keyword">#include</span> &lt;<span class="type">map</span>&gt;<br/>
<span class="macro">@end(<span class="name">includes</span>)</span><br/>
</code></div>
<ul><li>
<code><span class="type">FragMap</span></code> enthält eine <code><span class="type">std</span>::<span class="type">map</span></code>
</li></ul>
</div>
<div><div>
<code>
<span class="macro">@add(<span class="name">define frag</span>)</span><br/>
<span class="in1"></span><span class="keyword">using</span> <span class="type">FragMap</span> =<br/>
<span class="in2"></span><span class="type">std</span>::<span class="type">map</span>&lt;<span class="type">std</span>::<span class="type">string</span>, <span class="type">Frag</span>&gt;;<br/>
<span class="macro">@end(<span class="name">define frag</span>)</span><br/>
</code></div>
<ul><li>
Eine Kollektion von Fragmenten ist ein Array von Fragment-Ketten
</li><li>
Alle Felder müssen mit <code><span class="num">nullptr</span></code> initialisiert werden
</li></ul>
</div>
</body>
</html>
