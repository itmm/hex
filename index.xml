<html lang="de">
		<head>
			<meta charset="utf-8" />
			<title>HTML Extractor</title>
			<link rel="stylesheet" type="text/css"
				href="slides/slides.css" />
		</head>
	<body>
		<h1>HTML Extractor</h1>
			<p>
				Dieses Dokument enthält eine Präsentation, welche die
				Entwicklung des <emph>HTML Extractors</emph>
				(<code>hex</code>) beschreibt.
				Sie enthält zusätzlich den gesamten Source-Code von
				<code>hex</code>.
			</p><p>
				Es handelt sich um den Versuch eines neuen
				Programmier-Konzeptes: des Slideware-Programming (SWP).
				Viel Spass.
			</p>

			<div class="slides">
				<div>
					<div>
						<h1>HTML Extractor</h1>
					</div>
					<ul>
						<li>
							<code>hex</code> extrahiert Source-Code aus
							HTML-Präsentationen
						</li><li>
							In der Präsentation kann der Schritt für
							Schritt eingeführt werden
						</li><li>
							Es ist die Aufgabe von <code>hex</code>,
							daraus ein ausführbares Programm zu
							generieren
						</li>
					</ul>
				</div><div>
					<div>
						<h1>Slideware Programming (SWP)</h1>
					</div>
					<ul>
						<li>
							Aus dem Source-Code, der in einer
							HTML-Präsentation enthalten ist, kann ein
							ausführbares Programm generiert werden
						</li><li>
							Dabei wird das Programm schrittweise
							aufgebaut
						</li>
					</ul>
				</div><div>
					<div>
						<h1>SWP &ne; Literate Programming</h1>
					</div>
					<ul>
						<li>
							SWP beschreibt nicht nur ein fertiges
							Programm,
						</li><li>
							Sondern wie das Programm aufgebaut wird
						</li><li>
							Zu jedem Zeitpunkt muss das bisher
							beschriebene Programm ausführbar sein,
						</li><li>
							Wenn nicht definierte Makros zu nichts
							expandieren.
						</li><li>
							So kann das Verständnis für ein Programm
							schrittweise erarbeitet werden
						</li>
					</ul>
				</div>
			</div>
		<h1>Definition des Ablaufs</h1>
			<div class="slides">
				<div>
					<div><code>
						a{MAIN}b{}
						1{}e{global elements}b{}
						1{}t{int} f{main}(b{}
						2{}t{int} v{argc}, t{const char **}v{argv}b{}
						1{}) {b{}
						2{}e{main body}b{}
						1{}}b{}
						x{MAIN}
					</code></div>
					<ul>
						<li>
							Das Hauptprogramm besteht aus der
							<code lang="fn">main</code>-Funktion
						</li><li>
							Zusätzlich müssen Objekte im globalen Scope
							definiert werden
						</li>
					</ul>
				</div><div>
					<div><code>
						a{main body}b{}
						1{}e{perform unit-tests};b{}
						1{}e{process arguments};b{}
						1{}e{read source file};b{}
						1{}e{write HTML file};b{}
						1{}e{serialize fragments};b{}
						1{}e{compile program};b{}
						x{main body}
					</code></div>
					<ul>
						<li>
							Bei jedem Start werden alle Unit-Tests
							ausgeführt (um eine umfangreiche
							Testabdeckung zu sichern)
						</li><li>
							Eventuell werden Parameter von der
							Kommandozeile ausgewertet
						</li><li>
							Dann wird ein Parse-Graph aus Fragmenten
							aufgebaut
						</li><li>
							Und das daraus resultiernde Programm
							übersetzt
						</li>
					</ul>
				</div><div>
					<div>
						<h1>Was macht <code class="expand">@expand</code>?</h1>
					</div>
					<ul>
						<li>
							<code class="expand">@expand</code>-Blöcke
							beschreiben Makro-Aufrufe.
						</li><li>
							Der Wert des Makros mit dem Namen in Klammern
							wird anstelle des Aufrufs im endgültigen
							Programm gesetzt.
						</li><li>
							Diese Makros bilden ein zentrales Element von
							<code>hex</code>.
						</li><li>
							Sie können mit <code
								class="add">@add</code>-<code
								class="end">@end</code>-Sequenzen
							definiert oder erweitert werden.
						</li>
					</ul>
				</div><div>
					<div><code>
						a{global elements}b{}
						1{}e{includes};b{}
						1{}e{define logging};b{}
						1{}e{forward declarations};b{}
						x{global elements}
					</code></div>
					<ul>
						<li>
							System-Dateien werden vor der Definition von
							Strukturen und Funktionen eingebunden.
						</li><li>
							Auch müssen Macros für das Logging vor den
							Funktionen definiert werden, die sie
							verwenden
						</li>
					</ul>
				</div>
			</div>
		<h1>Minimale Vorbereitung für das Parsen</h1>
			<div class="slides">
				<div>
					<div><code>
						a{includes}b{}
						1{}#include &lt;stdio.h&gt;b{}
						1{}#include &lt;stdlib.h&gt;b{}
						x{includes}
					</code></div>
					<ul>
						<li>
							Standard File-Funktionen werden vom Programm
							benötigt
						</li><li>
							Standard Bibliothek wird für dynamische
							Speicherverwaltung benötigt
						</li>
					</ul>
				</div><div>
					<div><code>
						a{global elements}b{}
						1{}t{struct Input} {b{}
						2{}t{struct Input *}v{link};b{}
						2{}t{FILE *}v{file};b{}
						1{}};b{}
						b{}
						1{}t{struct Input *}v{input} = k{NULL};b{}
						x{global elements}
					</code></div>
					<ul>
						<li>
							Es gibt immer eine aktuelle Datei, die gerade
							gelesen wird
						</li><li>
							Mitten während des Lesens können andere
							Dateien eingelesen (inkludiert) werden
						</li><li>
							Daher gibt es einen Stapel offener Dateien
						</li><li>
							Aus der letzten wird gelesen
						</li>
					</ul>
				</div><div>
					<div><code>
						a{global elements}b{}
						1{}t{void} f{pushFile} (t{FILE *}v{file}) {b{}
						2{}t{struct Input *}v{i} =b{}
						3{}f{malloc}(f{sizeof}(t{struct Input}));b{}
						b{}
						2{}e{check memory for input};b{}
						2{}v{i}-&gt;v{link} = v{input};b{}
						2{}v{i}-&gt;v{file} = v{file};b{}
						2{}v{input} = v{i};b{}
						1{}}b{}
						x{global elements}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process arguments}b{}
						1{}f{pushFile}(v{stdin});b{}
						x{process arguments}
					</code></div>
					<ul>
						<li>
							Der Source-Code für die Slideware muss aus
							einer Datei geladen werden
						</li><li>
							Der Name kann über die Kommandozeile gesetzt
							werden
						</li><li>
							Aber bis das implementiert ist, nehmen wird
							eine sinnvolle Vorgabe
						</li>
					</ul>
				</div><div>
					<div><code>
						a{global elements}b{}
						1{}t{int} f{nextCh}() {b{}
						2{}t{int} v{ch} = k{EOF};b{}
						2{}k{while} (v{input}) {b{}
						3{}v{ch} = f{fgetc}(v{input}-&gt;v{file});b{}
						3{}k{if} (v{ch} != k{EOF}) { k{break}; }b{}
						3{}t{struct Input *}v{n} = v{input}-&gt;v{link};b{}
						3{}f{fclose}(v{input}-&gt;v{file});b{}
						3{}f{free}(v{input});b{}
						3{}v{input} = v{n};b{}
						2{}}b{}
						2{}k{return} v{ch};b{}
						1{}}b{}
						x{global elements}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{global elements}b{}
						1{}t{void} f{pushPath}(t{const char *}v{path}) {b{}
						2{}t{FILE *}v{f} = f{fopen}(v{path}, s{"r"});b{}
						2{}e{check file for path};b{}
						2{}f{pushFile}(v{f});b{}
						1{}}b{}
						x{global elements}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div>
			</div>
		<h1>Buffer</h1>
			<div class="slides">
				<div>
					<div><code>
						i{buffer.xml}b{}
					</code></div>
					<ul>
						<li>
							Buffer werden in einer eigenen Datei
							definiert
						</li>
					</ul>
				</div>
			</div>
		<h1>Consumer</h1>
			<div class="slides">
				<div>
					<div><code>
						i{consumer.xml}b{}
					</code></div>
					<ul>
						<li>
							Consumer werden in einer eigenen Datei
							definiert
						</li>
					</ul>
				</div>
			</div>
		<h1>Makros</h1>
			<div class="slides">
				<div>
					<div><code>
						i{macros.xml}
					</code></div>
					<ul>
						<li>
							Makros werden in einer eigenen Datei
							definiert
						</li>
					</ul>
				</div>
			</div>
		<h1>Input Dateien lesen</h1>
			<div class="slides">
				<div>
					<div><code>
						a{read source file}b{}
						1{}e{global source vars};b{}
						1{}{b{}
						2{}e{additional read vars};b{}
						2{}t{int} v{last} = f{nextCh}();b{}
						2{}t{int} v{ch} = f{nextCh}();b{}
						2{}k{while} (v{ch} != v{EOF}) {b{}
						3{}e{process current char};b{}
						3{}v{last} = v{ch}; v{ch} = f{nextCh}();b{}
						2{}}b{}
						1{}}b{}
						x{read source file}
					</code></div>
					<ul>
						<li>
							Neben dem aktuellen Zeichen wird auch das
							letzte Zeichen aufgehoben
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process current char}b{}
						1{}k{switch} (v{ch}) {b{}
						2{}k{case} '{':b{}
						3{}e{process open brace};b{}
						3{}k{break};b{}
						2{}k{case} '}': {b{}
						3{}t{bool} v{processed} = k{false};b{}
						3{}e{process close brace};b{}
						3{}k{break};b{}
						2{}}b{}
						2{}k{default}:b{}
						3{}e{process other char};b{}
						1{}}b{}
						x{process current char}
					</code></div>
					<ul>
						<li>
							Beim Parsen kommt es nur auf das Öffnen und
							Schließen von Mengenklammern an
						</li>
					</ul>
				</div><div>
					<div><code>
						a{additional read vars}b{}
						1{}t{struct Macro *} v{macro} = k{NULL};b{}
						1{}t{struct Buffer} v{buffer} = {};b{}
						x{additional read vars}
					</code></div>
					<ul>
						<li>
							Wir unterscheiden, ob wir in einem Code-Block
							sind, oder außerhalb
						</li><li>
							In einem Code sind wir sogar in einem Makro,
							dessen Inhalt gelesen wird
						</li><li>
							Am Anfang sind wir außerhalb eines
							Code-Blocks
						</li>
					</ul>
				</div><div>
					<div><code>
						a{additional read vars}b{}
						1{}t{char} v{openCh} = s{'\0'};b{}
						x{additional read vars}
					</code></div>
					<ul>
						<li>
							Der Befehl vor einer öffnenden Mengenklammer
							wird in dieser Variable zwischengespeichert
						</li>
					</ul>
				</div><div>
					<div><code>
						a{additional read vars}b{}
						1{}t{char} v{name}t{[128]};b{}
						1{}t{char *}v{nameCur} = k{NULL};b{}
						1{}t{const char *}v{nameEnd} = v{name} +b{}
						2{}k{sizeof}(v{name});b{}
						x{additional read vars}
					</code></div>
					<ul>
						<li>
							Wenn <code class="var">nameCur</code> gesetzt
							ist, dann wird ein Name in Buffer gelesen
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process close brace} {b{}
						1{}k{if} (v{nameCur}) {b{}
						2{}*v{nameCur} = s{'\0'};b{}
						2{}e{process macro name};b{}
						2{}v{nameCur} = k{NULL};b{}
						2{}v{last} = v{ch};b{}
						2{}v{ch} = f{nextCh}();b{}
						1{}}b{}
						} x{process close brace}
					</code></div>
					<ul>
						<li>
							Bei einer schließenden Mengenklammer wird der
							Makro-Name ausgewertet
						</li><li>
							Danach wird der Namenszeiger zurückgesetzt
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process other char} {b{}
						1{}k{if} (v{nameCur}) {b{}
						2{}f{ASSERT}(v{nameCur} &lt; v{nameEnd});b{}
						2{}*v{nameCur}++ = v{ch};b{}
						2{}k{break};b{}
						1{}}b{}
						} x{process other char}
					</code></div>
					<ul>
						<li>
							Wenn ein Name geparst wird, dann der
							Namensbuffer entsprechend erweitert
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process other char} {b{}
						1{}k{if} (v{macro}) {b{}
						2{}f{addToBuffer}(&amp;v{buffer}, v{last});b{}
						1{}}b{}
						} x{process other char}
					</code></div>
					<ul>
						<li>
							Wenn es ein aktuelles Makro gibt, dann müssen
							sonstige Zeichen dort angefügt werden
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process open brace} {b{}
						1{}k{if} (! v{macro}) {b{}
						2{}k{if} (v{last} == s{'a'} || v{last} == s{'i'}) {b{}
						3{}v{openCh} = v{last};b{}
						3{}v{nameCur} = v{name};b{}
						3{}k{break};b{}
						2{}}b{}
						1{}}b{}
						} x{process open brace}
					</code></div>
					<ul>
						<li>
							Wenn außerhalb eines Makros die Folge
							<code>a</code><code>{</code>
							gelesen wird, dann beginnt ein 
							<code class="add">@add</code> Fragment
						</li><li>
							Falls ein <code>i</code><code>{</code>
							gelesen wird, dann muss eine andere Datei
							mit <code class="add">@include</code>
							eingebunden werden
						</li><li>
							Es folgt der Name des Makros oder der Pfad
							der Datei bis zum nächsten
							<code>}</code>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{global source vars}b{}
						1{}t{struct MacroMap} v{macros} = {};b{}
						x{global source vars}
					</code></div>
					<ul>
						<li>
							Kollektion mit allen Makros wird für
							folgende Schritte sichtbar angelegt
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process macro name}b{}
						1{}k{if} (v{openCh} == s{'a'}) {b{}
						2{}f{ASSERT}(! v{macro});b{}
						2{}v{macro} = f{getMacroInMap}(b{}
							3{}&amp;v{macros}, v{name}, v{nameCur}b{}
						2{});b{}
						2{}v{processed} = k{true};b{}
						1{}}b{}
						x{process macro name}
					</code></div>
					<ul>
						<li>
							Bei einem öffnenden Makro wird das passende
							Makro gesucht
						</li><li>
							Weitere Bytes können zu diesem Makro
							hinzugefügt werden
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process macro name}b{}
						1{}k{if} (v{openCh} == s{'x'}) {b{}
						2{}f{ASSERT}(v{macro});b{}
						2{}e{macro names must match};b{}
						2{}e{flush macro buffer};b{}
						2{}v{macro} = k{NULL};b{}
						2{}v{processed} = k{true};b{}
						1{}}b{}
						x{process macro name}
					</code></div>
					<ul>
						<li>
							Bei einem schließenden Makro wird das
							aktuelle Makro unterbrochen
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process macro name}b{}
						1{}k{if} (v{openCh} == s{'i'}) {b{}
						2{}f{ASSERT}(! v{macro});b{}
						2{}f{pushPath}(v{name});b{}
						2{}v{processed} = k{true};b{}
						1{}}b{}
						x{process macro name}
					</code></div>
					<ul>
						<li>
							Wenn eine Datei eingebunden werden soll,
							dann wird sie geöffnet und auf den Stapel
							der offenen Dateien gelegt.
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process macro name}b{}
						1{}k{if} (v{openCh} == s{'e'}) {b{}
						2{}f{ASSERT}(v{macro});b{}
						2{}e{flush macro buffer};b{}
						2{}t{struct Macro *}v{sub} =b{}
						3{}f{getMacroInMap}(b{}
						4{}&amp;v{macros}, v{name}, v{nameCur});b{}
						2{}f{addMacroToMacro}(b{}
						3{}v{macro}, v{sub});b{}
						2{}v{processed} = k{true};b{}
						1{}}b{}
						x{process macro name}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{flush macro buffer}b{}
						1{}k{if} (b{}
						2{}v{buffer}.v{buffer} != v{buffer}.v{current}b{}
						1{}) {b{}
						2{}f{addBytesToMacro}(b{}
						3{}v{macro}, v{buffer}.v{buffer},b{}
						3{}v{buffer}.v{current}b{}
						2{});b{}
						2{}f{resetBuffer}(&amp;v{buffer});b{}
						1{}}b{}
						x{flush macro buffer}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process open brace} {b{}
						1{}k{if} (v{macro}) {b{}
						2{}t{bool} v{valid} = k{false};b{}
						2{}e{check valid names};b{}
						2{}k{if} (v{valid}) {b{}
						3{}v{openCh} = v{last};b{}
						3{}v{nameCur} = v{name};b{}
						3{}k{break};b{}
						2{}}b{}
						1{}}b{}
						} x{process open brace}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{check valid names}b{}
						1{}k{static} t{const char} v{valids}[] =b{}
						2{}s{"12345bfvsntkxe"};b{}
						1{}k{if} (f{strchr}(v{valids}, v{last})) {b{}
						2{}v{valid} = k{true};b{}
						1{}}b{}
						x{check valid names}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process macro name}b{}
						1{}k{if} (! v{processed}) {b{}
						2{}f{ASSERT}(v{macro});b{}
						2{}t{const char *}v{c} = v{name};b{}
						2{}k{for} (; v{c} != v{nameCur}; ++v{c}) {b{}
						3{}f{addToBuffer}(&amp;v{buffer}, *v{c});b{}
						2{}}b{}
						2{}v{processed} = k{true};b{}
						1{}}b{}
						x{process macro name}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{process open brace}b{}
						1{}k{if} (v{macro}) {b{}
						2{}f{addToBuffer}(&amp;v{buffer}, v{last});b{}
						1{}}b{}
						x{process open brace}b{}
						b{}
						a{process close brace}b{}
						1{}k{if} (v{macro} &amp;&amp; ! v{processed}) {b{}
						2{}f{addToBuffer}(&amp;v{buffer}, v{last});b{}
						1{}}b{}
						x{process close brace}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div>
			</div>
		<h1>Entities auflösen</h1>
			<div class="slides">
				<div>
					<div><code>
						i{entities.xml}
					</code></div>
					<ul>
						<li>
							Entities werden in einer eigenen Datei
							expandiert
						</li>
					</ul>
				</div>
			</div>
		<h1>Serialize Fragments</h1>
			<div class="slides">
				<div>
					<div><code>
						a{serialize fragments} {b{}
						1{}t{const char} v{name}t{[]} = s{"MAIN"};b{}
						1{}t{struct Macro *} v{macro} = f{getMacroInMap}(b{}
						2{}&amp;v{macros}, v{name},b{}
						2{}v{name} + k{sizeof}(v{name}) - 1b{}
						1{});b{}
						1{}t{struct FileConsumer} v{fc};b{}
						1{}f{setupFileConsumer}(&amp;v{fc}, v{stdout});b{}
						1{}t{struct EntityConsumer} v{ec};b{}
						1{}f{setupEntityConsumer}(&amp;v{ec}, &amp;v{fc}.v{consumer});b{}
						1{}f{serializeMacro}(b{}
						2{}v{macro}, &amp;v{ec}.v{consumer}b{}
						1{});b{}
						} x{serialize fragments}
					</code></div>
					<ul>
						<li>
						</li>
					</ul>
				</div>
			</div>
	</body>
</html>
