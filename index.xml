<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<title>HTML Extractor</title>
		<link rel="stylesheet" type="text/css"
			href="slides/slides.css">
	</head>
	<body>
		<h1>HTML Extractor</h1>

		<p>
			Dieses Dokument enthält eine Präsentation, welche die
			Entwicklung des <emph>HTML Extractors</emph>
			(<code>hex</code>) beschreibt.
			Sie enthält zusätzlich den gesamten Source-Code von
			<code>hex</code>.
		</p><p>
			Es handelt sich um den Versuch eines neuen
			Programmier-Konzeptes: des Slideware-Programming (SWP).
			Viel Spass.
		</p>

		<div class="slides">
			<div class="row">
				<div class="slide title">
					<h1>HTML Extractor</h1>
				</div>
				<ul class="notes">
					<li>
						<code>hex</code> extrahiert Source-Code aus
						HTML-Präsentationen
					</li><li>
						In der Präsentation kann der Schritt für Schritt
						eingeführt werden
					</li><li>
						Es ist die Aufgabe von <code>hex</code>, daraus
						ein ausführbares Programm zu generieren
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>Slideware Programming (SWP)</h1>
				</div>
				<ul class="notes">
					<li>
						Aus dem Source-Code, der in einer
						HTML-Präsentation enthalten ist, kann ein
						ausführbares Programm generiert werden
					</li><li>
						Dabei wird das Programm schrittweise aufgebaut
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>SWP &ne; Literate Programming</h1>
				</div>
				<ul class="notes">
					<li>
						SWP beschreibt nicht nur ein fertiges Programm,
					</li><li>
						Sondern wie das Programm aufgebaut wird
					</li><li>
						Zu jedem Zeitpunkt muss das bisher beschriebene
						Programm ausführbar sein,
					</li><li>
						Wenn nicht definierte Makros zu nichts
						expandieren.
					</li><li>
						So kann das Verständnis für ein Programm
						schrittweise erarbeitet werden
					</li>
				</ul>
			</div>
		</div>
		<h1>Definition des Ablaufs</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					e{global elements}n{}
					n{}
					t{int} f{main}(n{}
					1{}t{int} v{argc},n{}
					1{}t{const char **}v{argv}n{}
					) {n{}
					1{}e{perform unit-tests};n{}
					1{}e{process arguments};n{}
					1{}e{process HTML file};n{}
					1{}e{serialize fragments};n{}
					1{}e{compile program};n{}
					}
				</code></div>
				<ul class="notes">
					<li>
						Bei jedem Start werden alle Unit-Tests
						ausgeführt (um eine umfangreiche Testabdeckung
						zu sichern)
					</li><li>
						Eventuell werden Parameter von der Kommandozeile
						ausgewertet
					</li><li>
						Dann wird ein Parse-Graph aus Fragmenten
						aufgebaut
					</li><li>
						Und das daraus resultiernde Programm übersetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide title">
					<h1>Was macht <code class="expand">@expand</code>?</h1>
				</div>
				<ul class="notes">
					<li>
						<code class="expand">@expand</code>-Blöcke
						beschreiben Makro-Aufrufe.
					</li><li>
						Der Wert des Makros mit dem Namen in Klammern
						wird anstelle des Aufrufs im endgültigen
						Programm gesetzt.
					</li><li>
						Diese Makros bilden ein zentrales Element von
						<code>hex</code>.
					</li><li>
						Sie können mit
						<code class="add">@add</code>-<code class="end">@end</code>-Sequenzen
						definiert oder erweitert werden.
					</li>
				</ul>
			</div>
		</div>
		<h1>Makros</h1>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{global elements}n{}
					1{}e{includes};n{}
					1{}e{define logging};n{}
					1{}e{define macro};n{}
					x{global elements}
				</code></div>
				<ul class="notes">
					<li>
						System-Dateien werden vor der Definition von
						Strukturen und Funktionen eingebunden.
					</li><li>
						Auch müssen Macros für das Logging vor den
						Funktionen definiert werden, die sie verwenden
					</li><li>
						Makros sind global sichtbare Strukturen.
						Und das daraus resultiernde Programm übersetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct MacroEntry};n{}
					n{}
					1{}t{struct Macro} {n{}
					2{}t{struct Macro *}v{link};n{}
					2{}t{struct MacroEntry *}v{firstEntry};n{}
					2{}t{struct MacroEntry *}v{lastEntry};n{}
					2{}t{char }v{name}t{[]};n{}
					1{}};n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Die Makros werden in einfach verketteten Listen
						gesammelt
					</li><li>
						Genauso werden die Einträge eines Makros in
						einer einfach verketteten Liste organisiert
					</li><li>
						Um schnell Einträge einfügen zu können, gibt es
						auch einen Verweis auf das letzte Element
					</li><li>
						Je nach Namen werden für ein Makro
						unterschiedlich viele Bytes im Heap angefordert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{includes}n{}
					1{}i{stdlib.h}n{}
					x{includes}
				</code></div>
				<ul class="notes">
					<li>
						<code class="include-name">stdlib.h</code> wird für die Definition
						von <code class="keyword">NULL</code> benötigt
					</li>
				</ul>
			</div>
		</div>
		<h2>Neues Makro anlegen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct Macro *}f{allocMacro}(n{}
					2{}t{const char *}v{nameBegin},n{}
					2{}t{const char *}v{nameEnd}n{}
					1{}) {n{}
					2{}t{struct Macro *}v{result} = k{NULL};n{}
					2{}e{allocate macro on heap};n{}
					2{}v{result}-&gt;v{link} = k{NULL};n{}
					2{}v{result}-&gt;v{firstEntry} = k{NULL};n{}
					2{}e{copy macro name};n{}
					2{}k{return} v{result};n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Die Zeiger werden mit
						<code class="keyword">NULL</code> initializiert
					</li><li>
						<code class="var">lastEntry</code> wird erst
						initialisiert, wenn
						<code class="var">firstEntry</code> gesetzt wird
					</li><li>
						Der Name wird über zwei Zeiger übergeben, muss
						also nicht mit einem Null-Byte terminiert sein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{includes}n{}
					1{}i{stdio.h}n{}
					x{includes}n{}
					n{}
					a{define logging}n{}
					1{}<span class="define">#define <span class="name">ASSERT</span>(v{COND}) \</span>n{}
					2{}<span class="define">k{if} (! (v{COND})) {\ </span>n{}
					3{}<span class="define">f{fprintf}(v{stderr}, \</span>n{}
					4{}<span class="define">s{"%s:%d FAILED\n"}, \</span>n{}
					4{}<span class="define">__FILE__, __LINE__); \</span>n{}
					3{}<span class="define">f{exit}(v{EXIT_FAILURE}); \</span>n{}
					2{}<span class="define">}</span>n{}
					x{define logging}
				</code></div>
				<ul class="notes">
					<li>
						Wenn Bedingung falsch ist, wird Fehlermeldung
						ausgegeben
					</li><li>
						Und das Programm beendet
					</li><li>
						Datei und Zeile des Tests wird ausgegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{allocate macro on heap}n{}
					1{}f{ASSERT}(v{nameBegin});n{}
					1{}f{ASSERT}(v{nameBegin} &lt;= v{nameEnd});n{}
					1{}t{int} v{nameLength} =n{}
  					2{}v{nameEnd} - v{nameBegin};n{}
					1{}t{int} v{macroSize} = k{sizeof}(t{struct Macro})n{}
   					2{}+ v{nameLength} + 1;n{}
					1{}v{result} = v{malloc}(v{macroSize});n{}
					1{}f{ASSERT}(v{result});n{}
					x{allocate macro on heap}
				</code></div>
				<ul class="notes">
					<li>
						Die Zeiger werden mit
						<code class="keyword">NULL</code> initializiert
					</li><li>
						<code class="var">lastEntry</code> wird erst
						initialisiert, wenn
						<code class="var">firstEntry</code> gesetzt wird
					</li><li>
						Der Name wird über zwei Zeiger übergeben, muss
						also nicht mit einem Null-Byte terminiert sein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{includes}n{}
					1{}i{string.h}n{}
					x{includes}n{}
					n{}
					a{copy macro name}n{}
					1{}f{memcpy}(n{}
					2{}v{result}-&gt;v{name}, v{nameBegin},n{}
		 			2{}v{nameLength}n{}
					1{});n{}
					1{}v{result}-&gt;v{name}[v{nameLength}] = s{'\0'};n{}
					x{copy macro name}
				</code></div>
				<ul class="notes">
					<li>
						Der Name wird direkt in die das Makro kopiert
					</li><li>
						Der Name wird mit einem Null-Byte abgeschlossen
					</li>
				</ul>
			</div>
		</div>
		<h2>Makros freigeben</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}k{void} f{freeMacro}(n{}
					2{}t{struct Macro *}v{macro}n{}
					1{}) {n{}
					2{}k{while} (v{macro}) {n{}
					3{}t{struct Macro *}v{link} =n{}
					4{}v{macro}-&gt;v{link};n{}
					3{}e{free macros entries};n{}
					3{}f{free}(v{macro});n{}
					3{}v{macro} = v{link};n{}
					2{}}n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Mit einem Makro werden auch alle verketteten
						Makros freigegeben
					</li><li>
						Die Freigabe der einzelnen Einträge wird später
						definiert
					</li>
				</ul>
			</div>
		</div>
		<h2>Unit Tests</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{perform unit tests}n{}
					1{}e{macro unit tests};n{}
					x{perform unit tests}n{}
					n{}
					a{define macro}n{}
					1{}t{struct Macro *}f{allocTestMacro}(n{}
					2{}t{const char *}v{name}n{}
					1{}) {n{}
					2{}k{return} f{allocMacro}(n{}
					3{}v{name}, v{name} + f{strlen}(v{name})n{}
					2{});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Für Unit-Tests gibt es einen einfacheren
						Konstruktor
					</li><li>
						Die Länge des Namens wird anhand des Null-Bytes
						berechnet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}k{void} f{testMacroName}(n{}
					2{}t{const char *}v{name}n{}
					1{}) {n{}
					2{}t{struct Macro *}v{macro} =n{}
					3{}f{allocTestMacro}(v{name});n{}
					2{}f{ASSERT}(v{macro});n{}
					2{}f{ASSERT}(n{}
	   				3{}f{strcmp}(v{macro}-&gt;v{name}, v{name}) == 0n{}
  					2{});n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						<code class="fn">testMacroName</code> prüft, ob
						der Name korrekt in ein Makro kopiert wurde.
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}f{testMacroName}(s{"abc"});n{}
					1{}f{testMacroName}(s{""});n{}
					1{}f{testMacroName}(s{"A c"});n{}
					1{}{n{}
					2{}t{struct Macro *}v{macro} =n{}
					3{}f{allocTestMacro}(s{"ab"});n{}
					2{}f{ASSERT}(v{macro});n{}
					2{}f{ASSERT}(! v{macro}-&gt;v{link});n{}
					2{}f{ASSERT}(! v{macro}-&gt;v{firstEntry});n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Zum einen wird getestet, ob die Namen korrekt
						kopiert werden
					</li><li>
						Zum anderen wird sichergestellt, dass die
						Verweise <code class="keyword">NULL</code> sind
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Einträge</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct MacroEntry} {n{}
					2{}t{struct MacroEntry *}v{link};n{}
					2{}t{struct Macro *}v{macro};n{}
					2{}t{const char *}v{valueEnd};n{}
					2{}t{char }v{value}t{[]};n{}
					1{}};n{}
					x{define macro}n{}
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag kann entweder auf ein anderes Makro
						verweisen (wenn dieses an der aktuellen Stelle
						expandiert werden soll)
					</li><li>
						Oder er enthält Bytes, die beim Expandieren
						direkt expandiert werden
					</li><li>
						Die Länge des Byte-Arrays wird über einen Zeiger
						angezeigt (damit auch Null-Bytes verwendet
						werden können)
					</li><li>
						Wenn ein Eintrag sowohl Daten als auch ein Makro
						enthält, so wird zuerst der Text ausgegeben
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Eintrag anlegen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct MacroEntry *}f{allocMacroEntry}(n{}
					2{}t{struct Macro *}v{macro},n{}
					2{}t{const char *}v{valueBegin},n{}
					2{}t{const char *}v{valueEnd}n{}
					1{}) {n{}
					2{}t{struct MacroEntry *}v{result} = k{NULL};n{}
					2{}e{allocate entry on heap};n{}
					2{}v{result}-&gt;v{link} = k{NULL};n{}
					2{}e{copy entry values};n{}
					2{}k{return} v{result};n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Wie beim Macro werden die
						<code class="var">link</code> Verweise auf
						<code class="keyword">NULL</code> initialisiert
					</li><li>
						Sowohl <code class="var">macro</code> als auch
						<code class="var">valueBegin</code> sind
						optional
					</li><li>
						Die Größe des Eintrags hängt von der Größe der
						Bytes ab, die kopiert werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{allocate entry on heap}n{}
					1{}t{int} v{valueLength} = 0;n{}
					1{}k{if} (v{valueBegin}) {n{}
					2{}f{ASSERT}(v{valueBegin} &lt;= v{valueEnd});n{}
					2{}v{valueLength} =n{}
	   				3{}v{valueEnd} - v{valueBegin};n{}
					1{}}n{}
					1{}t{int} v{entrySize} = v{valueLength} +n{}
					2{}k{sizeof}(t{struct MacroEntry});n{}
					1{}v{result} = v{malloc}(v{entrySize});n{}
					1{}f{ASSERT}(v{result});n{}
					x{allocate entry on heap}
				</code></div>
				<ul class="notes">
					<li>
						Die Größe der Struktur wird um die Anzahl der zu
						kopierenden Bytes vergrößert
					</li><li>
						Wenn nicht genug Speicher vorhanden ist, dann
						wird das Programm beendet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{copy entry values}n{}
					1{}k{if} (v{valueBegin}) {n{}
					2{}f{memcpy}(n{}
					3{}v{result}-&gt;v{value}, v{valueBegin},n{}
		 			3{}v{valueLength}n{}
					2{});n{}
					1{}}n{}
					1{}v{result}-&gt;v{valueEnd} =n{}
					2{}v{result}-&gt;v{value} + v{valueLength};n{}
					1{}v{result}-&gt;v{macro} = v{macro};n{}
					x{copy entry values}
				</code></div>
				<ul class="notes">
					<li>
						Die Bytes werden nur kopiert, wenn welche
						übergeben wurden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct MacroEntry *}n{}
					1{}f{allocEmptyMacroEntry}() {n{}
					2{}k{return} f{allocMacroEntry}(n{}
					3{}k{NULL}, k{NULL}, k{NULL}n{}
					2{});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Für Tests ist es praktisch, leere Einträge
						anzulegen
					</li>
				</ul>
			</div>
		</div>
		<h2>Makro Einträge freigeben</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}k{void} f{freeMacroEntry}(n{}
					2{}t{struct MacroEntry *}v{entry}n{}
					1{}) {n{}
					2{}k{while} (v{entry}) {n{}
					3{}t{struct MacroEntry *}v{link} =n{}
					4{}v{entry}-&gt;v{link};n{}
					3{}f{free}(v{entry});n{}
					3{}v{entry} = v{link};n{}
					2{}}n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Eintrag freigegeben wird, so werden
						auch alle verlinkten Einträge freigegeben
					</li><li>
						Referenzierte Makros werden nicht mit
						freigegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{includes}n{}
					1{}t{struct MacroEntry};n{}
					1{}k{void} f{freeMacroEntry}(n{}
					2{}t{struct MacroEntry *}v{entry}n{}
					1{});n{}
					x{includes}n{}
					n{}
					a{free macros entries}n{}
					1{}f{freeMacroEntry}(v{macro}-&gt;v{firstEntry});n{}
					x{free macros entries}
				</code></div>
				<ul class="notes">
					<li>
						Wenn ein Makro freigegeben wird, so werden auch
						die anhängenden Einträge freigegeben
					</li><li>
						Damit die Funktion im
						<code class="fn">freeMacro</code> sichtbar ist,
						wird sie in der Include-Sektion definiert
					</li>
				</ul>
			</div>
		</div>
		<h2>Auf Attribute zugreifen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}k{int} f{getMacroEntryValueSize}(n{}
					2{}t{struct MacroEntry *}v{entry}n{}
					1{}) {n{}
					2{}k{if} (! v{entry}) {n{}
					3{}k{return} n{0};n{}
					2{}}n{}
					2{}k{return} v{entry}-&gt;v{valueEnd} -n{}
  					3{}v{entry}-&gt;v{value};n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Liefert die Anzahl der enthaltenen Bytes
					</li>
				</ul>
			</div>
		</div>
		<h2>Unit Tests</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocEmptyMacroEntry}();n{}
					n{}
					2{}f{ASSERT}(v{entry});n{}
					2{}f{ASSERT}(! v{entry}-&gt;v{link});n{}
					2{}f{ASSERT}(! v{entry}-&gt;v{macro});n{}
					n{}
					2{}f{freeMacroEntry}(v{entry});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Ein leerer Eintrag hat keinen Nachfolger
					</li><li>
						Und kein Makro
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocEmptyMacroEntry}();n{}
					n{}
					2{}f{ASSERT}(v{entry});n{}
					2{}f{ASSERT}(n{}
					3{}f{getMacroEntryValueSize}(n{}
					4{}v{entry}) == n{0);}n{}
					n{}
					2{}f{freeMacroEntry}(v{entry});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Ein leerer Eintrag hat keine Bytes
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct MacroEntry *}n{}
					1{}f{allocTestMacroEntry}(n{}
					2{}t{const char *}v{value}n{}
					1{}) {n{}
					2{}t{const char *}v{end} = v{value} +n{}
					3{}f{strlen}(v{value});n{}
					n{}
					2{}k{return} f{allocMacroEntry}(n{}
					3{}k{NULL}, v{value}, v{end}n{}
					2{});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Der Test-Konstruktor bekommt eine
						Null-terminierte Zeichenkette als Argument
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocTestMacroEntry}(s{"abc"});n{}
					n{}
					2{}f{ASSERT}(v{entry});n{}
					2{}f{ASSERT}(n{}
					3{}f{getMacroEntryValueSize}(n{}
					4{}v{entry}) == n{3);}n{}
					n{}
					2{}f{freeMacroEntry}(v{entry});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag hat die korrekte Anzahl an Bytes
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocTestMacroEntry}(s{"abc"});n{}
					n{}
					2{}f{ASSERT}(v{entry});n{}
					2{}f{ASSERT}(n{}
					3{}f{memcmp}(v{entry}-&gt;v{value},n{}
					4{}s{"abc"}, n{3}) == n{0);}n{}
					n{}
					2{}f{freeMacroEntry}(v{entry});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Die Bytes eines Eintrags stimmen überein
					</li>
				</ul>
			</div>
		</div>
		<h2>Einträge zu Makros hinzufügen</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{void} f{addEntryToMacro}(n{}
					2{}t{struct Macro *}v{macro},n{}
					2{}t{struct MacroEntry *}v{entry}n{}
					1{}) {n{}
					2{}e{assert add entry};n{}
					2{}k{if} (v{macro}-&gt;v{firstEntry}) {n{}
					3{}e{append entry};n{}
					2{}} k{else} {n{}
					3{}e{set first entry};n{}
					2{}}n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Ein Eintrag wird entweder an das Ende der Liste
						der Einträge angehängt
					</li><li>
						Oder als neuer Kopf der Liste gesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{assert add entry}n{}
					1{}f{ASSERT}(v{macro});n{}
					1{}f{ASSERT}(v{entry});n{}
					1{}f{ASSERT}(! v{entry}-&gt;v{link});n{}
					x{assert add entry}
				</code></div>
				<ul class="notes">
					<li>
						Makro darf nicht
						<code class="keyword">NULL</code> sein
					</li><li>
						Eintrag darf nicht
						<code class="keyword">NULL</code> sein
					</li><li>
						Eintrag darf noch nicht in einer anderen Liste
						hängen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{append entry}n{}
					1{}v{macro}-&gt;v{lastEntry}-&gt;v{link} = v{entry};n{}
					1{}v{macro}-&gt;v{lastEntry} = v{entry};n{}
					x{append entry}
				</code></div>
				<ul class="notes">
					<li>
						Da es schon Einträge gibt, muss es bereits einen
						letzten geben
					</li><li>
						Dessen neuer Nachfolger ist der neue Eintrag
					</li><li>
						Der neue Eintrag wird zum neuen letzten Eintrag
					</li><li>
						Der Nachfolger von
						<code class="var">entry</code> ist bereits
						<code class="keyword">NULL</code>
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{set first entry}n{}
					1{}v{macro}-&gt;v{firstEntry} = v{entry};n{}
					1{}v{macro}-&gt;v{lastEntry} = v{entry};n{}
					x{set first entry}
				</code></div>
				<ul class="notes">
					<li>
						Der erste Eintrag wird auch als letzter Eintrag
						gesetzt
					</li><li>
						Der Nachfolger von
						<code class="var">entry</code> ist bereits
						<code class="keyword">NULL</code>
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct Macro *}v{macro} =n{}
					3{}f{allocTestMacro}(s{""});n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocEmptyMacroEntry}();n{}
					2{}f{addEntryToMacro}(v{macro}, v{entry});n{}

					2{}f{ASSERT}(n{}
					3{}v{macro}-&gt;v{firstEntry} == v{entry}n{}
					2{});n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Der erste Eintrag im Makro wird gesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct Macro *}v{macro} =n{}
					3{}f{allocTestMacro}(s{""});n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocEmptyMacroEntry}();n{}
					2{}f{addEntryToMacro}(v{macro}, v{entry});n{}

					2{}f{ASSERT}(n{}
					3{}v{macro}-&gt;v{lastEntry} == v{entry}n{}
					2{});n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Der letzte Eintrag im Makro wird gesetzt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct Macro *}v{macro} = k{NULL};n{}
					2{}t{struct MacroEntry *}v{first};n{}
					2{}t{struct MacroEntry *}v{second};n{}
					2{}e{add two entries};n{}
					2{}e{check first of 2};n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Zwei Einträge werden an ein Makro angehängt
					</li><li>
						Der erste Eintrag muss gesetzt bleiben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{add two entries}n{}
					1{}v{macro} = f{allocTestMacro}(s{""});n{}
					1{}v{first} = f{allocEmptyMacroEntry}();n{}
					1{}v{second} = f{allocEmptyMacroEntry}();n{}
					n{}
					1{}f{addEntryToMacro}(v{macro}, v{first});n{}
					1{}f{addEntryToMacro}(v{macro}, v{second});n{}

					x{add two entries}n{}
					n{}
					a{check first of 2}n{}
					1{}f{ASSERT}(v{macro}-&gt;v{firstEntry} == v{first});n{}
					e{check first of 2}
				</code></div>
				<ul class="notes">
					<li>
						Zwei Einträge werden an ein Makro angehängt
					</li><li>
						Der erste Eintrag muss gesetzt bleiben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct Macro *}v{macro} = k{NULL};n{}
					2{}t{struct MacroEntry *}v{first};n{}
					2{}t{struct MacroEntry *}v{second};n{}
					2{}e{add two entries};n{}
					2{}f{ASSERT}(n{}
					3{}v{macro}-&gt;v{lastEntry} == v{second}n{}
					2{});n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Zwei Einträge werden an ein Makro angehängt
					</li><li>
						Der letzte Eintrag muss gesetzt werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{void} f{addBytesToMacro}(n{}
					2{}t{struct Macro *}v{macro},n{}
					2{}t{const char *}v{value},n{}
					2{}t{const char *}v{valueEnd}n{}
					1{}) {n{}
					2{}t{struct MacroEntry *}v{entry} =n{}
					3{}f{allocMacroEntry}(n{}
					4{}k{NULL}, v{value}, v{valueEnd}n{}
					3{});n{}
					2{}f{addEntryToMacro}(v{macro}, v{entry});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Für die Daten wird ein neuer Eintrag angelegt
					</li><li>
						Dieser wird an das Makro angehängt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}e{define cycle check}n{}
					1{}t{void} f{addMacroToMacro}(n{}
					2{}t{struct Macro *}v{macro},n{}
					2{}t{struct Macro *}v{child}n{}
					1{}) {n{}
					2{}f{ASSERT}(v{macro});n{}
					2{}f{ASSERT}(v{child});n{}
					2{}e{avoid macro cycles};n{}
					2{}e{reuse last entry};n{}
					2{}e{add macro entry});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Bevor ein Makro hinzugefügt werden kann, muss
						sichergestellt werden, dass kein Zykel entsteht
					</li><li>
						Ein Zykel liegt vor, wenn
						<code class="var">macro</code> gleich
						<code class="var">child</code> ist
					</li><li>
						Oder bereits direkt oder indirekt zu
						<code class="var">child</code> hinzugefügt wurde
					</li><li>
						Falls der letzte Eintrag noch kein Makro hat,
						wird dieser Eintrag verwendet
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{reuse last entry}n{}
					1{}k{if} (v{macro}-&gt;v{firstEntry} &amp;&amp;n{}
					2{}! v{macro}-&gt;v{lastEntry}-&gt;v{macro}n{}
					1{}) {n{}
					2{}v{macro}-&gt;v{lastEntry}-&gt;v{macro} = v{child};n{}
					2{}k{return};n{}
					1{}}n{}
					x{reuse last entry}
				</code></div>
				<ul class="notes">
					<li>
						Wenn das Makro-Attribut im letzten Eintrag noch
						nicht benutzt wird, kann dieses verwendet werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{add macro entry}n{}
					1{}t{struct MacroEntry *}v{entry} =n{}
					2{}f{allocMacroEntry}(n{}
					3{}v{child}, k{NULL}, k{NULL}n{}
					2{});n{}
					1{}f{addEntryToMacro}(v{macro}, v{entry});n{}
					x{add macro entry}
				</code></div>
				<ul class="notes">
					<li>
						Sonst muss ein neuer Eintrag mit dem Makro
						angelegt werden
					</li>
				</ul>
			</div>
		</div>
		<h2>Makros serialisieren</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}k{typedef} t{void} t{Consumer}(n{}
					2{}t{const char *}v{begin},n{}
					2{}t{const char *}v{end},n{}
					2{}t{void *}v{context}n{}
					1{});n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						t{Callback} Instanzen
						werden als Callbacks verwendet, um Byte-Folgen
						zu konsumieren
					</li><li>
						Ein freier Kontext-Parameter wird mit übergeben
					</li><li>
						Damit lassen sich objekt-ähnliche Strukturen
						realisieren
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{void} f{serializeMacro}(n{}
  					2{}t{struct Macro *}v{macro,}n{}
  					2{}t{Consumer} v{consumer},n{}
  					2{}t{void *} v{context}n{}
					1{}) {n{}
					2{}f{ASSERT}(v{macro});n{}
					2{}f{ASSERT}(v{consumer});n{}
					2{}e{iterate entries};n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Jeder Eintrag wird nacheinander bearbeitet
					</li><li>
						Makros in Einträgen werden rekursiv ausgegeben
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{iterate entries}n{}
  					1{}t{struct MacroEntry *}v{entry} =n{}
  					2{}v{macro}-&gt;v{firstEntry};n{}
					1{}k{for} (; v{entry}; v{entry} = v{entry}-&gt;v{link}) {n{}
					2{}e{serialize bytes};n{}
					2{}k{if} (v{entry}-&gt;v{macro}) {n{}
					3{}f{serializeMacro}(v{entry}-&gt;v{macro},n{}
 					4{}v{consumer}, v{context}n{}
					3{});n{}
					2{}}n{}
					1{}}n{}
					x{iterate entries}
				</code></div>
				<ul class="notes">
					<li>
						Für jeden Eintrag werden zuerst die Bytes
						ausgegeben
					</li><li>
						Dann wird rekursiv das Makro ausgegeben, falls
						vorhanden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{serialize bytes}n{}
					1{}k{if} (f{getMacroEntryValueSize}(v{entry})) {n{}
					2{}v{consumer}(n{}
	   				3{}v{entry}-&gt;v{value},n{}
					3{}v{entry}-&gt;v{valueEnd},n{}
					3{}v{context}n{}
					2{});n{}
					1{}}n{}
					x{serialize bytes}
				</code></div>
				<ul class="notes">
					<li>
						Wenn es Bytes in dem Eintrag gibt, wird der
						<code class="var">consumer</code> mit ihnen
						aufgerufen
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct TestConsumerContext} {n{}
					2{}t{char *}v{current};n{}
					2{}t{const char *}v{end};n{}
					2{}t{char }v{buffer}t{[]};n{}
					1{}};n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Zum Testen gibt es einen speziellen
						<code class="type">Consumer</code>.
					</li><li>
						Dessen Kontext enthält einen Buffer.
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{void} f{testConsumer} (n{}
					2{}t{const char *}v{begin},n{}
					2{}t{const char *}v{end},n{}
					2{}t{void *}v{context}n{}
					1{}) {n{}
					2{}f{ASSERT}(v{begin});n{}
					2{}f{ASSERT}(v{begin} &lt;= v{end});n{}
					2{}f{ASSERT}(v{context});n{}
					2{}e{add to test consumer};n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Der Test Consumer fügt die übergegebenen Daten im
						Buffer des Kontexts ein
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{add to test consumer}n{}
					1{}t{struct TestConsumerContext *}v{ctx} =n{}
					2{}v{context};n{}
					1{}t{int} v{length} = v{end} - v{begin};n{}
					1{}f{ASSERT}(n{}
					2{}v{ctx}-&gt;v{current} + v{length} &lt;= v{ctx}-&gt;v{end}n{}
					1{});n{}
					1{}f{memcpy}(v{ctx}-&gt;v{current}, v{begin}, v{length});n{}
					1{}v{ctx}-&gt;v{current} += v{length};n{}
					x{add to test consumer}
				</code></div>
				<ul class="notes">
					<li>
						Wenn genügend Platz im Buffer ist, werden die
						Bytes hineinkopiert
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{struct TestConsumerContext *}n{}
					1{}f{allocTestConsumerContext}(t{int} v{size}) {n{}
					2{}f{ASSERT}(v{size} &gt;= 0);n{}
					2{}t{struct TestConsumerContext *}n{}
					2{}v{context} = f{malloc}(v{size} + k{sizeof}(n{}
					3{}t{struct TestConsumerContext}));n{}
					2{}f{ASSERT}(v{context});n{}
					2{}e{init test consumer};n{}
					2{}k{return} v{context};n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Der Buffer wird direkt in der Struktur angelegt
					</li><li>
						Die Strukturen können nur auf dem Heap angelegt
						werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{init test consumer}n{}
					1{}v{context}-&gt;v{current} =
					v{context}-&gt;v{buffer};n{}
					1{}v{context}-&gt;v{end} =n{}
					2{}v{context}-&gt;v{buffer} + v{size};n{}
					x{init test consumer}
				</code></div>
				<ul class="notes">
					<li>
						Zum schnellen Zugriff wird ein Zeiger auf das
						aktuelle Ende und das Ende des Buffers
						abgelegt
					</li><li>
						Die Größe des Buffers kann beim Einfügen nicht
						überschritten werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{void} f{testMacro}(t{struct Macro *}n{}
					2{}v{macro}, t{const char *}v{expected}n{}
					1{}) {n{}
					2{}t{int} v{size} = f{strlen}(v{expected});n{}
					2{}t{struct TestConsumerContext *}n{}
					2{}v{context} =n{}
					3{}f{allocTestConsumerContext}(n{}
					4{}v{size});n{}
					2{}e{serialize test macro};n{}
					2{}f{free}(v{context});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Diese Hilfsfunktion prüft ob die Serialisierung
						eines Makros der Erwartung entspricht
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{serialize test macro}n{}
					1{}f{serializeMacro}(v{macro},n{}
					2{}v{testConsumer}, v{context});n{}
					1{}f{ASSERT}(v{context}-&gt;v{current} -n{}
					2{}v{context}-&gt;v{buffer} == v{size});n{}
					1{}f{ASSERT}(f{memcmp}(v{expected},n{}
					2{}v{context}-&gt;v{buffer}, v{size}) == 0);n{}
					x{serialize test macro}
				</code></div>
				<ul class="notes">
					<li>
						Serialisiert das Makro
					</li><li>
						Der Buffer muss die erwarteten Werte enthalten
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define macro}n{}
					1{}t{void} f{addStringToMacro}(n{}
					2{}t{struct Macro *}v{macro},n{}
					2{}t{const char *}v{str}n{}
					1{}) {n{}
					2{}t{int} v{size} = f{strlen}(v{str});n{}
					2{}f{addBytesToMacro}(n{}
					3{}v{macro}, v{str}, v{str} + v{size}n{}
					2{});n{}
					1{}}n{}
					x{define macro}
				</code></div>
				<ul class="notes">
					<li>
						Zu Testzwecken kann eine Null-terminierte
						Zeichenkette hinzugefügt werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests}n{}
					1{}{n{}
					2{}t{struct Macro *}v{macro} =n{}
					3{}f{allocTestMacro}(s{""});n{}
					2{}f{addStringToMacro}(v{macro}, s{"abc"});n{}
					2{}f{addStringToMacro}(v{macro}, s{"def"});n{}
					2{}f{testMacro}(v{macro}, s{"abcdef"});n{}
					2{}f{freeMacro}(v{macro});n{}
					1{}}n{}
					x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Prüft, ob zwei Strings richtig serialisiert
						werden
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{macro unit tests} {n{}
					1{}t{struct Macro *}v{a} =n{}
					2{}f{allocTestMacro}(s{""});n{}
					1{}t{struct Macro *}v{b} =n{}
					2{}f{allocTestMacro}(s{""});n{}
					1{}f{addStringToMacro}(v{a}, s{"abc"});n{}
					1{}f{addMacroToMacro}(v{b}, v{a});n{}
					1{}f{addStringToMacro}(v{b}, s{"def"});n{}
					1{}f{addMacroToMacro}(v{b}, v{a});n{}
					1{}f{testMacro}(v{b}, s{"abcdefabc"});n{}
					1{}f{freeMacro}(v{a}); f{freeMacro}(v{b});n{}
					} x{macro unit tests}
				</code></div>
				<ul class="notes">
					<li>
						Prüft, ob Makros expandiert werden
					</li>
				</ul>
			</div>
		</div>
		<h2>Zykel im Makro-Graph finden</h2>
		<div class="slides">
			<div class="row">
				<div class="slide code"><code>
					a{includes}n{}
					1{}i{stdbool.h}n{}
					x{includes}n{}
				</code></div>
				<ul class="notes">
					<li>
						Boolesche Datenwerte werden benötigt
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{define cycle check}n{}
					1{}t{bool} f{isMacroInMacro}(n{}
					2{}t{struct Macro *}v{needle},n{}
					2{}t{struct Macro *}v{haystack}n{}
					1{}) {n{}
					2{}f{ASSERT}(v{needle});n{}
					2{}f{ASSERT}(v{haystack});n{}
					2{}e{check cycle macro};n{}
					2{}e{check cycle entries};n{}
					2{}k{return} k{false};n{}
					1{}}n{}
					x{define cycle check}
				</code></div>
				<ul class="notes">
					<li>
						Wenn das Makro das gesuchte ist, dann wurde ein
						Zykel gefunden
					</li><li>
						Danach wird über alle Einträge gesucht
					</li><li>
						Wenn das Makro dort nicht gefunden wurde, dann
						ist es nicht enthalten
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{avoid macro cycles}n{}
					1{}f{ASSERT}(! f{isMacroInMacro}(n{}
					2{}v{macro}, v{child}n{}
					1{}));n{}
					x{avoid macro cycles}
				</code></div>
				<ul class="notes">
					<li>
						Ein Makro darf nur hinzugefügt werden, wenn es
						den Container nict bereits enthält
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{check cycle macro}n{}
					1{}k{if} (v{needle} == v{haystack}) {n{}
					2{}k{return} k{true};n{}
					1{}}n{}
					x{check cycle macro}
				</code></div>
				<ul class="notes">
					<li>
						Wenn der Container selbst das gesuchte Makro ist,
						liefert die Funktion
						<code class="keyword">true</code> zurück
					</li>
				</ul>
			</div>
			<div class="row">
				<div class="slide code"><code>
					a{check cycle entries}n{}
					1{}t{struct MacroEntry *}v{entry} =n{}
					2{}v{haystack}-&gt;v{firstEntry};n{}
					1{}k{for} (; v{entry}; v{entry} = v{entry}->v{link}) {n{}
					2{}k{if} (! v{entry}-&gt;v{macro}) { k{continue}; }n{}
					2{}k{if} (f{isMacroInMacro}(n{}
					3{}v{needle}, v{entry}-&gt;v{macro}n{}
					2{})) {n{}
					3{}k{return} k{true};n{}
					2{}}n{}
					1{}}n{}
					x{check cycle entries}
				</code></div>
				<ul class="notes">
					<li>
						Alle Makros in den Einträgen werden rekursiv
						untersucht
					</li><li>
						Damit wird der ganze Graph durchsucht
					</li>
				</ul>
			</div>
		</div>
	</body>
</html>
