<html lang="de">
		<head>
			<meta charset="utf-8" />
			<title>Ausgaben konsumieren</title>
			<link rel="stylesheet" type="text/css"
				href="slides/slides.css" />
		</head>
	<body>
		<div class="slides">
			<div>
				<div>
					<h1>Ausgaben konsumieren</h1>
				</div>
				<ul>
					<li>
						Diese Datei beschreibt eine generische Funktion
						um zeichenweise Ausgaben zu konsumieren
					</li><li>
						Damit sind leichtere Tests möglich, da nicht so
						viele temporären Dateien angelegt werden müssen
					</li>
				</ul>
			</div>
				<div>
					<div><code>
						a{global elements}b{}
						1{}e{expand consumer}b{}
						x{global elements}
					</code></div>
					<ul>
						<li>
							Diese Datei stellt globale Funktionen bereit
							um ein abstraktes Interface zur Verfügung
							zu stellen
						</li>
					</ul>
				</div><div>
					<div><code>
						a{expand consumer}b{}
						1{}t{struct Consumer} {b{}
						2{}t{int} (* f{put})(b{}
						3{}t{struct Consumer *}v{consumer}, t{int} v{ch}b{}
						2{});b{}
						1{}};b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Ein Consumer besteht nur aus einer Funktion,
							die ein Zeichen entgegennimmt
						</li><li>
							Der Consumer ist trotzdem als
							<code>struct</code> ausgeführt, damit nicht
							immer ein Paar aus Funktionszeiger und
							Kontext durchgereicht werden muss
						</li><li>
							Das Ende wird signalisiert durch das Senden
							von <code>EOF</code>
						</li>
					</ul>
				</div><div>
					<div><code>
						a{expand consumer}b{}
						1{}t{void} f{putToConsumer}(b{}
						2{}t{struct Consumer *}v{c}, t{int} v{ch}b{}
						1{}) {b{}
						2{}f{ASSERT}(v{c}); f{ASSERT}(v{c}-&gt;v{put});b{}
						2{}v{c}-&gt;v{put}(v{c}, v{ch});b{}
						1{}}b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Diese Funktion vereinfacht den Aufruf des
							Consumers.
						</li>
					</ul>
				</div>
			<div>
				<div>
					<h1>Beispiel: FileConsumer</h1>
				</div>
				<ul>
					<li>
						Ein einfacher Consumer schreibt die Daten
						in eine Datei
					</li>
				</ul>
			</div>
				<div>
					<div><code>
						a{expand consumer}b{}
						1{}t{struct FileConsumer} {b{}
						2{}t{struct Consumer} v{consumer};b{}
						2{}t{FILE *} v{file};b{}
						1{}};b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Neben der Consumer-Struktur muss die Datei
							bekannt sein
						</li>
					</ul>
				</div><div>
					<div><code>
						a{expand consumer}b{}
						1{}t{int} f{consumeInFile}(b{}
						2{}t{struct Consumer *}v{c}, t{int} v{ch}b{}
						1{}) {b{}
						2{}t{struct FileConsumer *}v{fc} = (t{void *}) v{c};b{}
						2{}f{ASSERT}(v{fc}); f{ASSERT}(v{fc}-&gt;v{file});b{}
						2{}k{if} (v{ch} != k{EOF}) {b{}
						3{}v{ch} = f{fputc}(v{ch}, v{fc}-&gt;v{file});b{}
						2{}} k{else} {b{}
						3{}f{fclose}(v{fc}-&gt;v{file});b{}
						3{}v{fc}-&gt;v{file} = k{NULL};b{}
						2{}}b{}
						2{}k{return} v{ch};b{}
						1{}}b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Der Consumer wird auf den richtigen Typ
							gecastet
						</li><li>
							Das setzt vorraus, dass er korrekt
							initialisiert wurde
						</li><li>
							Wenn nicht das Ende erreicht ist, wird das
							Zeichen in die Datei geschrieben
						</li><li>
							Andernfalls wird die Datei geschlossen
						</li>
					</ul>
				</div><div>
					<div><code>
						a{expand consumer}b{}
						1{}t{void} f{setupFileConsumer}(b{}
						2{}t{struct FileConsumer *}v{fc}, t{FILE *}v{f}b{}
						1{}) {b{}
						2{}f{ASSERT}(v{fc}); f{ASSERT}(v{f});b{}
						2{}v{fc}-&gt;v{file} = v{f};b{}
						2{}v{fc}-&gt;v{consumer}.v{put} = f{consumeInFile};b{}
						1{}}b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Die Struktur wird mit einer offenen Datei
							initialisiert
						</li>
					</ul>
				</div>
			<div>
				<div>
					<h1>Beispiel: BufferConsumer</h1>
				</div>
				<ul>
					<li>
						Dieser Consumer speichert in einen Buffer
					</li><li>
						Er ist praktisch zum Unit-Testen
					</li>
				</ul>
			</div>
				<div>
					<div><code>
						a{expand consumer}b{}
						1{}t{struct BufferConsumer} {b{}
						2{}t{struct Consumer} v{consumer};b{}
						2{}t{struct Buffer} v{buffer};b{}
						1{}};b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Neben der Consumer-Struktur muss Platz für
							den Buffer vorhanden sein
						</li>
					</ul>
				</div><div>
					<div><code>
						a{expand consumer}b{}
						1{}t{int} f{consumeInBuffer}(b{}
						2{}t{struct Consumer *}v{c}, t{int} v{ch}b{}
						1{}) {b{}
						2{}t{struct BufferConsumer *}v{bc} = (t{void *}) v{c};b{}
						2{}f{ASSERT}(v{bc});b{}
						2{}t{int} v{cr} = v{ch} != k{EOF} ? v{ch} : s{'\0'};b{}
						2{}f{addToBuffer}(&amp;v{bc}-&gt;v{buffer}, v{cr});b{}
						2{}k{return} v{ch};b{}
						1{}}b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Der Consumer wird auf den richtigen Typ
							gecastet
						</li><li>
							Das setzt vorraus, dass er korrekt
							initialisiert wurde
						</li><li>
							Wenn nicht das Ende erreicht ist, wird das
							Zeichen in den Buffer geschrieben
						</li><li>
							Wenn das Ende erreicht ist, wird ein
							Nullbyte geschrieben, um den String zu
							terminieren
						</li>
					</ul>
				</div><div>
					<div><code>
						a{expand consumer}b{}
						1{}t{void} f{setupBufferConsumer}(b{}
						2{}t{struct BufferConsumer *}v{bc}b{}
						1{}) {b{}
						2{}f{ASSERT}(v{bc});b{}
						2{}f{memset}(b{}
						3{}&amp;v{bc}-&gt;v{buffer}, 0,b{}
						3{}f{sizeof}(v{bc}-&gt;v{buffer})b{}
						2{});b{}
						2{}v{bc}-&gt;v{consumer}.v{put} = f{consumeInBuffer};b{}
						1{}}b{}
						x{expand consumer}
					</code></div>
					<ul>
						<li>
							Die Struktur wird mit einem leeren Buffer
							initialisiert
						</li>
					</ul>
				</div>
			<div>
				<div>
					<h1>Unit Tests</h1>
				</div>
				<ul>
					<li>
						Testet den BufferConsumer als proof of concept
					</li>
				</ul>
			</div>
				<div>
					<div><code>
						a{perform unit-tests} {b{}
						1{}e{consumer unit-tests}b{}
						} x{perform unit-tests}
					</code></div>
					<ul>
						<li>
							Die Unit-Tests werden in einem eigenen Makro
							gesammelt
						</li>
					</ul>
				</div><div>
					<div><code>
						a{consumer unit-tests} {b{}
						1{}t{struct BufferConsumer} v{bc};b{}
						1{}f{setupBufferConsumer}(&amp;v{bc});b{}
						1{}t{struct Consumer *}v{c} = &amp;v{bc}.v{consumer};b{}
						1{}f{putToConsumer}(v{c}, s{'a'});b{}
						1{}f{putToConsumer}(v{c}, s{'b'});b{}
						1{}f{putToConsumer}(v{c}, k{EOF});b{}
						1{}f{ASSERT}(b{}
						2{}f{strcmp}(s{"ab"}, v{bc}.v{buffer}.v{buffer}) == 0b{}
						1{});b{}
						} x{consumer unit-tests}
					</code></div>
					<ul>
						<li>
							Zwei Zeichen werden in den Buffer eingefügt
						</li>
					</ul>
				</div>
		</div>
	</body>
</html>
