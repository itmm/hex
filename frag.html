<!doctype html>
<html lang="de"l>
<head>
<meta charset="utf-8">
<title>Fragmente</title><link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>Fragmente</h1>
<div class="slides">
<div><div>
<h1>Fragmente</h1>
</div>
<ul><li>
 Fragmente bilden einen gerichteten azyklischen Graph</li><li>
 Die Infix-Traversierung dieses Graphen bildet die generierten
  Source-Code Dateien</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">global elements)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">define frag)</span></span>;<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 Fragmente sind global sichtbare Strukturen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry</span>;<br/>

<br/>
<span class="in1"></span>
<span class="type">struct Frag</span> {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">firstEntry</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">lastEntry</span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">expands</span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">multiples</span>;<br/>
<span class="in2"></span>
<span class="type">char </span><span class="var">name</span><span class="type">[]</span>;<br/>
<span class="in1"></span>
};<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Fragmente erden in einfach verketteten Listen gesammelt</li><li>
 Genauso werden die Einträge eines Fragments in einer einfach
  verketteten Liste organisiert</li><li>
 Um schnell Einträge einfügen zu können, gibt es auch einen Verweis auf
  das letzte Element</li><li>
 Je nach Namen werden für ein Fragment unterschiedlich viele Bytes im
  Heap angefordert</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">includes)</span></span><br/>
<span class="in1"></span>
#include &lt;stdlib.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>
</code>
</div>
<ul><li>
 <code>stdlib.h</code> wird für die Definition von <code><span class="keyword">NULL</span></code> benötigt</li></ul></div>
</div>
<h1>Neues Fragment anlegen</h1>
<div class="slides">
<div><div>
<h1>Neues Fragment anlegen</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">allocFrag</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">nameBegin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">nameEnd</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">allocate macro on heap)</span></span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">firstEntry</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">expands</span> = 0;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">multiples</span> = 0;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">copy macro name)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">result</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Die Zeiger werden mit <code><span class="keyword">NULL</span></code> initializiert</li><li>
 <code><span class="var">lastEntry</span></code> wird erst initialisiert, wenn <code><span class="var">firstEntry</span></code> gesetzt
  wird</li><li>
 Der Name wird über zwei Zeiger übergeben, muss also nicht mit einem
  Null-Byte terminiert sein</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">define logging)</span></span><br/>
<span class="in1"></span>
#define ASSERT(<span class="var">COND</span>, ...) \<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! (<span class="var">COND</span>)) { \<br/>
<span class="in3"></span>
<span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>
<span class="in4"></span>
<span class="str">"%s:%d"</span>, \<br/>
<span class="in4"></span>
__FILE__, __LINE__); \<br/>
<span class="in3"></span>
<span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>
<span class="in4"></span>
<span class="str">" FAILED: "</span> __VA_ARGS__); \<br/>
<span class="in3"></span>
<span class="fn">fprintf</span>(<span class="var">stderr</span>, <span class="str">"\n"</span>); \<br/>
<span class="in3"></span>
<span class="fn">exit</span>(<span class="var">EXIT_FAILURE</span>); \<br/>
<span class="in2"></span>
}<br/>

<span class="end">@end(<span class="name">define logging)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn Bedingung falsch ist, wird Fehlermeldung ausgegeben</li><li>
 Und das Programm beendet</li><li>
 Datei und Zeile des Tests wird ausgegeben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">allocate macro on heap)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">nameBegin</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">nameBegin</span> &lt;= <span class="var">nameEnd</span>);<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">nameLength</span> =<br/>
<span class="in2"></span>
<span class="var">nameEnd</span> - <span class="var">nameBegin</span>;<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">macroSize</span> = <span class="keyword">sizeof</span>(<span class="type">struct Frag</span>)<br/>
<span class="in2"></span>
+ <span class="var">nameLength</span> + 1;<br/>
<span class="in1"></span>
<span class="var">result</span> = <span class="var">malloc</span>(<span class="var">macroSize</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>

<span class="end">@end(<span class="name">allocate macro on heap)</span></span><br/>
</code>
</div>
<ul><li>
 Die Zeiger werden mit <code><span class="keyword">NULL</span></code> initializiert</li><li>
 <code><span class="var">lastEntry</span></code> wird erst initialisiert, wenn <code><span class="var">firstEntry</span></code> gesetzt
  wird</li><li>
 Der Name wird über zwei Zeiger übergeben, muss also nicht mit einem
  Null-Byte terminiert sein</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">includes)</span></span><br/>
<span class="in1"></span>
#include &lt;string.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>

<br/>

<span class="add">@def(<span class="name">copy macro name)</span></span><br/>
<span class="in1"></span>
<span class="fn">memcpy</span>(<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">name</span>, <span class="var">nameBegin</span>,<br/>
<span class="in2"></span>
<span class="var">nameLength</span><br/>
<span class="in1"></span>
);<br/>
<span class="in1"></span>
<span class="var">result</span>-&gt;<span class="var">name</span>[<span class="var">nameLength</span>] = <span class="str">'\0'</span>;<br/>

<span class="end">@end(<span class="name">copy macro name)</span></span><br/>
</code>
</div>
<ul><li>
 Der Name wird direkt in die das Makro kopiert</li><li>
 Der Name wird mit einem Null-Byte abgeschlossen</li></ul></div>
</div>
<h1>Makros freigeben</h1>
<div class="slides">
<div><div>
<h1>Makros freigeben</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">freeFragEntries</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">free macros entries)</span></span>;<br/>
<span class="in3"></span>
<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> = <span class="keyword">NULL</span>;<br/>
<span class="in3"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">freeMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">while</span> (<span class="var">macro</span>) {<br/>
<span class="in3"></span>
<span class="type">struct Frag *</span><span class="var">link</span> =<br/>
<span class="in4"></span>
<span class="var">macro</span>-&gt;<span class="var">link</span>;<br/>
<span class="in3"></span>
freeFragEntries(macro);<br/>
<span class="in3"></span>
<span class="fn">free</span>(<span class="var">macro</span>);<br/>
<span class="in3"></span>
<span class="var">macro</span> = <span class="var">link</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Mit einem Makro werden auch alle verketteten Makros freigegeben</li><li>
 Die Freigabe der einzelnen Einträge wird später definiert
		</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">perform unit-tests)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">macro unit tests)</span></span>;<br/>

<span class="end">@end(<span class="name">perform unit-tests)</span></span><br/>

<br/>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">allocTestMacro</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">name</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="fn">allocFrag</span>(<br/>
<span class="in3"></span>
<span class="var">name</span>, <span class="var">name</span> + <span class="fn">strlen</span>(<span class="var">name</span>)<br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Für Unit-Tests gibt es einen einfacheren Konstruktor</li><li>
 Die Länge des Namens wird anhand des Null-Bytes berechnet</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="keyword">void</span> <span class="fn">testMacroName</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">name</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacro</span>(<span class="var">name</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">strcmp</span>(<span class="var">macro</span>-&gt;<span class="var">name</span>, <span class="var">name</span>) == 0<br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 <code><span class="fn">testMacroName</span></code> prüft, ob der Name korrekt in ein Makro kopiert
  wurde</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
<span class="fn">testMacroName</span>(<span class="str">"abc"</span>);<br/>
<span class="in1"></span>
<span class="fn">testMacroName</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="fn">testMacroName</span>(<span class="str">"A c"</span>);<br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacro</span>(<span class="str">"ab"</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">macro</span>-&gt;<span class="var">link</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">macro</span>-&gt;<span class="var">firstEntry</span>);<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Zum einen wird getestet, ob die Namen korrekt kopiert werden</li><li>
 Zum anderen wird sichergestellt, dass die Verweise <code><span class="keyword">NULL</span></code> sind</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">bool</span> <span class="fn">isPopulatedMacro</span>(<br/>
<span class="in2"></span>
<span class="type">const struct Frag *</span><span class="var">macro</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
return macro &amp;&amp; macro-&gt;firstEntry;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
</div>
</div>
<h1>Makro Einträge</h1>
<div class="slides">
<div><div>
<h1>Makro Einträge</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry</span> {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span>;<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueEnd</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">additional entry attributes)</span></span>;<br/>
<span class="in2"></span>
<span class="type">char </span><span class="var">value</span><span class="type">[]</span>;<br/>
<span class="in1"></span>
};<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Eintrag kann entweder auf ein anderes Makro verweisen (wenn dieses
  an der aktuellen Stelle expandiert werden soll)</li><li>
 Oder er enthält Bytes, die beim Expandieren direkt expandiert werden</li><li>
 Die Länge des Byte-Arrays wird über einen Zeiger angezeigt (damit auch
  Null-Bytes verwendet werden können)</li><li>
 Wenn ein Eintrag sowohl Daten als auch ein Makro enthält, so wird
  zuerst der Text ausgegeben
		</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="fn">allocMacroEntry</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueBegin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueEnd</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">allocate entry on heap)</span></span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">copy entry values)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">result</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Wie beim Macro werden die <code><span class="var">link</span></code> Verweise auf <code><span class="keyword">NULL</span></code>
  initialisiert</li><li>
 Sowohl <code><span class="var">macro</span></code> als auch <code><span class="var">valueBegin</span></code> sind optional</li><li>
 Die Größe des Eintrags hängt von der Größe der Bytes ab, die kopiert
  werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">allocate entry on heap)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">valueLength</span> = 0;<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">valueBegin</span> &lt;= <span class="var">valueEnd</span>);<br/>
<span class="in2"></span>
<span class="var">valueLength</span> =<br/>
<span class="in3"></span>
<span class="var">valueEnd</span> - <span class="var">valueBegin</span>;<br/>
<span class="in1"></span>
}<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">entrySize</span> = <span class="var">valueLength</span> +<br/>
<span class="in2"></span>
<span class="keyword">sizeof</span>(<span class="type">struct FragEntry</span>);<br/>
<span class="in1"></span>
<span class="var">result</span> = <span class="var">malloc</span>(<span class="var">entrySize</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>

<span class="end">@end(<span class="name">allocate entry on heap)</span></span><br/>
</code>
</div>
<ul><li>
 Die Größe der Struktur wird um die Anzahl der zu kopierenden Bytes
  vergrößert</li><li>
 Wenn nicht genug Speicher vorhanden ist, dann wird das Programm beendet</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">copy entry values)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
<span class="in2"></span>
<span class="fn">memcpy</span>(<br/>
<span class="in3"></span>
<span class="var">result</span>-&gt;<span class="var">value</span>, <span class="var">valueBegin</span>,<br/>
<span class="in3"></span>
<span class="var">valueLength</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>
<span class="in1"></span>
<span class="var">result</span>-&gt;<span class="var">valueEnd</span> =<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">value</span> + <span class="var">valueLength</span>;<br/>
<span class="in1"></span>
<span class="var">result</span>-&gt;<span class="var">macro</span> = <span class="var">macro</span>;<br/>

<span class="end">@end(<span class="name">copy entry values)</span></span><br/>
</code>
</div>
<ul><li>
 Die Bytes werden nur kopiert, wenn welche übergeben wurden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>

<span class="type">struct FragEntry *</span><br/>

<span class="fn">allocEmptyMacroEntry</span>() {<br/>
<span class="in1"></span>
<span class="keyword">return</span> <span class="fn">allocMacroEntry</span>(<br/>
<span class="in2"></span>
<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span><br/>
<span class="in1"></span>
);<br/>

}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Für Tests ist es praktisch, leere Einträge anzulegen</li></ul></div>
</div>
<h1>Makro Einträge freigeben</h1>
<div class="slides">
<div><div>
<h1>Makro Einträge freigeben</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>

<span class="keyword">void</span> <span class="fn">freeMacroEntry</span>(<br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span><br/>

) {<br/>
<span class="in1"></span>
<span class="keyword">while</span> (<span class="var">entry</span>) {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">link</span> =<br/>
<span class="in3"></span>
<span class="var">entry</span>-&gt;<span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="fn">free</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="var">entry</span> = <span class="var">link</span>;<br/>
<span class="in1"></span>
}<br/>

}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn ein Eintrag freigegeben wird, so werden auch alle verlinkten</li></ul></div>
<div>
<ul><li>
 Referenzierte Makros werden nicht mit freigegeben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">forward declarations)</span></span><br/>

<span class="type">struct FragEntry</span>;<br/>

<span class="keyword">void</span> <span class="fn">freeMacroEntry</span>(<br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span><br/>

);<br/>

<span class="end">@end(<span class="name">forward declarations)</span></span><br/>

<br/>

<span class="add">@def(<span class="name">free macros entries)</span></span><br/>
<span class="in1"></span>
<span class="fn">freeMacroEntry</span>(<span class="var">macro</span>-&gt;<span class="var">firstEntry</span>);<br/>

<span class="end">@end(<span class="name">free macros entries)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn ein Makro freigegeben wird, so werden auch die anhängenden
  Einträge freigegeben</li><li>
 Damit die Funktion im <code><span class="fn">freeMacro</span></code> sichtbar ist, wird sie in der
  Include-Sektion definiert</li></ul></div>
</div>
<h1>Auf Attribute zugreifen</h1>
<div class="slides">
<div><div>
<h1>Auf Attribute zugreifen</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="keyword">int</span> <span class="fn">getMacroEntryValueSize</span>(<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="var">entry</span>) {<br/>
<span class="in3"></span>
<span class="keyword">return</span> <span class="num">0</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">entry</span>-&gt;<span class="var">valueEnd</span> -<br/>
<span class="in3"></span>
<span class="var">entry</span>-&gt;<span class="var">value</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Liefert die Anzahl der enthaltenen Bytes</li></ul></div>
</div>
<h1>Unit Tests</h1>
<div class="slides">
<div><div>
<h1>Unit Tests</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyMacroEntry</span>();<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">macro</span>);<br/>

<br/>
<span class="in2"></span>
<span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Ein leerer Eintrag hat keinen Nachfolger</li><li>
 Und kein Makro</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyMacroEntry</span>();<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">getMacroEntryValueSize</span>(<br/>
<span class="in4"></span>
<span class="var">entry</span>) == <span class="num">0);</span><br/>

<br/>
<span class="in2"></span>
<span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Ein leerer Eintrag hat keine Bytes</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><br/>
<span class="in1"></span>
<span class="fn">allocTestMacroEntry</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">value</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span> = <span class="var">value</span> +<br/>
<span class="in3"></span>
<span class="fn">strlen</span>(<span class="var">value</span>);<br/>

<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="fn">allocMacroEntry</span>(<br/>
<span class="in3"></span>
<span class="keyword">NULL</span>, <span class="var">value</span>, <span class="var">end</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Der Test-Konstruktor bekommt eine Null-terminierte Zeichenkette als
  Argument</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacroEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">getMacroEntryValueSize</span>(<br/>
<span class="in4"></span>
<span class="var">entry</span>) == <span class="num">3);</span><br/>

<br/>
<span class="in2"></span>
<span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Eintrag hat die korrekte Anzahl an Bytes</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacroEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">memcmp</span>(<span class="var">entry</span>-&gt;<span class="var">value</span>,<br/>
<span class="in4"></span>
<span class="str">"abc"</span>, <span class="num">3</span>) == <span class="num">0);</span><br/>

<br/>
<span class="in2"></span>
<span class="fn">freeMacroEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Die Bytes eines Eintrags stimmen überein</li></ul></div>
</div>
<h1>Einträge zu Makros hinzufügen</h1>
<div class="slides">
<div><div>
<h1>Einträge zu Makros hinzufügen</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addEntryToMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span>,<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">assert add entry)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">macro</span>-&gt;<span class="var">firstEntry</span>) {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">append entry)</span></span>;<br/>
<span class="in2"></span>
} <span class="keyword">else</span> {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">set first entry)</span></span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Eintrag wird entweder an das Ende der Liste der Einträge angehängt</li><li>
 Oder als neuer Kopf der Liste gesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">assert add entry)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>

<span class="end">@end(<span class="name">assert add entry)</span></span><br/>
</code>
</div>
<ul><li>
 Makro darf nicht <code><span class="keyword">NULL</span></code> sein</li><li>
 Eintrag darf nicht <code><span class="keyword">NULL</span></code> sein</li><li>
 Eintrag darf noch nicht in einer anderen Liste hängen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">append entry)</span></span><br/>
<span class="in1"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">link</span> = <span class="var">entry</span>;<br/>
<span class="in1"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>

<span class="end">@end(<span class="name">append entry)</span></span><br/>
</code>
</div>
<ul><li>
 Da es schon Einträge gibt, muss es bereits einen letzten geben</li><li>
 Dessen neuer Nachfolger ist der neue Eintrag</li><li>
 Der neue Eintrag wird zum neuen letzten Eintrag</li><li>
 Der Nachfolger von <code><span class="var">entry</span></code> ist bereits <code><span class="keyword">NULL</span></code></li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">set first entry)</span></span><br/>
<span class="in1"></span>
<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> = <span class="var">entry</span>;<br/>
<span class="in1"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>

<span class="end">@end(<span class="name">set first entry)</span></span><br/>
</code>
</div>
<ul><li>
 Der erste Eintrag wird auch als letzter Eintrag gesetzt</li><li>
 Der Nachfolger von <code><span class="var">entry</span></code> ist bereits <code><span class="keyword">NULL</span></code></li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyMacroEntry</span>();<br/>
<span class="in2"></span>
<span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> == <span class="var">entry</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Der erste Eintrag im Makro wird gesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyMacroEntry</span>();<br/>
<span class="in2"></span>
<span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span> == <span class="var">entry</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Der letzte Eintrag im Makro wird gesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">first</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">second</span>;<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">add two entries)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check first of 2)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Zwei Einträge werden an ein Makro angehängt</li><li>
 Der erste Eintrag muss gesetzt bleiben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">add two entries)</span></span><br/>
<span class="in1"></span>
<span class="var">macro</span> = <span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="var">first</span> = <span class="fn">allocEmptyMacroEntry</span>();<br/>
<span class="in1"></span>
<span class="var">second</span> = <span class="fn">allocEmptyMacroEntry</span>();<br/>

<br/>
<span class="in1"></span>
<span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">first</span>);<br/>
<span class="in1"></span>
<span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">second</span>);<br/>

<span class="end">@end(<span class="name">add two entries)</span></span><br/>

<br/>

<span class="add">@def(<span class="name">check first of 2)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> == <span class="var">first</span>);<br/>

<span class="end">@end(<span class="name">check first of 2)</span></span><br/>
</code>
</div>
<ul><li>
 Zwei Einträge werden an ein Makro angehängt</li><li>
 Der erste Eintrag muss gesetzt bleiben</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">first</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">second</span>;<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">add two entries)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span> == <span class="var">second</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Zwei Einträge werden an ein Makro angehängt</li><li>
 Der letzte Eintrag muss gesetzt werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addBytesToMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">value</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueEnd</span>,<br/>
<span class="in2"></span>
<span class="type">struct Input *</span><span class="var">input</span>,<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocMacroEntry</span>(<br/>
<span class="in4"></span>
<span class="keyword">NULL</span>, <span class="var">value</span>, <span class="var">valueEnd</span><br/>
<span class="in3"></span>
);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">populate additional entry fields)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Für die Daten wird ein neuer Eintrag angelegt</li><li>
 Dieser wird an das Makro angehängt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">define cycle check)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addMacroToMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span>,<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">child</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">child</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">avoid macro cycles)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">reuse last entry)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">add macro entry)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Bevor ein Makro hinzugefügt werden kann, muss sichergestellt werden,
  dass kein Zykel entsteht</li><li>
 Ein Zykel liegt vor, wenn <code><span class="var">macro</span></code> gleich <code><span class="var">child</span></code> ist</li><li>
 Oder bereits direkt oder indirekt zu <code><span class="var">child</span></code> hinzugefügt wurde</li><li>
 Falls der letzte Eintrag noch kein Makro hat, wird dieser Eintrag
  verwendet</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">reuse last entry)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">macro</span>-&gt;<span class="var">firstEntry</span> &amp;&amp;<br/>
<span class="in2"></span>
! <span class="var">macro</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">macro</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="var">macro</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">macro</span> = <span class="var">child</span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">reuse last entry)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn das Makro-Attribut im letzten Eintrag noch nicht benutzt wird,
  kann dieses verwendet werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">add macro entry)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in2"></span>
<span class="fn">allocMacroEntry</span>(<br/>
<span class="in3"></span>
<span class="var">child</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
<span class="fn">addEntryToMacro</span>(<span class="var">macro</span>, <span class="var">entry</span>);<br/>

<span class="end">@end(<span class="name">add macro entry)</span></span><br/>
</code>
</div>
<ul><li>
 Sonst muss ein neuer Eintrag mit dem Makro angelegt werden</li></ul></div>
</div>
<h1>Makros serialisieren</h1>
<div class="slides">
<div><div>
<h1>Makros serialisieren</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">serialize test defines)</span></span>;<br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">serializeMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro,</span><br/>
<span class="in2"></span>
<span class="type">FILE *</span><span class="var">out</span>,<br/>
<span class="in2"></span>
<span class="type">bool</span> <span class="var">writeLineMacros</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">macro</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">out</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">iterate entries)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Jeder Eintrag wird nacheinander bearbeitet</li><li>
 Makros in Einträgen werden rekursiv ausgegeben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">iterate entries)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in2"></span>
<span class="var">macro</span>-&gt;<span class="var">firstEntry</span>;<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">serialize bytes)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">entry</span>-&gt;<span class="var">macro</span>) {<br/>
<span class="in3"></span>
<span class="fn">serializeMacro</span>(<br/>
<span class="in4"></span>
<span class="var">entry</span>-&gt;<span class="var">macro</span>, <span class="var">out</span>,<br/>
<span class="in4"></span>
<span class="var">writeLineMacros</span><br/>
<span class="in3"></span>
);<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">iterate entries)</span></span><br/>
</code>
</div>
<ul><li>
 Für jeden Eintrag werden zuerst die Bytes ausgegeben</li><li>
 Dann wird rekursiv das Makro ausgegeben, falls vorhanden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize test defines)</span></span><br/>
<span class="in1"></span>
<span class="type">char *</span><span class="var">macroTestBufferCur</span> = <span class="keyword">NULL</span>;<br/>
<span class="in1"></span>
<span class="type">const char *</span><span class="var">macroTestBufferEnd</span> = <span class="keyword">NULL</span>;<br/>

<span class="end">@end(<span class="name">serialize test defines)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize bytes)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="fn">getMacroEntryValueSize</span>(<span class="var">entry</span>)) {<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">cur</span> = <span class="var">entry</span>-&gt;<span class="var">value</span>;<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span> = <span class="var">entry</span>-&gt;<span class="var">valueEnd</span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">len</span> = <span class="var">end</span> - <span class="var">cur</span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="var">macroTestBufferCur</span>) {<br/>
<span class="in3"></span>
<span class="fn">ASSERT</span>(<span class="fn">fwrite</span>(<span class="var">cur</span>, 1, <span class="var">len</span>, <span class="var">out</span>) == <span class="var">len</span>);<br/>
<span class="in2"></span>
} <span class="keyword">else</span> {<br/>
<span class="in3"></span>
<span class="fn">ASSERT</span>(<span class="var">macroTestBufferCur</span> + <span class="var">len</span> &lt; <span class="var">macroTestBufferEnd</span>);<br/>
<span class="in3"></span>
<span class="fn">memcpy</span>(<span class="var">macroTestBufferCur</span>, <span class="var">cur</span>, <span class="var">len</span>);<br/>
<span class="in3"></span>
<span class="var">macroTestBufferCur</span> += <span class="var">len</span>;<br/>
<span class="in3"></span>
*<span class="var">macroTestBufferCur</span> = <span class="str">'\0'</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">serialize bytes)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn es Bytes in dem Eintrag gibt, wird der <code><span class="var">consumer</span></code> mit ihnen
  aufgerufen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">testMacro</span>(<span class="type">struct Frag *</span><br/>
<span class="in2"></span>
<span class="var">macro</span>, <span class="type">const char *</span><span class="var">expected</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">serialize test macro)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Diese Hilfsfunktion prüft ob die Serialisierung eines Makros der
  Erwartung entspricht</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize test macro)</span></span><br/>
<span class="in1"></span>
char buffer[100];<br/>
<span class="in1"></span>
macroTestBufferCur = buffer;<br/>
<span class="in1"></span>
macroTestBufferEnd = buffer + sizeof(buffer);<br/>
<span class="in1"></span>
<span class="fn">serializeMacro</span>(<span class="var">macro</span>, (void *) buffer, <span class="keyword">false</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="fn">strcmp</span>(<br/>
<span class="in2"></span>
<span class="var">expected</span>, <span class="var">buffer</span><br/>
<span class="in1"></span>
) == 0);<br/>
<span class="in1"></span>
macroTestBufferCur = NULL;<br/>
<span class="in1"></span>
macroTestBufferEnd = NULL;<br/>

<span class="end">@end(<span class="name">serialize test macro)</span></span><br/>
</code>
</div>
<ul><li>
 Serialisiert das Makro</li><li>
 Der Buffer muss die erwarteten Werte enthalten</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addStringToMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">str</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">size</span> = <span class="fn">strlen</span>(<span class="var">str</span>);<br/>
<span class="in2"></span>
<span class="fn">addBytesToMacro</span>(<br/>
<span class="in3"></span>
<span class="var">macro</span>, <span class="var">str</span>, <span class="var">str</span> + <span class="var">size</span>,<br/>
<span class="in3"></span>
<span class="keyword">NULL</span>, <span class="num">0</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Zu Testzwecken kann eine Null-terminierte Zeichenkette hinzugefügt
  werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
<span class="in2"></span>
<span class="fn">addStringToMacro</span>(<span class="var">macro</span>, <span class="str">"abc"</span>);<br/>
<span class="in2"></span>
<span class="fn">addStringToMacro</span>(<span class="var">macro</span>, <span class="str">"def"</span>);<br/>
<span class="in2"></span>
<span class="fn">testMacro</span>(<span class="var">macro</span>, <span class="str">"abcdef"</span>);<br/>
<span class="in2"></span>
<span class="fn">freeMacro</span>(<span class="var">macro</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Prüft, ob zwei Strings richtig serialisiert werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">macro unit tests)</span></span> {<br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="var">a</span> =<br/>
<span class="in2"></span>
<span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="var">b</span> =<br/>
<span class="in2"></span>
<span class="fn">allocTestMacro</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="fn">addStringToMacro</span>(<span class="var">a</span>, <span class="str">"abc"</span>);<br/>
<span class="in1"></span>
<span class="fn">addMacroToMacro</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>
<span class="in1"></span>
<span class="fn">addStringToMacro</span>(<span class="var">b</span>, <span class="str">"def"</span>);<br/>
<span class="in1"></span>
<span class="fn">addMacroToMacro</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>
<span class="in1"></span>
<span class="fn">testMacro</span>(<span class="var">b</span>, <span class="str">"abcdefabc"</span>);<br/>
<span class="in1"></span>
<span class="fn">freeMacro</span>(<span class="var">a</span>); <span class="fn">freeMacro</span>(<span class="var">b</span>);<br/>

} <span class="end">@end(<span class="name">macro unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Prüft, ob Makros expandiert werden</li></ul></div>
</div>
<h1>Zykel im Makro-Graph finden</h1>
<div class="slides">
<div><div>
<h1>Zykel im Makro-Graph finden</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">includes)</span></span><br/>
<span class="in1"></span>
#include &lt;stdbool.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>
</code>
</div>
<ul><li>
 Boolesche Datenwerte werden benötigt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">define cycle check)</span></span><br/>
<span class="in1"></span>
<span class="type">bool</span> <span class="fn">isMacroInMacro</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">needle</span>,<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">haystack</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">needle</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">haystack</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check cycle macro)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check cycle entries)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="keyword">false</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define cycle check)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn das Makro das gesuchte ist, dann wurde ein Zykel gefunden</li><li>
 Danach wird über alle Einträge gesucht</li><li>
 Wenn das Makro dort nicht gefunden wurde, dann ist es nicht enthalten</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">avoid macro cycles)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(! <span class="fn">isMacroInMacro</span>(<br/>
<span class="in2"></span>
<span class="var">macro</span>, <span class="var">child</span><br/>
<span class="in1"></span>
));<br/>

<span class="end">@end(<span class="name">avoid macro cycles)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Makro darf nur hinzugefügt werden, wenn es den Container nicht
  bereits enthält</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">check cycle macro)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">needle</span> == <span class="var">haystack</span>) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">check cycle macro)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn der Container selbst das gesuchte Makro ist, liefert die Funktion
  <code><span class="keyword">true</span></code> zurück</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">check cycle entries)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in2"></span>
<span class="var">haystack</span>-&gt;<span class="var">firstEntry</span>;<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="var">entry</span>-&gt;<span class="var">macro</span>) { <span class="keyword">continue</span>; }<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="fn">isMacroInMacro</span>(<br/>
<span class="in3"></span>
<span class="var">needle</span>, <span class="var">entry</span>-&gt;<span class="var">macro</span><br/>
<span class="in2"></span>
)) {<br/>
<span class="in3"></span>
<span class="keyword">return</span> <span class="keyword">true</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">check cycle entries)</span></span><br/>
</code>
</div>
<ul><li>
 Alle Makros in den Einträgen werden rekursiv untersucht</li><li>
 Damit wird der ganze Graph durchsucht</li></ul></div>
</div>
<h1>Makro-Kollektion</h1>
<div class="slides">
<div><div>
<h1>Makro-Kollektion</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
#define MACRO_SLOTS 128<br/>

<br/>
<span class="in1"></span>
<span class="type">struct MacroMap</span> {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macros</span><span class="type">[</span><br/>
<span class="in3"></span>
<span class="type">MACRO_SLOTS</span><br/>
<span class="in2"></span>
<span class="type">]</span>;<br/>
<span class="in1"></span>
};<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Eine Kollektion von Makros ist ein Array von Makro-Ketten</li><li>
 Alle Felder müssen mit <code><span class="keyword">NULL</span></code> initialisiert werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">clearMacroMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct MacroMap *</span><span class="var">map</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag **</span><span class="var">cur</span> = <span class="var">map</span>-&gt;<span class="var">macros</span>;<br/>
<span class="in2"></span>
<span class="type">struct Frag **</span><span class="var">end</span> =<br/>
<span class="in3"></span>
<span class="var">cur</span> + <span class="var">MACRO_SLOTS</span>;<br/>
<span class="in2"></span>
<span class="keyword">for</span> (; <span class="var">cur</span> &lt; <span class="var">end</span>; ++<span class="var">cur</span>) {<br/>
<span class="in3"></span>
<span class="fn">freeMacro</span>(*<span class="var">cur</span>); *<span class="var">cur</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Um den Speicher freizugeben, wird jeder Slot gelöscht</li><li>
 und auf &lt;code class="keyword"&gt;NULL&lt;/code&gt; gesetzt um wieder verwendet</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="fn">calcHash</span>(<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">begin</span>);<br/>
<span class="in2"></span>
<span class="type">unsigned</span> <span class="var">hash</span> = <span class="num">0xf1e2d3c4</span>;<br/>
<span class="in2"></span>
<span class="keyword">while</span> (*<span class="var">begin</span> &amp;&amp; <span class="var">begin</span> != <span class="var">end</span>) {<br/>
<span class="in3"></span>
<span class="var">hash</span> ^= *<span class="var">begin</span>++;<br/>
<span class="in3"></span>
<span class="var">hash</span> = (<span class="var">hash</span> &lt;&lt; 3) |<br/>
<span class="in4"></span>
(<span class="var">hash</span> &gt;&gt; 29);<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">hash</span> % <span class="var">MACRO_SLOTS</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Der Hash wird über den Namen des Makros erstellt</li><li>
 Der Name kann entweder durch ein Null-Byte abgeschlossen werden</li><li>
 Oder ein Ende wird direkt angegeben</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">allocMacroInMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct MacroMap *</span><span class="var">map</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> =<br/>
<span class="in3"></span>
<span class="fn">allocFrag</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">insert in slot)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">macro</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Ein neues Makro wird erstellt</li><li>
 Und in der Hash-Map abgelegt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">insert in slot)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in1"></span>
<span class="var">macro</span>-&gt;<span class="var">link</span> = <span class="var">map</span>-&gt;<span class="var">macros</span>[<span class="var">hash</span>];<br/>
<span class="in1"></span>
<span class="var">map</span>-&gt;<span class="var">macros</span>[<span class="var">hash</span>] = <span class="var">macro</span>;<br/>

<span class="end">@end(<span class="name">insert in slot)</span></span><br/>
</code>
</div>
<ul><li>
 Makros werden im Slot eingefügt</li><li>
 Neue Makros überlagern alte Slots mit gleichem Namen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">findMacroInMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct MacroMap *</span><span class="var">map</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> = <span class="fn">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">find macro in slot)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">macro</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Liefert das erste Makro mit dem übergebenen Namen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">find macro in slot)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in1"></span>
<span class="var">macro</span> = <span class="var">map</span>-&gt;<span class="var">macros</span>[<span class="var">hash</span>];<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">macro</span>; <span class="var">macro</span> = <span class="var">macro</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">a</span> = <span class="var">begin</span>;<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">b</span> = <span class="var">macro</span>-&gt;<span class="var">name</span>;<br/>
<span class="in2"></span>
<span class="keyword">while</span> (<span class="var">a</span> != <span class="var">end</span>) {<br/>
<span class="in3"></span>
<span class="keyword">if</span> (*<span class="var">a</span>++ != *<span class="var">b</span>++) { <span class="keyword">break</span>; }<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">a</span> == <span class="var">end</span> &amp;&amp; ! *<span class="var">b</span>) {<br/>
<span class="in3"></span>
<span class="keyword">return</span> <span class="var">macro</span>; }<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">find macro in slot)</span></span><br/>
</code>
</div>
<ul><li>
 Im passenden Hash-Slot werden die Namen der Makros verglichen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">getMacroInMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct MacroMap *</span><span class="var">map</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">macro</span> = NULL;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">get macro find)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">get macro alloc)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">macro</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Liefert Makro mit angegebenen Namen oder legt ein neues Makro mit
  diesem Namen an</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">get macro find)</span></span><br/>
<span class="in1"></span>
<span class="var">macro</span> = <span class="fn">findMacroInMap</span>(<br/>
<span class="in2"></span>
<span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
<span class="in1"></span>
);<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">macro</span>) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">macro</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">get macro find)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn das Makro in der Kollektion vorhanden ist, wird dieses verwendet</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">get macro alloc)</span></span><br/>
<span class="in1"></span>
<span class="var">macro</span> = <span class="fn">allocMacroInMap</span>(<br/>
<span class="in2"></span>
<span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">get macro alloc)</span></span><br/>
</code>
</div>
<ul><li>
 Sonst wird ein neues Makro angelegt</li></ul></div>
</div>
<h1>Position im Original merken</h1>
<div class="slides">
<div><div>
<h1>Position im Original merken</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">additional entry attributes)</span></span><br/>
<span class="in1"></span>
struct Input *input;<br/>
<span class="in1"></span>
int line;<br/>

<span class="end">@end(<span class="name">additional entry attributes)</span></span><br/>
</code>
</div>
<ul><li>
 Jedes Fragment hält einen Zeiger auf die Datei aus der das Fragment
  generiert wurde</li><li>
 Und die Zeile in dieser Datei</li><li>
 So kann durch spezielle <code>#line</code> Makros im generierten Source-Code auf
  die ursprüngliche Datei verwiesen werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">populate additional entry fields)</span></span><br/>
<span class="in1"></span>
<span class="var">entry</span>-&gt;<span class="var">input</span> = <span class="var">input</span>;<br/>
<span class="in1"></span>
<span class="var">entry</span>-&gt;<span class="var">line</span> = <span class="var">line</span>;<br/>

<span class="end">@end(<span class="name">populate additional entry fields)</span></span><br/>
</code>
</div>
