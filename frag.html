<!doctype html>
<html lang="de"l>
<head>
<meta charset="utf-8">
<title>Fragmente</title><link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>Fragmente</h1>
<div class="slides">
<div><div>
<h1>Fragmente</h1>
</div>

<ul><li>
 Fragmente bilden einen gerichteten azyklischen Graph
</li><li>
 Die Infix-Traversierung dieses Graphen bildet die generierten
  Source-Code Dateien
</li></ul></div>

<div><div>
<code>

<span class="include">@include(<span class="name"><a href="hash.html">hash.x</a>)</span></span><br/>

</code>
</div>

<ul><li>
 Hash-Funktion wird benötigt
</li><li>
 Und in der Datei als <code>calcHash</code> definiiert
</li></ul></div>

<div><div>
<code>

<span class="add">@globadd(<span class="name">global elements</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">define frag</span>)</span>;<br/>

<span class="end">@end(<span class="name">global elements</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragmente sind global sichtbare Strukturen
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span>;<br/>

<br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">link</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">firstEntry</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">lastEntry</span>;<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">expands</span>;<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">multiples</span>;<br/>

<span class="in2"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">name</span>;<br/>

<span class="in1"></span>};<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragmente erden in einfach verketteten Listen gesammelt
</li><li>
 Genauso werden die Einträge eines Fragments in einer einfach
  verketteten Liste organisiert
</li><li>
 Um schnell Einträge einfügen zu können, gibt es auch einen Verweis auf
  das letzte Element
</li><li>
 Je nach Namen werden für ein Fragment unterschiedlich viele Bytes im
  Heap angefordert
</li></ul></div>

<div><div>
<code>

<span class="add">@globadd(<span class="name">includes</span>)</span><br/>

<span class="in1"></span>#<span class="var">include</span> &lt;<span class="var">stdlib</span>.<span class="var">h</span>&gt;<br/>

<span class="end">@end(<span class="name">includes</span>)</span><br/>

</code>
</div>

<ul><li>
 <code>stdlib.h</code> wird für die Definition von <code>nullptr</code> benötigt
</li></ul></div>

</div>
<h1>Neues Fragment anlegen</h1>
<div class="slides">
<div><div>
<h1>Neues Fragment anlegen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="fn">allocFrag</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">nameBegin</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">nameEnd</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">result</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">allocate frag on heap</span>)</span>;<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">link</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">firstEntry</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">expands</span> = <span class="num">0</span>;<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">multiples</span> = <span class="num">0</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">copy frag name</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Zeiger werden mit <code>nullptr</code> initialisiert
</li><li>
 <code>lastEntry</code> wird erst initialisiert, wenn <code>firstEntry</code> gesetzt
  wird
</li><li>
 Der Name wird über zwei Zeiger übergeben, muss also nicht mit einem
  Null-Byte terminiert sein
</li></ul></div>

<div><div>
<code>

<span class="add">@globdef(<span class="name">define logging</span>)</span><br/>

<span class="in1"></span>#<span class="var">define</span> <span class="fn">ASSERT</span>(<span class="var">COND</span>, ...) \<br/>

<span class="in2"></span><span class="keyword">if</span> (! (<span class="var">COND</span>)) { \<br/>

<span class="in3"></span><span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>

<span class="in4"></span><span class="str">"%s:%d"</span>, \<br/>

<span class="in4"></span><span class="var">__FILE__</span>, <span class="var">__LINE__</span>); \<br/>

<span class="in3"></span><span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>

<span class="in4"></span><span class="str">" FAILED: "</span> <span class="var">__VA_ARGS__</span>); \<br/>

<span class="in3"></span><span class="fn">fprintf</span>(<span class="var">stderr</span>, <span class="str">"\n"</span>); \<br/>

<span class="in3"></span><span class="fn">exit</span>(<span class="var">EXIT_FAILURE</span>); \<br/>

<span class="in2"></span>}<br/>

<span class="end">@end(<span class="name">define logging</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn Bedingung falsch ist, wird Fehlermeldung ausgegeben
</li><li>
 Und das Programm beendet
</li><li>
 Datei und Zeile des Tests wird ausgegeben
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">allocate frag on heap</span>)</span><br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">nameBegin</span>);<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">nameBegin</span> &lt;= <span class="var">nameEnd</span>);<br/>

<span class="in1"></span><span class="var">result</span> = <span class="keyword">new</span> <span class="fn">Frag</span>();<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>

<span class="end">@end(<span class="name">allocate frag on heap</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Zeiger werden mit <code>nullptr</code> initialisiert
</li><li>
 <code>lastEntry</code> wird erst initialisiert, wenn <code>firstEntry</code> gesetzt
  wird
</li><li>
 Der Name wird über zwei Zeiger übergeben, muss also nicht mit einem
  Null-Byte terminiert sein
</li></ul></div>

<div><div>
<code>

<span class="add">@globadd(<span class="name">includes</span>)</span><br/>

<span class="in1"></span>#<span class="var">include</span> &lt;<span class="var">string</span>.<span class="var">h</span>&gt;<br/>

<span class="end">@end(<span class="name">includes</span>)</span><br/>

<br/>

<span class="add">@def(<span class="name">copy frag name</span>)</span><br/>

<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">name</span> = <span class="var">std</span>::<span class="fn">string</span>(<span class="var">nameBegin</span>, <span class="var">nameEnd</span>);<br/>

<span class="end">@end(<span class="name">copy frag name</span>)</span><br/>

</code>
</div>

<ul><li>
 Der Name wird direkt in das Fragment kopiert
</li></ul></div>

</div>
<h1>Fragmente freigeben</h1>
<div class="slides">
<div><div>
<h1>Fragmente freigeben</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">freeFragEntries</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">frag</span>) {<br/>

<span class="in3"></span><span class="expand">@expand(<span class="name">free frag entries</span>)</span>;<br/>

<span class="in3"></span><span class="var">frag</span>-&gt;<span class="var">firstEntry</span> = <span class="num">nullptr</span>;<br/>

<span class="in3"></span><span class="var">frag</span>-&gt;<span class="var">lastEntry</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">freeFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">f</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">while</span> (<span class="var">f</span>) {<br/>

<span class="in3"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">l</span> =<br/>

<span class="in4"></span><span class="var">f</span>-&gt;<span class="var">link</span>;<br/>

<span class="in3"></span><span class="fn">freeFragEntries</span>(<span class="var">f</span>);<br/>

<span class="in3"></span><span class="fn">delete</span>(<span class="var">f</span>);<br/>

<span class="in3"></span><span class="var">f</span> = <span class="var">l</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Mit einem Fragment werden auch alle verketteten Fragmente freigegeben
</li><li>
 Die Freigabe der einzelnen Einträge wird später definiert
		
</li></ul></div>
# Unit Tests

<div><div>
<code>

<span class="add">@globdef(<span class="name">perform unit-tests</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">frag unit tests</span>)</span>;<br/>

<span class="end">@end(<span class="name">perform unit-tests</span>)</span><br/>

<br/>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="fn">allocTestFrag</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">name</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="fn">allocFrag</span>(<br/>

<span class="in3"></span><span class="var">name</span>, <span class="var">name</span> + <span class="fn">strlen</span>(<span class="var">name</span>)<br/>

<span class="in2"></span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Für Unit-Tests gibt es einen einfacheren Konstruktor
</li><li>
 Die Länge des Namens wird anhand des Null-Bytes berechnet
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">testFragName</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">name</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">f</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFrag</span>(<span class="var">name</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>-&gt;<span class="var">name</span> == <span class="var">name</span>);<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 <code>testFragName</code> prüft, ob der Name korrekt in ein Fragment kopiert
  wurde
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">"abc"</span>);<br/>

<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">"A c"</span>);<br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">f</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFrag</span>(<span class="str">"ab"</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">f</span>-&gt;<span class="var">link</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">f</span>-&gt;<span class="var">firstEntry</span>);<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Zum einen wird getestet, ob die Namen korrekt kopiert werden
</li><li>
 Zum anderen wird sichergestellt, dass die Verweise <code>nullptr</code> sind
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">bool</span> <span class="fn">isPopulatedFrag</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">struct</span> <span class="type">Frag</span> *<span class="var">f</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">f</span> &amp;&amp; <span class="var">f</span>-&gt;<span class="var">firstEntry</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>


</div>
</div>
<h1>Fragment-Einträge</h1>
<div class="slides">
<div><div>
<h1>Fragment-Einträge</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">link</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>;<br/>

<span class="in2"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">value</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">additional entry attributes</span>)</span>;<br/>

<span class="in1"></span>};<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Eintrag kann entweder auf ein anderes Fragment verweisen (wenn
  dieses an der aktuellen Stelle expandiert werden soll)
</li><li>
 Oder er enthält Bytes, die beim Expandieren direkt expandiert werden
</li><li>
 Die Länge des Byte-Arrays wird über einen Zeiger angezeigt (damit auch
  Null-Bytes verwendet werden können)
</li><li>
 Wenn ein Eintrag sowohl Daten als auch ein Fragment enthält, so wird
  zuerst der Text ausgegeben
		
</li></ul></div>
# Fragment-Eintrag anlegen

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="fn">allocFragEntry</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">valueBegin</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">valueEnd</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">result</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">allocate entry on heap</span>)</span>;<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">link</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">copy entry values</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Wie bei einem Fragment werden die <code>link</code> Verweise auf <code>nullptr</code>
  initialisiert
</li><li>
 Sowohl <code>frag</code> als auch <code>valueBegin</code> sind optional
</li><li>
 Die Größe des Eintrags hängt von der Anzahl der Bytes ab, die kopiert
  werden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">allocate entry on heap</span>)</span><br/>

<span class="in1"></span><span class="var">result</span> = <span class="keyword">new</span> <span class="fn">FragEntry</span>();<br/>

<span class="end">@end(<span class="name">allocate entry on heap</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Größe der Struktur wird um die Anzahl der zu kopierenden Bytes
  vergrößert
</li><li>
 Wenn nicht genug Speicher vorhanden ist, dann wird das Programm beendet
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">copy entry values</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">value</span> = <span class="var">std</span>::<span class="fn">string</span>(<span class="var">valueBegin</span>, <span class="var">valueEnd</span>);<br/>

<span class="in1"></span>}<br/>

<span class="in1"></span><span class="var">result</span>-&gt;<span class="var">frag</span> = <span class="var">frag</span>;<br/>

<span class="end">@end(<span class="name">copy entry values</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Bytes werden nur kopiert, wenn welche übergeben wurden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<br/>

<span class="in2"></span><span class="fn">allocEmptyFragEntry</span>() {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="fn">allocFragEntry</span>(<br/>

<span class="in4"></span><span class="num">nullptr</span>, <span class="num">nullptr</span>, <span class="num">nullptr</span><br/>

<span class="in3"></span>);<br/>

<span class="in2"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Für Tests ist es praktisch, leere Einträge anzulegen
</li></ul></div>

</div>
<h1>Fragment-Einträge freigeben</h1>
<div class="slides">
<div><div>
<h1>Fragment-Einträge freigeben</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">freeFragEntry</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">e</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">while</span> (<span class="var">e</span>) {<br/>

<span class="in3"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">l</span> =<br/>

<span class="in4"></span><span class="var">e</span>-&gt;<span class="var">link</span>;<br/>

<span class="in3"></span><span class="fn">delete</span>(<span class="var">e</span>);<br/>

<span class="in3"></span><span class="var">e</span> = <span class="var">l</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn ein Eintrag freigegeben wird, so werden auch alle verlinkten
  Einträge freigegeben
</li><li>
 Referenzierte Fragmente werden nicht mit freigegeben
</li></ul></div>

<div><div>
<code>

<span class="add">@globdef(<span class="name">forward declarations</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span>;<br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">freeFragEntry</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span><br/>

<span class="in1"></span>);<br/>

<span class="end">@end(<span class="name">forward declarations</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">free frag entries</span>)</span><br/>

<span class="in1"></span><span class="fn">freeFragEntry</span>(<span class="var">frag</span>-&gt;<span class="var">firstEntry</span>);<br/>

<span class="end">@end(<span class="name">free frag entries</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn ein Fragment freigegeben wird, so werden auch die anhängenden
  Einträge freigegeben
</li><li>
 Damit die Funktion im <code>freeFrag</code> sichtbar ist, wird sie in der
  Include-Sektion definiert
</li></ul></div>

</div>
<h1>Auf Attribute zugreifen</h1>
<div class="slides">
<div><div>
<h1>Auf Attribute zugreifen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">int</span> <span class="fn">getFragEntryValueSize</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">e</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">if</span> (! <span class="var">e</span>) {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="num">0</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">e</span>-&gt;<span class="var">value</span>.<span class="fn">size</span>();<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Liefert die Anzahl der enthaltenen Bytes
</li></ul></div>

</div>
<h1>Unit Tests</h1>
<div class="slides">
<div><div>
<h1>Unit Tests</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">frag</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein leerer Eintrag hat keinen Nachfolger
</li><li>
 Und kein Fragment
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="fn">getFragEntryValueSize</span>(<br/>

<span class="in4"></span><span class="var">entry</span>) == <span class="num">0</span><br/>

<span class="in2"></span>);<br/>

<br/>

<span class="in2"></span><span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein leerer Eintrag hat keine Bytes
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<br/>

<span class="in2"></span><span class="fn">allocTestFragEntry</span>(<br/>

<span class="in3"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">v</span><br/>

<span class="in2"></span>) {<br/>

<span class="in3"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">e</span> = <span class="var">v</span> +<br/>

<span class="in4"></span><span class="fn">strlen</span>(<span class="var">v</span>);<br/>

<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="fn">allocFragEntry</span>(<br/>

<span class="in4"></span><span class="num">nullptr</span>, <span class="var">v</span>, <span class="var">e</span><br/>

<span class="in3"></span>);<br/>

<span class="in2"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Der Test-Konstruktor bekommt eine Null-terminierte Zeichenkette als
  Argument
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFragEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="fn">getFragEntryValueSize</span>(<br/>

<span class="in4"></span><span class="var">entry</span>) == <span class="num">3</span><br/>

<span class="in2"></span>);<br/>

<br/>

<span class="in2"></span><span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Eintrag hat die korrekte Anzahl an Bytes
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFragEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>-&gt;<span class="var">value</span> == <span class="str">"abc"</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Bytes eines Eintrags stimmen überein
</li></ul></div>

</div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
<div class="slides">
<div><div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addEntryToFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">assert add entry</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">frag</span>-&gt;<span class="var">firstEntry</span>) {<br/>

<span class="in3"></span><span class="expand">@expand(<span class="name">append entry</span>)</span>;<br/>

<span class="in2"></span>} <span class="keyword">else</span> {<br/>

<span class="in3"></span><span class="expand">@expand(<span class="name">set first entry</span>)</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Eintrag wird entweder an das Ende der Liste der Einträge angehängt
</li><li>
 Oder als neuer Kopf der Liste gesetzt
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">assert add entry</span>)</span><br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>

<span class="end">@end(<span class="name">assert add entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragment darf nicht <code>nullptr</code> sein
</li><li>
 Eintrag darf nicht <code>nullptr</code> sein
</li><li>
 Eintrag darf noch nicht in einer anderen Liste hängen
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">append entry</span>)</span><br/>

<span class="in1"></span><span class="var">frag</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">link</span> = <span class="var">entry</span>;<br/>

<span class="in1"></span><span class="var">frag</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>

<span class="end">@end(<span class="name">append entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Da es schon Einträge gibt, muss es bereits einen letzten geben
</li><li>
 Dessen neuer Nachfolger ist der neue Eintrag
</li><li>
 Der neue Eintrag wird zum neuen letzten Eintrag
</li><li>
 Der Nachfolger von <code>entry</code> ist bereits <code>nullptr</code>
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">set first entry</span>)</span><br/>

<span class="in1"></span><span class="var">frag</span>-&gt;<span class="var">firstEntry</span> = <span class="var">entry</span>;<br/>

<span class="in1"></span><span class="var">frag</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>

<span class="end">@end(<span class="name">set first entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Der erste Eintrag wird auch als letzter Eintrag gesetzt
</li><li>
 Der Nachfolger von <code>entry</code> ist bereits <code>nullptr</code>
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">f</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">e</span> =<br/>

<span class="in3"></span><span class="fn">allocEmptyFragEntry</span>();<br/>

<span class="in2"></span><span class="fn">addEntryToFrag</span>(<span class="var">f</span>, <span class="var">e</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="var">f</span>-&gt;<span class="var">firstEntry</span> == <span class="var">e</span><br/>

<span class="in2"></span>);<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Der erste Eintrag im Fragment wird gesetzt
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">f</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">e</span> =<br/>

<span class="in3"></span><span class="fn">allocEmptyFragEntry</span>();<br/>

<span class="in2"></span><span class="fn">addEntryToFrag</span>(<span class="var">f</span>, <span class="var">e</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="var">f</span>-&gt;<span class="var">lastEntry</span> == <span class="var">e</span><br/>

<span class="in2"></span>);<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Der letzte Eintrag im Fragment wird gesetzt
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">first</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">second</span>;<br/>

<span class="in2"></span><span class="expand">@multiple(<span class="name">add two entries</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">check first of 2</span>)</span>;<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">frag</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Zwei Einträge werden an ein Fragment angehängt
</li><li>
 Der erste Eintrag muss gesetzt bleiben
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">add two entries</span>)</span><br/>

<span class="in1"></span><span class="var">frag</span> = <span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="var">first</span> = <span class="fn">allocEmptyFragEntry</span>();<br/>

<span class="in1"></span><span class="var">second</span> = <span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>

<span class="in1"></span><span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">first</span>);<br/>

<span class="in1"></span><span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">second</span>);<br/>

<span class="end">@end(<span class="name">add two entries</span>)</span><br/>

<br/>

<span class="add">@def(<span class="name">check first of 2</span>)</span><br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>-&gt;<span class="var">firstEntry</span> == <span class="var">first</span>);<br/>

<span class="end">@end(<span class="name">check first of 2</span>)</span><br/>

</code>
</div>

<ul><li>
 Zwei Einträge werden an ein Fragment angehängt
</li><li>
 Der erste Eintrag muss gesetzt bleiben
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">first</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">second</span>;<br/>

<span class="in2"></span><span class="expand">@multiple(<span class="name">add two entries</span>)</span>;<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="var">frag</span>-&gt;<span class="var">lastEntry</span> == <span class="var">second</span><br/>

<span class="in2"></span>);<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">frag</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Zwei Einträge werden an ein Fragment angehängt
</li><li>
 Der letzte Eintrag muss gesetzt werden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addBytesToFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">value</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">valueEnd</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">source</span>,<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocFragEntry</span>(<br/>

<span class="in4"></span><span class="num">nullptr</span>, <span class="var">value</span>, <span class="var">valueEnd</span><br/>

<span class="in3"></span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">populate additional entry fields</span>)</span>;<br/>

<span class="in2"></span><span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Für die Daten wird ein neuer Eintrag angelegt
</li><li>
 Dieser wird an das Fragment angehängt
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">define cycle check</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addFragToFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">child</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">child</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">avoid frag cycles</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">reuse last entry</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">add frag entry</span>)</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Bevor ein Fragment hinzugefügt werden kann, muss sichergestellt werden,
  dass kein Zykel entsteht
</li><li>
 Ein Zykel liegt vor, wenn <code>frag</code> gleich <code>child</code> ist
</li><li>
 Oder bereits direkt oder indirekt zu <code>child</code> hinzugefügt wurde
</li><li>
 Falls der letzte Eintrag noch kein Fragment hat, wird dieser Eintrag
  verwendet
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">reuse last entry</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>-&gt;<span class="var">firstEntry</span> &amp;&amp;<br/>

<span class="in2"></span>! <span class="var">frag</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">frag</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="var">frag</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">frag</span> = <span class="var">child</span>;<br/>

<span class="in2"></span><span class="keyword">return</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">reuse last entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn das Fragment-Attribut im letzten Eintrag noch nicht benutzt wird,
  kann dieses verwendet werden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">add frag entry</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in2"></span><span class="fn">allocFragEntry</span>(<br/>

<span class="in3"></span><span class="var">child</span>, <span class="num">nullptr</span>, <span class="num">nullptr</span><br/>

<span class="in2"></span>);<br/>

<span class="in1"></span><span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">entry</span>);<br/>

<span class="end">@end(<span class="name">add frag entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Sonst muss ein neuer Eintrag in dem Fragment angelegt werden
</li></ul></div>

</div>
<h1>Fragmente serialisieren</h1>
<div class="slides">
<div><div>
<h1>Fragmente serialisieren</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">serialize test defines</span>)</span>;<br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">serializeFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">FILE</span> *<span class="var">out</span>,<br/>

<span class="in2"></span><span class="type">bool</span> <span class="var">writeLineMacros</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">out</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">iterate entries</span>)</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Jeder Eintrag wird nacheinander bearbeitet
</li><li>
 Fragmente in Einträgen werden rekursiv ausgegeben
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">iterate entries</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in2"></span><span class="var">frag</span>-&gt;<span class="var">firstEntry</span>;<br/>

<span class="in1"></span><span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">serialize bytes</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">entry</span>-&gt;<span class="var">frag</span>) {<br/>

<span class="in3"></span><span class="fn">serializeFrag</span>(<br/>

<span class="in4"></span><span class="var">entry</span>-&gt;<span class="var">frag</span>, <span class="var">out</span>,<br/>

<span class="var">writeLineMacros</span><br/>

<span class="in7"></span>);<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">iterate entries</span>)</span><br/>

</code>
</div>

<ul><li>
 Für jeden Eintrag werden zuerst die Bytes ausgegeben
</li><li>
 Dann wird rekursiv das Fragment ausgegeben, falls vorhanden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">serialize test defines</span>)</span><br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> *<span class="var">fragTestBufferCur</span> = <span class="num">nullptr</span>;<br/>

<span class="end">@end(<span class="name">serialize test defines</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize bytes</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="fn">getFragEntryValueSize</span>(<span class="var">entry</span>)) {<br/>

<span class="in2"></span><span class="keyword">if</span> (! <span class="var">fragTestBufferCur</span>) {<br/>

<span class="in3"></span><span class="fn">ASSERT</span>(<span class="fn">fwrite</span>(<br/>

<span class="in4"></span><span class="var">entry</span>-&gt;<span class="var">value</span>.<span class="fn">data</span>(), <span class="num">1</span>, <span class="var">entry</span>-&gt;<span class="var">value</span>.<span class="fn">size</span>(),<br/>

<span class="var">out</span><br/>

<span class="in7"></span>) == <span class="var">entry</span>-&gt;<span class="var">value</span>.<span class="fn">size</span>());<br/>

<span class="in2"></span>} <span class="keyword">else</span> {<br/>

<span class="in3"></span>*<span class="var">fragTestBufferCur</span> += <span class="var">entry</span>-&gt;<span class="var">value</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">serialize bytes</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn es Bytes in dem Eintrag gibt, wird der <code>consumer</code> mit ihnen
  aufgerufen
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">testFrag</span>(<span class="type">struct</span> <span class="type">Frag</span> *<br/>

<span class="in2"></span><span class="var">frag</span>, <span class="type">const</span> <span class="type">char</span> *<span class="var">expected</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">serialize test frag</span>)</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Diese Hilfsfunktion prüft ob die Serialisierung eines Fragments der
  Erwartung entspricht
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">serialize test frag</span>)</span><br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">buffer</span>;<br/>

<span class="in1"></span><span class="var">fragTestBufferCur</span> = &amp;<span class="var">buffer</span>;<br/>

<span class="in1"></span><span class="fn">serializeFrag</span>(<span class="var">frag</span>, (<span class="type">FILE</span> *) &amp;<span class="var">buffer</span>, <span class="num">false</span>);<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">buffer</span> == <span class="var">expected</span>);<br/>

<span class="in1"></span><span class="var">fragTestBufferCur</span> = <span class="num">nullptr</span>;<br/>

<span class="end">@end(<span class="name">serialize test frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Serialisiert das Fragment
</li><li>
 Der Buffer muss die erwarteten Werte enthalten
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addStringToFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">str</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">size</span> = <span class="fn">strlen</span>(<span class="var">str</span>);<br/>

<span class="in2"></span><span class="fn">addBytesToFrag</span>(<br/>

<span class="in3"></span><span class="var">frag</span>, <span class="var">str</span>, <span class="var">str</span> + <span class="var">size</span>,<br/>

<span class="in3"></span><span class="var">std</span>::<span class="fn">string</span>(), <span class="num">0</span><br/>

<span class="in2"></span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Zu Testzwecken kann eine Null-terminierte Zeichenkette hinzugefügt
  werden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>

<span class="in2"></span><span class="fn">addStringToFrag</span>(<span class="var">frag</span>, <span class="str">"abc"</span>);<br/>

<span class="in2"></span><span class="fn">addStringToFrag</span>(<span class="var">frag</span>, <span class="str">"def"</span>);<br/>

<span class="in2"></span><span class="fn">testFrag</span>(<span class="var">frag</span>, <span class="str">"abcdef"</span>);<br/>

<span class="in2"></span><span class="fn">freeFrag</span>(<span class="var">frag</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Prüft, ob zwei Strings richtig serialisiert werden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span> {<br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">a</span> =<br/>

<span class="in2"></span><span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">b</span> =<br/>

<span class="in2"></span><span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="fn">addStringToFrag</span>(<span class="var">a</span>, <span class="str">"abc"</span>);<br/>

<span class="in1"></span><span class="fn">addFragToFrag</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>

<span class="in1"></span><span class="fn">addStringToFrag</span>(<span class="var">b</span>, <span class="str">"def"</span>);<br/>

<span class="in1"></span><span class="fn">addFragToFrag</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>

<span class="in1"></span><span class="fn">testFrag</span>(<span class="var">b</span>, <span class="str">"abcdefabc"</span>);<br/>

<span class="in1"></span><span class="fn">freeFrag</span>(<span class="var">a</span>); <span class="fn">freeFrag</span>(<span class="var">b</span>);<br/>

} <span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Prüft, ob Fragmente expandiert werden
</li></ul></div>

</div>
<h1>Zykel im Fragment-Graph finden</h1>
<div class="slides">
<div><div>
<h1>Zykel im Fragment-Graph finden</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">define cycle check</span>)</span><br/>

<span class="in1"></span><span class="type">bool</span> <span class="fn">isFragInFrag</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">needle</span>,<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">haystack</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">needle</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">haystack</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">check cycle frag</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">check cycle entries</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define cycle check</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn das Fragment das gesuchte ist, dann wurde ein Zykel gefunden
</li><li>
 Danach wird über alle Einträge gesucht
</li><li>
 Wenn das Fragment dort nicht gefunden wurde, dann ist es nicht
  enthalten
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">avoid frag cycles</span>)</span><br/>

<span class="in1"></span><span class="fn">ASSERT</span>(! <span class="fn">isFragInFrag</span>(<br/>

<span class="in2"></span><span class="var">frag</span>, <span class="var">child</span><br/>

<span class="in1"></span>));<br/>

<span class="end">@end(<span class="name">avoid frag cycles</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Fragment darf nur hinzugefügt werden, wenn es den Container nicht
  bereits enthält
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">check cycle frag</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">needle</span> == <span class="var">haystack</span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">check cycle frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn der Container selbst das gesuchte Fragment ist, liefert die
  Funktion <code>true</code> zurück
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">check cycle entries</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in2"></span><span class="var">haystack</span>-&gt;<span class="var">firstEntry</span>;<br/>

<span class="in1"></span><span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>

<span class="in2"></span><span class="keyword">if</span> (! <span class="var">entry</span>-&gt;<span class="var">frag</span>) { <span class="keyword">continue</span>; }<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isFragInFrag</span>(<br/>

<span class="in3"></span><span class="var">needle</span>, <span class="var">entry</span>-&gt;<span class="var">frag</span><br/>

<span class="in2"></span>)) {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">check cycle entries</span>)</span><br/>

</code>
</div>

<ul><li>
 Alle Fragment in den Einträgen werden rekursiv untersucht
</li><li>
 Damit wird der ganze Graph durchsucht
</li></ul></div>

</div>
<h1>Fragment-Kollektion</h1>
<div class="slides">
<div><div>
<h1>Fragment-Kollektion</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span>#<span class="var">define</span> <span class="var">FRAG_SLOTS</span> <span class="num">128</span><br/>

<br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragMap</span> {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragMap</span> *<span class="var">link</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frags</span>[<br/>

<span class="var">FRAG_SLOTS</span><br/>

<span class="in5"></span>];<br/>

<span class="in1"></span>};<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Eine Kollektion von Fragmenten ist ein Array von Fragment-Ketten
</li><li>
 Alle Felder müssen mit <code>nullptr</code> initialisiert werden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">clearFragMap</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragMap</span> *<span class="var">map</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> **<span class="var">cur</span> = <span class="var">map</span>-&gt;<span class="var">frags</span>;<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> **<span class="var">end</span> =<br/>

<span class="in3"></span><span class="var">cur</span> + <span class="var">FRAG_SLOTS</span>;<br/>

<span class="in2"></span><span class="keyword">for</span> (; <span class="var">cur</span> &lt; <span class="var">end</span>; ++<span class="var">cur</span>) {<br/>

<span class="in3"></span><span class="fn">freeFrag</span>(*<span class="var">cur</span>); *<span class="var">cur</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in2"></span><span class="var">map</span>-&gt;<span class="var">link</span> = <span class="num">nullptr</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Um den Speicher freizugeben, wird jeder Slot gelöscht
</li><li>
 und auf <code>nullptr</code> gesetzt um wieder verwendet
  zu werden
</li><li>
 Wenn es einen Link auf ein andere Map gibt, wird diese zurückgesetzt
</li><li>
 Die referenzierte Map wird jedoch nicht gelöscht
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">int</span> <span class="fn">calcFragHash</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">begin</span>, <span class="type">const</span> <span class="type">char</span> *<span class="var">end</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">hash</span> % <span class="var">FRAG_SLOTS</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Der Hash wird über den Namen des Fragments erstellt
</li><li>
 Und auf die Anzahl der möglichen Slots beschränkt
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="fn">allocFragInMap</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragMap</span> *<span class="var">map</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">begin</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">end</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span> =<br/>

<span class="in3"></span><span class="fn">allocFrag</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">insert in slot</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">frag</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein neues Fragment wird erstellt
</li><li>
 Und in der Hash-Map abgelegt
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">insert in slot</span>)</span><br/>

<span class="in1"></span><span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcFragHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>

<span class="in1"></span><span class="var">frag</span>-&gt;<span class="var">link</span> = <span class="var">map</span>-&gt;<span class="var">frags</span>[<span class="var">hash</span>];<br/>

<span class="in1"></span><span class="var">map</span>-&gt;<span class="var">frags</span>[<span class="var">hash</span>] = <span class="var">frag</span>;<br/>

<span class="end">@end(<span class="name">insert in slot</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragment wird im Slot eingefügt
</li><li>
 Neue Fragmente überlagern alte Fragmente mit gleichem Namen
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="fn">findFragInMap</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragMap</span> *<span class="var">map</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">begin</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">end</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">find frag in slot</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">find frag in linked map</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="num">nullptr</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Liefert das erste Fragment mit dem übergebenen Namen
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">find frag in slot</span>)</span> {<br/>

<span class="in1"></span><span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcFragHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span> = <span class="var">map</span>-&gt;<span class="var">frags</span>[<span class="var">hash</span>];<br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> <span class="fn">s</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>

<span class="in1"></span><span class="keyword">for</span> (; <span class="var">frag</span>; <span class="var">frag</span> = <span class="var">frag</span>-&gt;<span class="var">link</span>) {<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">s</span> == <span class="var">frag</span>-&gt;<span class="var">name</span>) {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="var">frag</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

} <span class="end">@end(<span class="name">find frag in slot</span>)</span><br/>

</code>
</div>

<ul><li>
 Im passenden Hash-Slot werden die Namen der Fragmente verglichen
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">find frag in linked map</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">map</span>-&gt;<span class="var">link</span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="fn">findFragInMap</span>(<br/>

<span class="in3"></span><span class="var">map</span>-&gt;<span class="var">link</span>, <span class="var">begin</span>, <span class="var">end</span><br/>

<span class="in2"></span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">find frag in linked map</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn es einen verlinkten Kontext gibt, so kann das Element auch in
  diesem liegen
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="fn">getFragInMap</span>(<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragMap</span> *<span class="var">map</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">begin</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">char</span> *<span class="var">end</span>,<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">FragMap</span> *<span class="var">insert</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">struct</span> <span class="type">Frag</span> *<span class="var">frag</span> = <span class="num">nullptr</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">get frag find</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">get frag alloc</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">frag</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Liefert Fragment mit angegebenen Namen oder legt ein neues Fragment
  mit diesem Namen an
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">get frag find</span>)</span><br/>

<span class="in1"></span><span class="var">frag</span> = <span class="fn">findFragInMap</span>(<br/>

<span class="in2"></span><span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>

<span class="in1"></span>);<br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">frag</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">get frag find</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn das Fragment in der Kollektion vorhanden ist, wird dieses
  verwendet
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">get frag alloc</span>)</span><br/>

<span class="in1"></span><span class="var">frag</span> = <span class="fn">allocFragInMap</span>(<br/>

<span class="in2"></span><span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>

<span class="in1"></span>);<br/>

<span class="end">@end(<span class="name">get frag alloc</span>)</span><br/>

</code>
</div>

<ul><li>
 Sonst wird ein neues Fragment angelegt
</li></ul></div>

</div>
<h1>Position im Original merken</h1>
<div class="slides">
<div><div>
<h1>Position im Original merken</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">additional entry attributes</span>)</span><br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">source</span>;<br/>

<span class="in1"></span><span class="type">int</span> <span class="var">line</span>;<br/>

<span class="end">@end(<span class="name">additional entry attributes</span>)</span><br/>

</code>
</div>

<ul><li>
 Jedes Fragment hält einen Zeiger auf die Datei aus der das Fragment
  generiert wurde
</li><li>
 Und die Zeile in dieser Datei
</li><li>
 So kann durch spezielle <code>#line</code> Makros im generierten Source-Code auf
  die ursprüngliche Datei verwiesen werden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">populate additional entry fields</span>)</span><br/>

<span class="in1"></span><span class="var">entry</span>-&gt;<span class="var">source</span> = <span class="var">source</span>;<br/>

<span class="in1"></span><span class="var">entry</span>-&gt;<span class="var">line</span> = <span class="var">line</span>;<br/>

<span class="end">@end(<span class="name">populate additional entry fields</span>)</span><br/>

</code>
</div>

