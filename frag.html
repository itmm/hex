<!doctype html>
<html lang="de"l>
<head>
<meta charset="utf-8">
<title>Fragmente</title><link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>Fragmente</h1>
<div class="slides">
<div><div>
<h1>Fragmente</h1>
</div>

<ul><li>
 Fragmente bilden einen gerichteten azyklischen Graph
</li><li>
 Die Infix-Traversierung dieses Graphen bildet die generierten
  Source-Code Dateien
</li></ul></div>

<div><div>
<code>

<span class="include">@include(<span class="name"><a href="hash.html">hash.x</a>)</span></span><br/>

</code>
</div>

<ul><li>
 Hash-Funktion wird benötigt
</li><li>
 Und in der Datei als <code>calcHash</code> definiiert
</li></ul></div>

<div><div>
<code>

<span class="add">@globadd(<span class="name">global elements</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">define frag</span>)</span>;<br/>

<span class="end">@end(<span class="name">global elements</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragmente sind global sichtbare Strukturen
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span>;<br/>

<br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragEntry</span> {<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>;<br/>

<span class="in2"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">value</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">additional entry attributes</span>)</span>;<br/>

<span class="in2"></span><span class="fn">FragEntry</span>(): <span class="fn">frag</span>(<span class="num">nullptr</span>) {}<br/>

<span class="in1"></span>};<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Eintrag kann entweder auf ein anderes Fragment verweisen (wenn
  dieses an der aktuellen Stelle expandiert werden soll)
</li><li>
 Oder er enthält Bytes, die beim Expandieren direkt expandiert werden
</li><li>
 Die Länge des Byte-Arrays wird über einen Zeiger angezeigt (damit auch
  Null-Bytes verwendet werden können)
</li><li>
 Wenn ein Eintrag sowohl Daten als auch ein Fragment enthält, so wird
  zuerst der Text ausgegeben
</li></ul></div>

<div><div>
<code>

<span class="add">@globadd(<span class="name">includes</span>)</span><br/>

<span class="in1"></span>#<span class="var">include</span> &lt;<span class="var">list</span>&gt;<br/>

<span class="in1"></span>#<span class="var">include</span> &lt;<span class="var">map</span>&gt;<br/>

<span class="end">@end(<span class="name">includes</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">Frag</span> {<br/>

<span class="in2"></span><span class="var">std</span>::<span class="var">list</span>&lt;<span class="type">FragEntry</span> *&gt; <span class="var">entries</span>;<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">expands</span>;<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">multiples</span>;<br/>

<span class="in2"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">name</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">frag methods</span>)</span>;<br/>

<span class="in1"></span>};<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragmente erden in einfach verketteten Listen gesammelt
</li><li>
 Genauso werden die Einträge eines Fragments in einer einfach
  verketteten Liste organisiert
</li><li>
 Um schnell Einträge einfügen zu können, gibt es auch einen Verweis auf
  das letzte Element
</li><li>
 Je nach Namen werden für ein Fragment unterschiedlich viele Bytes im
  Heap angefordert
</li></ul></div>

</div>
<h1>Neues Fragment anlegen</h1>
<div class="slides">
<div><div>
<h1>Neues Fragment anlegen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">frag methods</span>)</span><br/>

<span class="in1"></span><span class="fn">Frag</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span><br/>

<span class="in1"></span>):<br/>

<span class="in2"></span><span class="fn">entries</span>(),<br/>

<span class="in2"></span><span class="fn">expands</span>(<span class="num">0</span>),<br/>

<span class="in2"></span><span class="fn">multiples</span>(<span class="num">0</span>),<br/>

<span class="in2"></span><span class="fn">name</span>(<span class="var">name</span>)<br/>

<span class="in1"></span>{ }<br/>

<span class="end">@end(<span class="name">frag methods</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Zeiger werden mit <code>nullptr</code> initialisiert
</li></ul></div>

<div><div>
<code>

<span class="add">@globdef(<span class="name">define logging</span>)</span><br/>

<span class="in1"></span>#<span class="var">define</span> <span class="fn">ASSERT</span>(<span class="var">COND</span>, ...) \<br/>

<span class="in2"></span><span class="keyword">if</span> (! (<span class="var">COND</span>)) { \<br/>

<span class="in3"></span><span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>

<span class="in4"></span><span class="str">"%s:%d"</span>, \<br/>

<span class="in4"></span><span class="var">__FILE__</span>, <span class="var">__LINE__</span>); \<br/>

<span class="in3"></span><span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>

<span class="in4"></span><span class="str">" FAILED: "</span> <span class="var">__VA_ARGS__</span>); \<br/>

<span class="in3"></span><span class="fn">fprintf</span>(<span class="var">stderr</span>, <span class="str">"\n"</span>); \<br/>

<span class="in3"></span><span class="fn">exit</span>(<span class="var">EXIT_FAILURE</span>); \<br/>

<span class="in2"></span>}<br/>

<span class="end">@end(<span class="name">define logging</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn Bedingung falsch ist, wird Fehlermeldung ausgegeben
</li><li>
 Und das Programm beendet
</li><li>
 Datei und Zeile des Tests wird ausgegeben
</li></ul></div>

<div><div>
<code>

<span class="add">@globadd(<span class="name">includes</span>)</span><br/>

<span class="in1"></span>#<span class="var">include</span> &lt;<span class="var">string</span>.<span class="var">h</span>&gt;<br/>

<span class="end">@end(<span class="name">includes</span>)</span><br/>

<br/>

# <span class="type">Fragmente</span> <span class="var">freigeben</span><br/>

<br/>

</code>
</div>

a{define frag}
	void freeFragEntries(
		Frag *frag
	) {
		if (frag) {
			frag-&gt;entries.clear();
		}
	}
x{define frag}
</div>
<div><div>
<code>

<br/>

# <span class="type">Unit</span> <span class="type">Tests</span><br/>

<br/>

</code>
</div>

D{perform unit-tests}
	e{frag unit tests};
x{perform unit-tests}

</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">testFragName</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">Frag</span> <span class="fn">f</span>(<span class="var">name</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>.<span class="var">name</span> == <span class="var">name</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 <code>testFragName</code> prüft, ob der Name korrekt in ein Fragment kopiert
  wurde
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">"abc"</span>);<br/>

<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="fn">testFragName</span>(<span class="str">"A c"</span>);<br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">Frag</span> <span class="fn">f</span>(<span class="str">"ab"</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">f</span>.<span class="var">entries</span>.<span class="fn">empty</span>());<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Zum einen wird getestet, ob die Namen korrekt kopiert werden
</li><li>
 Zum anderen wird sichergestellt, dass die Verweise <code>nullptr</code> sind
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">bool</span> <span class="fn">isPopulatedFrag</span>(<br/>

<span class="in2"></span><span class="type">const</span> <span class="type">Frag</span> *<span class="var">f</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">f</span> &amp;&amp; <span class="var">f</span>-&gt;<span class="var">entries</span>.<span class="fn">size</span>();<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>


</div>
</div>
<h1>Fragment-Eintrag anlegen</h1>
<div class="slides">
<div><div>
<h1>Fragment-Eintrag anlegen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">FragEntry</span> *<span class="fn">allocFragEntry</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">value</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">result</span> = <span class="keyword">new</span> <span class="fn">FragEntry</span>();<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">frag</span> = <span class="var">frag</span>;<br/>

<span class="in2"></span><span class="var">result</span>-&gt;<span class="var">value</span> = <span class="var">value</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Sowohl <code>frag</code> als auch <code>value</code> sind optional
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">FragEntry</span> *<br/>

<span class="in2"></span><span class="fn">allocEmptyFragEntry</span>() {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="fn">allocFragEntry</span>(<br/>

<span class="in4"></span><span class="num">nullptr</span>, <span class="var">std</span>::<span class="fn">string</span>()<br/>

<span class="in3"></span>);<br/>

<span class="in2"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Für Tests ist es praktisch, leere Einträge anzulegen
</li></ul></div>

</div>
<h1>Auf Attribute zugreifen</h1>
<div class="slides">
<div><div>
<h1>Auf Attribute zugreifen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">int</span> <span class="fn">getFragEntryValueSize</span>(<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">e</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">if</span> (! <span class="var">e</span>) { <span class="keyword">return</span> <span class="num">0</span>; }<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">e</span>-&gt;<span class="var">value</span>.<span class="fn">size</span>();<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Liefert die Anzahl der enthaltenen Bytes
</li></ul></div>

</div>
<h1>Unit Tests</h1>
<div class="slides">
<div><div>
<h1>Unit Tests</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">frag</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">delete</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein leerer Eintrag hat keinen Nachfolger
</li><li>
 Und kein Fragment
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="fn">getFragEntryValueSize</span>(<br/>

<span class="in4"></span><span class="var">entry</span>) == <span class="num">0</span><br/>

<span class="in2"></span>);<br/>

<br/>

<span class="in2"></span><span class="fn">delete</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein leerer Eintrag hat keine Bytes
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">FragEntry</span> *<br/>

<span class="in2"></span><span class="fn">allocTestFragEntry</span>(<br/>

<span class="in3"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">s</span><br/>

<span class="in2"></span>) {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="fn">allocFragEntry</span>(<br/>

<span class="in4"></span><span class="num">nullptr</span>, <span class="var">s</span><br/>

<span class="in3"></span>);<br/>

<span class="in2"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Der Test-Konstruktor bekommt eine Null-terminierte Zeichenkette als
  Argument
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFragEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<br/>

<span class="in3"></span><span class="fn">getFragEntryValueSize</span>(<br/>

<span class="in4"></span><span class="var">entry</span>) == <span class="num">3</span><br/>

<span class="in2"></span>);<br/>

<br/>

<span class="in2"></span><span class="fn">delete</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Eintrag hat die korrekte Anzahl an Bytes
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span><br/>

<span class="in1"></span>{<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocTestFragEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>-&gt;<span class="var">value</span> == <span class="str">"abc"</span>);<br/>

<br/>

<span class="in2"></span><span class="fn">delete</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Die Bytes eines Eintrags stimmen überein
</li></ul></div>

</div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
<div class="slides">
<div><div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addEntryToFrag</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">entry</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">assert add entry</span>)</span>;<br/>

<span class="in2"></span><span class="var">frag</span>-&gt;<span class="var">entries</span>.<span class="fn">push_back</span>(<span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Eintrag wird entweder an das Ende der Liste der Einträge angehängt
</li><li>
 Oder als neuer Kopf der Liste gesetzt
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">assert add entry</span>)</span><br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>

<span class="end">@end(<span class="name">assert add entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Fragment darf nicht <code>nullptr</code> sein
</li><li>
 Eintrag darf nicht <code>nullptr</code> sein
</li><li>
 Eintrag darf noch nicht in einer anderen Liste hängen
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addBytesToFrag</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">value</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">source</span>,<br/>

<span class="in2"></span><span class="type">int</span> <span class="var">line</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in3"></span><span class="fn">allocFragEntry</span>(<span class="num">nullptr</span>, <span class="var">value</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">populate additional entry fields</span>)</span>;<br/>

<span class="in2"></span><span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">entry</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Für die Daten wird ein neuer Eintrag angelegt
</li><li>
 Dieser wird an das Fragment angehängt
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">define cycle check</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addFragToFrag</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">child</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">child</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">avoid frag cycles</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">reuse last entry</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">add frag entry</span>)</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Bevor ein Fragment hinzugefügt werden kann, muss sichergestellt werden,
  dass kein Zykel entsteht
</li><li>
 Ein Zykel liegt vor, wenn <code>frag</code> gleich <code>child</code> ist
</li><li>
 Oder bereits direkt oder indirekt zu <code>child</code> hinzugefügt wurde
</li><li>
 Falls der letzte Eintrag noch kein Fragment hat, wird dieser Eintrag
  verwendet
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">reuse last entry</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (! <span class="var">frag</span>-&gt;<span class="var">entries</span>.<span class="fn">empty</span>() &amp;&amp;<br/>

<span class="in2"></span>! <span class="var">frag</span>-&gt;<span class="var">entries</span>.<span class="fn">back</span>()-&gt;<span class="var">frag</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="var">frag</span>-&gt;<span class="var">entries</span>.<span class="fn">back</span>()-&gt;<span class="var">frag</span> = <span class="var">child</span>;<br/>

<span class="in2"></span><span class="keyword">return</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">reuse last entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn das Fragment-Attribut im letzten Eintrag noch nicht benutzt wird,
  kann dieses verwendet werden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">add frag entry</span>)</span><br/>

<span class="in1"></span><span class="type">FragEntry</span> *<span class="var">entry</span> =<br/>

<span class="in2"></span><span class="fn">allocFragEntry</span>(<span class="var">child</span>, <span class="var">std</span>::<span class="fn">string</span>());<br/>

<span class="in1"></span><span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">entry</span>);<br/>

<span class="end">@end(<span class="name">add frag entry</span>)</span><br/>

</code>
</div>

<ul><li>
 Sonst muss ein neuer Eintrag in dem Fragment angelegt werden
</li></ul></div>

</div>
<h1>Fragmente serialisieren</h1>
<div class="slides">
<div><div>
<h1>Fragmente serialisieren</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="expand">@expand(<span class="name">serialize test defines</span>)</span>;<br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">serializeFrag</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">FILE</span> *<span class="var">out</span>,<br/>

<span class="in2"></span><span class="type">bool</span> <span class="var">writeLineMacros</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">out</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">iterate entries</span>)</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Jeder Eintrag wird nacheinander bearbeitet
</li><li>
 Fragmente in Einträgen werden rekursiv ausgegeben
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">iterate entries</span>)</span><br/>

<span class="in1"></span><span class="var">auto</span> <span class="var">entry</span> = <span class="var">frag</span>-&gt;<span class="var">entries</span>.<span class="fn">begin</span>();<br/>

<span class="in1"></span><span class="keyword">for</span> (; <span class="var">entry</span> != <span class="var">frag</span>-&gt;<span class="var">entries</span>.<span class="fn">end</span>(); ++<span class="var">entry</span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">serialize bytes</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">if</span> ((*<span class="var">entry</span>)-&gt;<span class="var">frag</span>) {<br/>

<span class="in3"></span><span class="fn">serializeFrag</span>(<br/>

<span class="in4"></span>(*<span class="var">entry</span>)-&gt;<span class="var">frag</span>, <span class="var">out</span>,<br/>

<span class="var">writeLineMacros</span><br/>

<span class="in7"></span>);<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">iterate entries</span>)</span><br/>

</code>
</div>

<ul><li>
 Für jeden Eintrag werden zuerst die Bytes ausgegeben
</li><li>
 Dann wird rekursiv das Fragment ausgegeben, falls vorhanden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">serialize test defines</span>)</span><br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> *<span class="var">fragTestBufferCur</span> = <span class="num">nullptr</span>;<br/>

<span class="end">@end(<span class="name">serialize test defines</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize bytes</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="fn">getFragEntryValueSize</span>(*<span class="var">entry</span>)) {<br/>

<span class="in2"></span><span class="keyword">if</span> (! <span class="var">fragTestBufferCur</span>) {<br/>

<span class="in3"></span><span class="fn">ASSERT</span>(<span class="fn">fwrite</span>(<br/>

<span class="in4"></span>(*<span class="var">entry</span>)-&gt;<span class="var">value</span>.<span class="fn">data</span>(), <span class="num">1</span>, (*<span class="var">entry</span>)-&gt;<span class="var">value</span>.<span class="fn">size</span>(),<br/>

<span class="var">out</span><br/>

<span class="in7"></span>) == (*<span class="var">entry</span>)-&gt;<span class="var">value</span>.<span class="fn">size</span>());<br/>

<span class="in2"></span>} <span class="keyword">else</span> {<br/>

<span class="in3"></span>*<span class="var">fragTestBufferCur</span> += (*<span class="var">entry</span>)-&gt;<span class="var">value</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">serialize bytes</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn es Bytes in dem Eintrag gibt, wird der <code>consumer</code> mit ihnen
  aufgerufen
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">testFrag</span>(<span class="type">Frag</span> *<br/>

<span class="in2"></span><span class="var">frag</span>, <span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">expected</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">serialize test frag</span>)</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Diese Hilfsfunktion prüft ob die Serialisierung eines Fragments der
  Erwartung entspricht
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">serialize test frag</span>)</span><br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">buffer</span>;<br/>

<span class="in1"></span><span class="var">fragTestBufferCur</span> = &amp;<span class="var">buffer</span>;<br/>

<span class="in1"></span><span class="fn">serializeFrag</span>(<span class="var">frag</span>, (<span class="type">FILE</span> *) &amp;<span class="var">buffer</span>, <span class="num">false</span>);<br/>

<span class="in1"></span><span class="fn">ASSERT</span>(<span class="var">buffer</span> == <span class="var">expected</span>);<br/>

<span class="in1"></span><span class="var">fragTestBufferCur</span> = <span class="num">nullptr</span>;<br/>

<span class="end">@end(<span class="name">serialize test frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Serialisiert das Fragment
</li><li>
 Der Buffer muss die erwarteten Werte enthalten
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">void</span> <span class="fn">addStringToFrag</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">frag</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">str</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">addBytesToFrag</span>(<br/>

<span class="in3"></span><span class="var">frag</span>, <span class="var">str</span>, <span class="var">std</span>::<span class="fn">string</span>(), <span class="num">0</span><br/>

<span class="in2"></span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Zu Testzwecken kann eine Null-terminierte Zeichenkette hinzugefügt
  werden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span> {<br/>

<span class="in1"></span><span class="type">Frag</span> <span class="fn">frag</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">frag</span>, <span class="str">"abc"</span>);<br/>

<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">frag</span>, <span class="str">"def"</span>);<br/>

<span class="in1"></span><span class="fn">testFrag</span>(&amp;<span class="var">frag</span>, <span class="str">"abcdef"</span>);<br/>

} <span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Prüft, ob zwei Strings richtig serialisiert werden
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests</span>)</span> {<br/>

<span class="in1"></span><span class="type">Frag</span> <span class="fn">a</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="type">Frag</span> <span class="fn">b</span>(<span class="str">""</span>);<br/>

<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">a</span>, <span class="str">"abc"</span>);<br/>

<span class="in1"></span><span class="fn">addFragToFrag</span>(&amp;<span class="var">b</span>, &amp;<span class="var">a</span>);<br/>

<span class="in1"></span><span class="fn">addStringToFrag</span>(&amp;<span class="var">b</span>, <span class="str">"def"</span>);<br/>

<span class="in1"></span><span class="fn">addFragToFrag</span>(&amp;<span class="var">b</span>, &amp;<span class="var">a</span>);<br/>

<span class="in1"></span><span class="fn">testFrag</span>(&amp;<span class="var">b</span>, <span class="str">"abcdefabc"</span>);<br/>

} <span class="end">@end(<span class="name">frag unit tests</span>)</span><br/>

</code>
</div>

<ul><li>
 Prüft, ob Fragmente expandiert werden
</li></ul></div>

</div>
<h1>Zykel im Fragment-Graph finden</h1>
<div class="slides">
<div><div>
<h1>Zykel im Fragment-Graph finden</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">define cycle check</span>)</span><br/>

<span class="in1"></span><span class="type">bool</span> <span class="fn">isFragInFrag</span>(<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">needle</span>, <span class="type">Frag</span> *<span class="var">haystack</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">needle</span>);<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">haystack</span>);<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">check cycle frag</span>)</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">check cycle entries</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="num">false</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define cycle check</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn das Fragment das gesuchte ist, dann wurde ein Zykel gefunden
</li><li>
 Danach wird über alle Einträge gesucht
</li><li>
 Wenn das Fragment dort nicht gefunden wurde, dann ist es nicht
  enthalten
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">avoid frag cycles</span>)</span><br/>

<span class="in1"></span><span class="fn">ASSERT</span>(! <span class="fn">isFragInFrag</span>(<br/>

<span class="in2"></span><span class="var">frag</span>, <span class="var">child</span><br/>

<span class="in1"></span>));<br/>

<span class="end">@end(<span class="name">avoid frag cycles</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein Fragment darf nur hinzugefügt werden, wenn es den Container nicht
  bereits enthält
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">check cycle frag</span>)</span><br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">needle</span> == <span class="var">haystack</span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">check cycle frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn der Container selbst das gesuchte Fragment ist, liefert die
  Funktion <code>true</code> zurück
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">check cycle entries</span>)</span><br/>

<span class="in1"></span><span class="keyword">for</span> (<br/>

<span class="in2"></span><span class="var">auto</span> <span class="var">i</span> = <span class="var">haystack</span>-&gt;<span class="var">entries</span>.<span class="fn">begin</span>();<br/>

<span class="in2"></span><span class="var">i</span> != <span class="var">haystack</span>-&gt;<span class="var">entries</span>.<span class="fn">end</span>(); ++<span class="var">i</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="keyword">if</span> (! (*<span class="var">i</span>)-&gt;<span class="var">frag</span>) { <span class="keyword">continue</span>; }<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="fn">isFragInFrag</span>(<br/>

<span class="in3"></span><span class="var">needle</span>, (*<span class="var">i</span>)-&gt;<span class="var">frag</span><br/>

<span class="in2"></span>)) {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="num">true</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">check cycle entries</span>)</span><br/>

</code>
</div>

<ul><li>
 Alle Fragment in den Einträgen werden rekursiv untersucht
</li><li>
 Damit wird der ganze Graph durchsucht
</li></ul></div>

</div>
<h1>Fragment-Kollektion</h1>
<div class="slides">
<div><div>
<h1>Fragment-Kollektion</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">struct</span> <span class="type">FragMap</span> {<br/>

<span class="in2"></span><span class="type">FragMap</span> *<span class="var">link</span>;<br/>

<span class="in2"></span><span class="var">std</span>::<span class="var">map</span>&lt;<span class="var">std</span>::<span class="var">string</span>, <span class="type">Frag</span>&gt; <span class="var">map</span>;<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">frag map methods</span>)</span>;<br/>

<span class="in1"></span>};<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Eine Kollektion von Fragmenten ist ein Array von Fragment-Ketten
</li><li>
 Alle Felder müssen mit <code>nullptr</code> initialisiert werden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">frag map methods</span>)</span><br/>

<span class="in1"></span><span class="fn">FragMap</span>(): <span class="fn">link</span>(<span class="num">nullptr</span>) {}<br/>

<span class="end">@end(<span class="name">frag map methods</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag map methods</span>)</span><br/>

<span class="in1"></span><span class="type">Frag</span> *<span class="fn">find</span>(<span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span>) {<br/>

<span class="in2"></span><span class="var">auto</span> <span class="var">found</span> = <span class="var">map</span>.<span class="fn">find</span>(<span class="var">name</span>);<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">found</span> != <span class="var">map</span>.<span class="fn">end</span>()) {<br/>

<span class="in3"></span><span class="keyword">return</span> &amp;<span class="var">found</span>-&gt;<span class="var">second</span>;<br/>

<span class="in2"></span>}<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">link</span>) {<br/>

<span class="in3"></span><span class="keyword">return</span> <span class="var">link</span>-&gt;<span class="fn">find</span>(<span class="var">name</span>);<br/>

<span class="in2"></span>}<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="num">nullptr</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag map methods</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag map methods</span>)</span><br/>

<span class="in1"></span><span class="type">Frag</span> &amp;<span class="fn">get</span>(<span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span>, <span class="type">FragMap</span> *<span class="var">insert</span> = <span class="num">nullptr</span>) {<br/>

<span class="in2"></span><span class="type">Frag</span> *<span class="var">found</span> = <span class="fn">find</span>(<span class="var">name</span>);<br/>

<span class="in2"></span><span class="keyword">if</span> (<span class="var">found</span>) { <span class="keyword">return</span> *<span class="var">found</span>; }<br/>

<span class="in2"></span><span class="var">insert</span> = <span class="var">insert</span> ?: <span class="var">this</span>;<br/>

<span class="in2"></span><span class="var">auto</span> <span class="var">created</span> = <span class="var">insert</span>-&gt;<span class="var">map</span>.<span class="fn">insert</span>(<br/>

<span class="in3"></span><span class="var">std</span>::<span class="var">pair</span>&lt;<span class="var">std</span>::<span class="var">string</span>, <span class="type">Frag</span>&gt;(<span class="var">name</span>, <span class="var">name</span>)<br/>

<span class="in2"></span>);<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">created</span>.<span class="var">first</span>-&gt;<span class="var">second</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag map methods</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag map methods</span>)</span><br/>

<span class="in1"></span><span class="type">Frag</span> &amp;<span class="var">operator</span>[](<span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="fn">get</span>(<span class="var">name</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">frag map methods</span>)</span><br/>

</code>
</div>


</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">Frag</span> &amp;<span class="fn">allocFragInMap</span>(<br/>

<span class="in2"></span><span class="type">FragMap</span> *<span class="var">map</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>

<span class="in2"></span><span class="var">auto</span> <span class="var">result</span> = <span class="var">map</span>-&gt;<span class="var">map</span>.<span class="fn">insert</span>(<span class="var">std</span>::<span class="var">pair</span>&lt;<span class="var">std</span>::<span class="var">string</span>, <span class="type">Frag</span>&gt;(<br/>

<span class="in3"></span><span class="var">name</span>, <span class="var">name</span><br/>

<span class="in2"></span>));<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="var">result</span>.<span class="var">first</span>-&gt;<span class="var">second</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Ein neues Fragment wird erstellt
</li><li>
 Und in der Hash-Map abgelegt
</li></ul></div>

<div><div>
<code>

<span class="add">@add(<span class="name">define frag</span>)</span><br/>

<span class="in1"></span><span class="type">Frag</span> &amp;<span class="fn">getFragInMap</span>(<br/>

<span class="in2"></span><span class="type">FragMap</span> *<span class="var">map</span>,<br/>

<span class="in2"></span><span class="type">const</span> <span class="var">std</span>::<span class="var">string</span> &amp;<span class="var">name</span>,<br/>

<span class="in2"></span><span class="type">FragMap</span> *<span class="var">insert</span><br/>

<span class="in1"></span>) {<br/>

<span class="in2"></span><span class="expand">@expand(<span class="name">get frag find</span>)</span>;<br/>

<span class="in2"></span><span class="keyword">return</span> <span class="fn">allocFragInMap</span>(<span class="var">map</span>, <span class="var">name</span>);<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">define frag</span>)</span><br/>

</code>
</div>

<ul><li>
 Liefert Fragment mit angegebenen Namen oder legt ein neues Fragment
  mit diesem Namen an
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">get frag find</span>)</span><br/>

<span class="in1"></span><span class="type">Frag</span> *<span class="var">frag</span> = <span class="var">map</span>-&gt;<span class="fn">find</span>(<span class="var">name</span>);<br/>

<span class="in1"></span><span class="keyword">if</span> (<span class="var">frag</span>) {<br/>

<span class="in2"></span><span class="keyword">return</span> *<span class="var">frag</span>;<br/>

<span class="in1"></span>}<br/>

<span class="end">@end(<span class="name">get frag find</span>)</span><br/>

</code>
</div>

<ul><li>
 Wenn das Fragment in der Kollektion vorhanden ist, wird dieses
  verwendet
</li></ul></div>

</div>
<h1>Position im Original merken</h1>
<div class="slides">
<div><div>
<h1>Position im Original merken</h1>
</div>


</div>
<div><div>
<code>

<span class="add">@def(<span class="name">additional entry attributes</span>)</span><br/>

<span class="in1"></span><span class="var">std</span>::<span class="var">string</span> <span class="var">source</span>;<br/>

<span class="in1"></span><span class="type">int</span> <span class="var">line</span>;<br/>

<span class="end">@end(<span class="name">additional entry attributes</span>)</span><br/>

</code>
</div>

<ul><li>
 Jedes Fragment hält einen Zeiger auf die Datei aus der das Fragment
  generiert wurde
</li><li>
 Und die Zeile in dieser Datei
</li><li>
 So kann durch spezielle <code>#line</code> Makros im generierten Source-Code auf
  die ursprüngliche Datei verwiesen werden
</li></ul></div>

<div><div>
<code>

<span class="add">@def(<span class="name">populate additional entry fields</span>)</span><br/>

<span class="in1"></span><span class="var">entry</span>-&gt;<span class="var">source</span> = <span class="var">source</span>;<br/>

<span class="in1"></span><span class="var">entry</span>-&gt;<span class="var">line</span> = <span class="var">line</span>;<br/>

<span class="end">@end(<span class="name">populate additional entry fields</span>)</span><br/>

</code>
</div>

