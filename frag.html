<!doctype html>
<html lang="de"l>
<head>
<meta charset="utf-8">
<title>Fragmente</title><link rel="stylesheet" type="text/css" href="slides/slides.css"></head>
<body>
<h1>Fragmente</h1>
<div class="slides">
<div><div>
<h1>Fragmente</h1>
</div>
<ul><li>
 Fragmente bilden einen gerichteten azyklischen Graph</li><li>
 Die Infix-Traversierung dieses Graphen bildet die generierten
  Source-Code Dateien</li></ul></div>
<div><div>
<code>

<span class="include">@include(<span class="name"><a href="hash.html">hash.x</a>)</span></span><br/>
</code>
</div>
<ul><li>
 Hash-Funktion wird benötigt</li><li>
 Und in der Datei als <code><span class="fn">calcHash</span></code> definiiert</li></ul></div>
<div><div>
<code>

A{global elements}<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">define frag)</span></span>;<br/>

<span class="end">@end(<span class="name">global elements)</span></span><br/>
</code>
</div>
<ul><li>
 Fragmente sind global sichtbare Strukturen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry</span>;<br/>

<br/>
<span class="in1"></span>
<span class="type">struct Frag</span> {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">firstEntry</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">lastEntry</span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">expands</span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">multiples</span>;<br/>
<span class="in2"></span>
<span class="type">char </span><span class="var">name</span><span class="type">[]</span>;<br/>
<span class="in1"></span>
};<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Fragmente erden in einfach verketteten Listen gesammelt</li><li>
 Genauso werden die Einträge eines Fragments in einer einfach
  verketteten Liste organisiert</li><li>
 Um schnell Einträge einfügen zu können, gibt es auch einen Verweis auf
  das letzte Element</li><li>
 Je nach Namen werden für ein Fragment unterschiedlich viele Bytes im
  Heap angefordert</li></ul></div>
<div><div>
<code>

A{includes}<br/>
<span class="in1"></span>
#include &lt;stdlib.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>
</code>
</div>
<ul><li>
 <code>stdlib.h</code> wird für die Definition von <code><span class="keyword">NULL</span></code> benötigt</li></ul></div>
</div>
<h1>Neues Fragment anlegen</h1>
<div class="slides">
<div><div>
<h1>Neues Fragment anlegen</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">allocFrag</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">nameBegin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">nameEnd</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">allocate frag on heap)</span></span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">firstEntry</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">expands</span> = 0;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">multiples</span> = 0;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">copy frag name)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">result</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Die Zeiger werden mit <code><span class="keyword">NULL</span></code> initialisiert</li><li>
 <code><span class="var">lastEntry</span></code> wird erst initialisiert, wenn <code><span class="var">firstEntry</span></code> gesetzt
  wird</li><li>
 Der Name wird über zwei Zeiger übergeben, muss also nicht mit einem
  Null-Byte terminiert sein</li></ul></div>
<div><div>
<code>

D{define logging}<br/>
<span class="in1"></span>
#define ASSERT(<span class="var">COND</span>, ...) \<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! (<span class="var">COND</span>)) { \<br/>
<span class="in3"></span>
<span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>
<span class="in4"></span>
<span class="str">"%s:%d"</span>, \<br/>
<span class="in4"></span>
__FILE__, __LINE__); \<br/>
<span class="in3"></span>
<span class="fn">fprintf</span>(<span class="var">stderr</span>, \<br/>
<span class="in4"></span>
<span class="str">" FAILED: "</span> __VA_ARGS__); \<br/>
<span class="in3"></span>
<span class="fn">fprintf</span>(<span class="var">stderr</span>, <span class="str">"\n"</span>); \<br/>
<span class="in3"></span>
<span class="fn">exit</span>(<span class="var">EXIT_FAILURE</span>); \<br/>
<span class="in2"></span>
}<br/>

<span class="end">@end(<span class="name">define logging)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn Bedingung falsch ist, wird Fehlermeldung ausgegeben</li><li>
 Und das Programm beendet</li><li>
 Datei und Zeile des Tests wird ausgegeben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">allocate frag on heap)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">nameBegin</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">nameBegin</span> &lt;= <span class="var">nameEnd</span>);<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">nameLength</span> =<br/>
<span class="in2"></span>
<span class="var">nameEnd</span> - <span class="var">nameBegin</span>;<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">size</span> = <span class="keyword">sizeof</span>(<span class="type">struct Frag</span>)<br/>
<span class="in2"></span>
+ <span class="var">nameLength</span> + 1;<br/>
<span class="in1"></span>
<span class="var">result</span> = <span class="var">malloc</span>(<span class="var">size</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>

<span class="end">@end(<span class="name">allocate frag on heap)</span></span><br/>
</code>
</div>
<ul><li>
 Die Zeiger werden mit <code><span class="keyword">NULL</span></code> initialisiert</li><li>
 <code><span class="var">lastEntry</span></code> wird erst initialisiert, wenn <code><span class="var">firstEntry</span></code> gesetzt
  wird</li><li>
 Der Name wird über zwei Zeiger übergeben, muss also nicht mit einem
  Null-Byte terminiert sein</li></ul></div>
<div><div>
<code>

A{includes}<br/>
<span class="in1"></span>
#include &lt;string.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>

<br/>

<span class="add">@def(<span class="name">copy frag name)</span></span><br/>
<span class="in1"></span>
<span class="fn">memcpy</span>(<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">name</span>, <span class="var">nameBegin</span>,<br/>
<span class="in2"></span>
<span class="var">nameLength</span><br/>
<span class="in1"></span>
);<br/>
<span class="in1"></span>
<span class="var">result</span>-&gt;<span class="var">name</span>[<span class="var">nameLength</span>] = <span class="str">'\0'</span>;<br/>

<span class="end">@end(<span class="name">copy frag name)</span></span><br/>
</code>
</div>
<ul><li>
 Der Name wird direkt in das Fragment kopiert</li><li>
 Der Name wird mit einem Null-Byte abgeschlossen</li></ul></div>
</div>
<h1>Fragmente freigeben</h1>
<div class="slides">
<div><div>
<h1>Fragmente freigeben</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">freeFragEntries</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">frag</span>) {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">free frag entries)</span></span>;<br/>
<span class="in3"></span>
<span class="var">frag</span>-&gt;<span class="var">firstEntry</span> = <span class="keyword">NULL</span>;<br/>
<span class="in3"></span>
<span class="var">frag</span>-&gt;<span class="var">lastEntry</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">freeFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">f</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">while</span> (<span class="var">f</span>) {<br/>
<span class="in3"></span>
<span class="type">struct Frag *</span><span class="var">l</span> =<br/>
<span class="in4"></span>
<span class="var">f</span>-&gt;<span class="var">link</span>;<br/>
<span class="in3"></span>
freeFragEntries(f);<br/>
<span class="in3"></span>
<span class="fn">free</span>(<span class="var">f</span>);<br/>
<span class="in3"></span>
<span class="var">f</span> = <span class="var">l</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Mit einem Fragment werden auch alle verketteten Fragmente freigegeben</li><li>
 Die Freigabe der einzelnen Einträge wird später definiert
		</li></ul></div>
<div><div>
<code>

A{perform unit-tests}<br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">frag unit tests)</span></span>;<br/>

<span class="end">@end(<span class="name">perform unit-tests)</span></span><br/>

<br/>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">allocTestFrag</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">name</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="fn">allocFrag</span>(<br/>
<span class="in3"></span>
<span class="var">name</span>, <span class="var">name</span> + <span class="fn">strlen</span>(<span class="var">name</span>)<br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Für Unit-Tests gibt es einen einfacheren Konstruktor</li><li>
 Die Länge des Namens wird anhand des Null-Bytes berechnet</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="keyword">void</span> <span class="fn">testFragName</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">name</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">f</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFrag</span>(<span class="var">name</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">f</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">strcmp</span>(<span class="var">f</span>-&gt;<span class="var">name</span>, <span class="var">name</span>) == 0<br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 <code><span class="fn">testFragName</span></code> prüft, ob der Name korrekt in ein Fragment kopiert
  wurde</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
<span class="fn">testFragName</span>(<span class="str">"abc"</span>);<br/>
<span class="in1"></span>
<span class="fn">testFragName</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="fn">testFragName</span>(<span class="str">"A c"</span>);<br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">f</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFrag</span>(<span class="str">"ab"</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">f</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">f</span>-&gt;<span class="var">link</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">f</span>-&gt;<span class="var">firstEntry</span>);<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Zum einen wird getestet, ob die Namen korrekt kopiert werden</li><li>
 Zum anderen wird sichergestellt, dass die Verweise <code><span class="keyword">NULL</span></code> sind</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">bool</span> <span class="fn">isPopulatedFrag</span>(<br/>
<span class="in2"></span>
<span class="type">const struct Frag *</span><span class="var">f</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
return f &amp;&amp; f-&gt;firstEntry;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
</div>
</div>
<h1>Fragment-Einträge</h1>
<div class="slides">
<div><div>
<h1>Fragment-Einträge</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry</span> {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>;<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueEnd</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">additional entry attributes)</span></span>;<br/>
<span class="in2"></span>
<span class="type">char </span><span class="var">value</span><span class="type">[]</span>;<br/>
<span class="in1"></span>
};<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Eintrag kann entweder auf ein anderes Fragment verweisen (wenn
  dieses an der aktuellen Stelle expandiert werden soll)</li><li>
 Oder er enthält Bytes, die beim Expandieren direkt expandiert werden</li><li>
 Die Länge des Byte-Arrays wird über einen Zeiger angezeigt (damit auch
  Null-Bytes verwendet werden können)</li><li>
 Wenn ein Eintrag sowohl Daten als auch ein Fragment enthält, so wird
  zuerst der Text ausgegeben
		</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="fn">allocFragEntry</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueBegin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueEnd</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">result</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">allocate entry on heap)</span></span>;<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">copy entry values)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">result</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Wie bei einem Fragment werden die <code><span class="var">link</span></code> Verweise auf <code><span class="keyword">NULL</span></code>
  initialisiert</li><li>
 Sowohl <code><span class="var">frag</span></code> als auch <code><span class="var">valueBegin</span></code> sind optional</li><li>
 Die Größe des Eintrags hängt von der Anzahl der Bytes ab, die kopiert
  werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">allocate entry on heap)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">valueLength</span> = 0;<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">valueBegin</span> &lt;= <span class="var">valueEnd</span>);<br/>
<span class="in2"></span>
<span class="var">valueLength</span> =<br/>
<span class="in3"></span>
<span class="var">valueEnd</span> - <span class="var">valueBegin</span>;<br/>
<span class="in1"></span>
}<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">entrySize</span> = <span class="var">valueLength</span> +<br/>
<span class="in2"></span>
<span class="keyword">sizeof</span>(<span class="type">struct FragEntry</span>);<br/>
<span class="in1"></span>
<span class="var">result</span> = <span class="var">malloc</span>(<span class="var">entrySize</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">result</span>);<br/>

<span class="end">@end(<span class="name">allocate entry on heap)</span></span><br/>
</code>
</div>
<ul><li>
 Die Größe der Struktur wird um die Anzahl der zu kopierenden Bytes
  vergrößert</li><li>
 Wenn nicht genug Speicher vorhanden ist, dann wird das Programm beendet</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">copy entry values)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">valueBegin</span>) {<br/>
<span class="in2"></span>
<span class="fn">memcpy</span>(<br/>
<span class="in3"></span>
<span class="var">result</span>-&gt;<span class="var">value</span>, <span class="var">valueBegin</span>,<br/>
<span class="in3"></span>
<span class="var">valueLength</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>
<span class="in1"></span>
<span class="var">result</span>-&gt;<span class="var">valueEnd</span> =<br/>
<span class="in2"></span>
<span class="var">result</span>-&gt;<span class="var">value</span> + <span class="var">valueLength</span>;<br/>
<span class="in1"></span>
<span class="var">result</span>-&gt;<span class="var">frag</span> = <span class="var">frag</span>;<br/>

<span class="end">@end(<span class="name">copy entry values)</span></span><br/>
</code>
</div>
<ul><li>
 Die Bytes werden nur kopiert, wenn welche übergeben wurden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>

<span class="type">struct FragEntry *</span><br/>

<span class="fn">allocEmptyFragEntry</span>() {<br/>
<span class="in1"></span>
<span class="keyword">return</span> <span class="fn">allocFragEntry</span>(<br/>
<span class="in2"></span>
<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span><br/>
<span class="in1"></span>
);<br/>

}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Für Tests ist es praktisch, leere Einträge anzulegen</li></ul></div>
</div>
<h1>Fragment-Einträge freigeben</h1>
<div class="slides">
<div><div>
<h1>Fragment-Einträge freigeben</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>

<span class="keyword">void</span> <span class="fn">freeFragEntry</span>(<br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">e</span><br/>

) {<br/>
<span class="in1"></span>
<span class="keyword">while</span> (<span class="var">e</span>) {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">l</span> =<br/>
<span class="in3"></span>
<span class="var">e</span>-&gt;<span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="fn">free</span>(<span class="var">e</span>);<br/>
<span class="in2"></span>
<span class="var">e</span> = <span class="var">l</span>;<br/>
<span class="in1"></span>
}<br/>

}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn ein Eintrag freigegeben wird, so werden auch alle verlinkten
  Einträge freigegeben</li><li>
 Referenzierte Fragmente werden nicht mit freigegeben</li></ul></div>
<div><div>
<code>

D{forward declarations}<br/>

<span class="type">struct FragEntry</span>;<br/>

<span class="keyword">void</span> <span class="fn">freeFragEntry</span>(<br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span><br/>

);<br/>

<span class="end">@end(<span class="name">forward declarations)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">free frag entries)</span></span><br/>
<span class="in1"></span>
<span class="fn">freeFragEntry</span>(<span class="var">frag</span>-&gt;<span class="var">firstEntry</span>);<br/>

<span class="end">@end(<span class="name">free frag entries)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn ein Fragment freigegeben wird, so werden auch die anhängenden
  Einträge freigegeben</li><li>
 Damit die Funktion im <code><span class="fn">freeFrag</span></code> sichtbar ist, wird sie in der
  Include-Sektion definiert</li></ul></div>
</div>
<h1>Auf Attribute zugreifen</h1>
<div class="slides">
<div><div>
<h1>Auf Attribute zugreifen</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="keyword">int</span> <span class="fn">getFragEntryValueSize</span>(<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">e</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="var">e</span>) {<br/>
<span class="in3"></span>
<span class="keyword">return</span> <span class="num">0</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">e</span>-&gt;<span class="var">valueEnd</span> -<br/>
<span class="in3"></span>
<span class="var">e</span>-&gt;<span class="var">value</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Liefert die Anzahl der enthaltenen Bytes</li></ul></div>
</div>
<h1>Unit Tests</h1>
<div class="slides">
<div><div>
<h1>Unit Tests</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">frag</span>);<br/>

<br/>
<span class="in2"></span>
<span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Ein leerer Eintrag hat keinen Nachfolger</li><li>
 Und kein Fragment</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">getFragEntryValueSize</span>(<br/>
<span class="in4"></span>
<span class="var">entry</span>) == <span class="num">0);</span><br/>

<br/>
<span class="in2"></span>
<span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Ein leerer Eintrag hat keine Bytes</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><br/>
<span class="in1"></span>
<span class="fn">allocTestFragEntry</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">v</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">e</span> = <span class="var">v</span> +<br/>
<span class="in3"></span>
<span class="fn">strlen</span>(<span class="var">v</span>);<br/>

<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="fn">allocFragEntry</span>(<br/>
<span class="in3"></span>
<span class="keyword">NULL</span>, <span class="var">v</span>, <span class="var">e</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Der Test-Konstruktor bekommt eine Null-terminierte Zeichenkette als
  Argument</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFragEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">getFragEntryValueSize</span>(<br/>
<span class="in4"></span>
<span class="var">entry</span>) == <span class="num">3);</span><br/>

<br/>
<span class="in2"></span>
<span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Eintrag hat die korrekte Anzahl an Bytes</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFragEntry</span>(<span class="str">"abc"</span>);<br/>

<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="fn">memcmp</span>(<span class="var">entry</span>-&gt;<span class="var">value</span>,<br/>
<span class="in4"></span>
<span class="str">"abc"</span>, <span class="num">3</span>) == <span class="num">0);</span><br/>

<br/>
<span class="in2"></span>
<span class="fn">freeFragEntry</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Die Bytes eines Eintrags stimmen überein</li></ul></div>
</div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
<div class="slides">
<div><div>
<h1>Einträge zu Fragmenten hinzufügen</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addEntryToFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>,<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">assert add entry)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">frag</span>-&gt;<span class="var">firstEntry</span>) {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">append entry)</span></span>;<br/>
<span class="in2"></span>
} <span class="keyword">else</span> {<br/>
<span class="in3"></span>
<span class="expand">@expand(<span class="name">set first entry)</span></span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Eintrag wird entweder an das Ende der Liste der Einträge angehängt</li><li>
 Oder als neuer Kopf der Liste gesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">assert add entry)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">entry</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(! <span class="var">entry</span>-&gt;<span class="var">link</span>);<br/>

<span class="end">@end(<span class="name">assert add entry)</span></span><br/>
</code>
</div>
<ul><li>
 Fragment darf nicht <code><span class="keyword">NULL</span></code> sein</li><li>
 Eintrag darf nicht <code><span class="keyword">NULL</span></code> sein</li><li>
 Eintrag darf noch nicht in einer anderen Liste hängen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">append entry)</span></span><br/>
<span class="in1"></span>
<span class="var">frag</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">link</span> = <span class="var">entry</span>;<br/>
<span class="in1"></span>
<span class="var">frag</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>

<span class="end">@end(<span class="name">append entry)</span></span><br/>
</code>
</div>
<ul><li>
 Da es schon Einträge gibt, muss es bereits einen letzten geben</li><li>
 Dessen neuer Nachfolger ist der neue Eintrag</li><li>
 Der neue Eintrag wird zum neuen letzten Eintrag</li><li>
 Der Nachfolger von <code><span class="var">entry</span></code> ist bereits <code><span class="keyword">NULL</span></code></li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">set first entry)</span></span><br/>
<span class="in1"></span>
<span class="var">frag</span>-&gt;<span class="var">firstEntry</span> = <span class="var">entry</span>;<br/>
<span class="in1"></span>
<span class="var">frag</span>-&gt;<span class="var">lastEntry</span> = <span class="var">entry</span>;<br/>

<span class="end">@end(<span class="name">set first entry)</span></span><br/>
</code>
</div>
<ul><li>
 Der erste Eintrag wird auch als letzter Eintrag gesetzt</li><li>
 Der Nachfolger von <code><span class="var">entry</span></code> ist bereits <code><span class="keyword">NULL</span></code></li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">f</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">e</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyFragEntry</span>();<br/>
<span class="in2"></span>
<span class="fn">addEntryToFrag</span>(<span class="var">f</span>, <span class="var">e</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="var">f</span>-&gt;<span class="var">firstEntry</span> == <span class="var">e</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Der erste Eintrag im Fragment wird gesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">f</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">e</span> =<br/>
<span class="in3"></span>
<span class="fn">allocEmptyFragEntry</span>();<br/>
<span class="in2"></span>
<span class="fn">addEntryToFrag</span>(<span class="var">f</span>, <span class="var">e</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="var">f</span>-&gt;<span class="var">lastEntry</span> == <span class="var">e</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">f</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Der letzte Eintrag im Fragment wird gesetzt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">first</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">second</span>;<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">add two entries)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check first of 2)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">frag</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Zwei Einträge werden an ein Fragment angehängt</li><li>
 Der erste Eintrag muss gesetzt bleiben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">add two entries)</span></span><br/>
<span class="in1"></span>
<span class="var">frag</span> = <span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="var">first</span> = <span class="fn">allocEmptyFragEntry</span>();<br/>
<span class="in1"></span>
<span class="var">second</span> = <span class="fn">allocEmptyFragEntry</span>();<br/>

<br/>
<span class="in1"></span>
<span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">first</span>);<br/>
<span class="in1"></span>
<span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">second</span>);<br/>

<span class="end">@end(<span class="name">add two entries)</span></span><br/>

<br/>

<span class="add">@def(<span class="name">check first of 2)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="var">frag</span>-&gt;<span class="var">firstEntry</span> == <span class="var">first</span>);<br/>

<span class="end">@end(<span class="name">check first of 2)</span></span><br/>
</code>
</div>
<ul><li>
 Zwei Einträge werden an ein Fragment angehängt</li><li>
 Der erste Eintrag muss gesetzt bleiben</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">first</span>;<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">second</span>;<br/>
<span class="in2"></span>
<span class="expand">@multiple(<span class="name">add two entries)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<br/>
<span class="in3"></span>
<span class="var">frag</span>-&gt;<span class="var">lastEntry</span> == <span class="var">second</span><br/>
<span class="in2"></span>
);<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">frag</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Zwei Einträge werden an ein Fragment angehängt</li><li>
 Der letzte Eintrag muss gesetzt werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addBytesToFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">value</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">valueEnd</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">source</span>,<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">line</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in3"></span>
<span class="fn">allocFragEntry</span>(<br/>
<span class="in4"></span>
<span class="keyword">NULL</span>, <span class="var">value</span>, <span class="var">valueEnd</span><br/>
<span class="in3"></span>
);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">populate additional entry fields)</span></span>;<br/>
<span class="in2"></span>
<span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">entry</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Für die Daten wird ein neuer Eintrag angelegt</li><li>
 Dieser wird an das Fragment angehängt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">define cycle check)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addFragToFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>,<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">child</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">child</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">avoid frag cycles)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">reuse last entry)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">add frag entry)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Bevor ein Fragment hinzugefügt werden kann, muss sichergestellt werden,
  dass kein Zykel entsteht</li><li>
 Ein Zykel liegt vor, wenn <code><span class="var">frag</span></code> gleich <code><span class="var">child</span></code> ist</li><li>
 Oder bereits direkt oder indirekt zu <code><span class="var">child</span></code> hinzugefügt wurde</li><li>
 Falls der letzte Eintrag noch kein Fragment hat, wird dieser Eintrag
  verwendet</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">reuse last entry)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">frag</span>-&gt;<span class="var">firstEntry</span> &amp;&amp;<br/>
<span class="in2"></span>
! <span class="var">frag</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">frag</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="var">frag</span>-&gt;<span class="var">lastEntry</span>-&gt;<span class="var">frag</span> = <span class="var">child</span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">reuse last entry)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn das Fragment-Attribut im letzten Eintrag noch nicht benutzt wird,
  kann dieses verwendet werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">add frag entry)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in2"></span>
<span class="fn">allocFragEntry</span>(<br/>
<span class="in3"></span>
<span class="var">child</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
<span class="fn">addEntryToFrag</span>(<span class="var">frag</span>, <span class="var">entry</span>);<br/>

<span class="end">@end(<span class="name">add frag entry)</span></span><br/>
</code>
</div>
<ul><li>
 Sonst muss ein neuer Eintrag in dem Fragment angelegt werden</li></ul></div>
</div>
<h1>Fragmente serialisieren</h1>
<div class="slides">
<div><div>
<h1>Fragmente serialisieren</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="expand">@expand(<span class="name">serialize test defines)</span></span>;<br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">serializeFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>,<br/>
<span class="in2"></span>
<span class="type">FILE *</span><span class="var">out</span>,<br/>
<span class="in2"></span>
<span class="type">bool</span> <span class="var">writeLineMacros</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">frag</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">out</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">iterate entries)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Jeder Eintrag wird nacheinander bearbeitet</li><li>
 Fragmente in Einträgen werden rekursiv ausgegeben</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">iterate entries)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in2"></span>
<span class="var">frag</span>-&gt;<span class="var">firstEntry</span>;<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">serialize bytes)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">entry</span>-&gt;<span class="var">frag</span>) {<br/>
<span class="in3"></span>
<span class="fn">serializeFrag</span>(<br/>
<span class="in4"></span>
<span class="var">entry</span>-&gt;<span class="var">frag</span>, <span class="var">out</span>,<br/>
<span class="in4"></span>
<span class="var">writeLineMacros</span><br/>
<span class="in3"></span>
);<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">iterate entries)</span></span><br/>
</code>
</div>
<ul><li>
 Für jeden Eintrag werden zuerst die Bytes ausgegeben</li><li>
 Dann wird rekursiv das Fragment ausgegeben, falls vorhanden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize test defines)</span></span><br/>
<span class="in1"></span>
<span class="type">char *</span><span class="var">fragTestBufferCur</span> = <span class="keyword">NULL</span>;<br/>
<span class="in1"></span>
<span class="type">const char *</span><span class="var">fragTestBufferEnd</span> = <span class="keyword">NULL</span>;<br/>

<span class="end">@end(<span class="name">serialize test defines)</span></span><br/>
</code>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize bytes)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="fn">getFragEntryValueSize</span>(<span class="var">entry</span>)) {<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">cur</span> = <span class="var">entry</span>-&gt;<span class="var">value</span>;<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span> = <span class="var">entry</span>-&gt;<span class="var">valueEnd</span>;<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">len</span> = <span class="var">end</span> - <span class="var">cur</span>;<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="var">fragTestBufferCur</span>) {<br/>
<span class="in3"></span>
<span class="fn">ASSERT</span>(<span class="fn">fwrite</span>(<span class="var">cur</span>, 1, <span class="var">len</span>, <span class="var">out</span>) == <span class="var">len</span>);<br/>
<span class="in2"></span>
} <span class="keyword">else</span> {<br/>
<span class="in3"></span>
<span class="fn">ASSERT</span>(<span class="var">fragTestBufferCur</span> + <span class="var">len</span> &lt; <span class="var">fragTestBufferEnd</span>);<br/>
<span class="in3"></span>
<span class="fn">memcpy</span>(<span class="var">fragTestBufferCur</span>, <span class="var">cur</span>, <span class="var">len</span>);<br/>
<span class="in3"></span>
<span class="var">fragTestBufferCur</span> += <span class="var">len</span>;<br/>
<span class="in3"></span>
*<span class="var">fragTestBufferCur</span> = <span class="str">'\0'</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">serialize bytes)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn es Bytes in dem Eintrag gibt, wird der <code><span class="var">consumer</span></code> mit ihnen
  aufgerufen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">testFrag</span>(<span class="type">struct Frag *</span><br/>
<span class="in2"></span>
<span class="var">frag</span>, <span class="type">const char *</span><span class="var">expected</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">serialize test frag)</span></span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Diese Hilfsfunktion prüft ob die Serialisierung eines Fragments der
  Erwartung entspricht</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">serialize test frag)</span></span><br/>
<span class="in1"></span>
char buffer[100];<br/>
<span class="in1"></span>
fragTestBufferCur = buffer;<br/>
<span class="in1"></span>
fragTestBufferEnd = buffer + sizeof(buffer);<br/>
<span class="in1"></span>
<span class="fn">serializeFrag</span>(<span class="var">frag</span>, (void *) buffer, <span class="keyword">false</span>);<br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(<span class="fn">strcmp</span>(<br/>
<span class="in2"></span>
<span class="var">expected</span>, <span class="var">buffer</span><br/>
<span class="in1"></span>
) == 0);<br/>
<span class="in1"></span>
fragTestBufferCur = NULL;<br/>
<span class="in1"></span>
fragTestBufferEnd = NULL;<br/>

<span class="end">@end(<span class="name">serialize test frag)</span></span><br/>
</code>
</div>
<ul><li>
 Serialisiert das Fragment</li><li>
 Der Buffer muss die erwarteten Werte enthalten</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">addStringToFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">str</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">size</span> = <span class="fn">strlen</span>(<span class="var">str</span>);<br/>
<span class="in2"></span>
<span class="fn">addBytesToFrag</span>(<br/>
<span class="in3"></span>
<span class="var">frag</span>, <span class="var">str</span>, <span class="var">str</span> + <span class="var">size</span>,<br/>
<span class="in3"></span>
<span class="keyword">NULL</span>, <span class="num">0</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Zu Testzwecken kann eine Null-terminierte Zeichenkette hinzugefügt
  werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span><br/>
<span class="in1"></span>
{<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span> =<br/>
<span class="in3"></span>
<span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>
<span class="in2"></span>
<span class="fn">addStringToFrag</span>(<span class="var">frag</span>, <span class="str">"abc"</span>);<br/>
<span class="in2"></span>
<span class="fn">addStringToFrag</span>(<span class="var">frag</span>, <span class="str">"def"</span>);<br/>
<span class="in2"></span>
<span class="fn">testFrag</span>(<span class="var">frag</span>, <span class="str">"abcdef"</span>);<br/>
<span class="in2"></span>
<span class="fn">freeFrag</span>(<span class="var">frag</span>);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Prüft, ob zwei Strings richtig serialisiert werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">frag unit tests)</span></span> {<br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="var">a</span> =<br/>
<span class="in2"></span>
<span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="var">b</span> =<br/>
<span class="in2"></span>
<span class="fn">allocTestFrag</span>(<span class="str">""</span>);<br/>
<span class="in1"></span>
<span class="fn">addStringToFrag</span>(<span class="var">a</span>, <span class="str">"abc"</span>);<br/>
<span class="in1"></span>
<span class="fn">addFragToFrag</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>
<span class="in1"></span>
<span class="fn">addStringToFrag</span>(<span class="var">b</span>, <span class="str">"def"</span>);<br/>
<span class="in1"></span>
<span class="fn">addFragToFrag</span>(<span class="var">b</span>, <span class="var">a</span>);<br/>
<span class="in1"></span>
<span class="fn">testFrag</span>(<span class="var">b</span>, <span class="str">"abcdefabc"</span>);<br/>
<span class="in1"></span>
<span class="fn">freeFrag</span>(<span class="var">a</span>); <span class="fn">freeFrag</span>(<span class="var">b</span>);<br/>

} <span class="end">@end(<span class="name">frag unit tests)</span></span><br/>
</code>
</div>
<ul><li>
 Prüft, ob Fragmente expandiert werden</li></ul></div>
</div>
<h1>Zykel im Fragment-Graph finden</h1>
<div class="slides">
<div><div>
<h1>Zykel im Fragment-Graph finden</h1>
</div>
</div>
<div><div>
<code>

A{includes}<br/>
<span class="in1"></span>
#include &lt;stdbool.h&gt;<br/>

<span class="end">@end(<span class="name">includes)</span></span><br/>
</code>
</div>
<ul><li>
 Boolesche Datenwerte werden benötigt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">define cycle check)</span></span><br/>
<span class="in1"></span>
<span class="type">bool</span> <span class="fn">isFragInFrag</span>(<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">needle</span>,<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">haystack</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">needle</span>);<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">haystack</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check cycle frag)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">check cycle entries)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="keyword">false</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define cycle check)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn das Fragment das gesuchte ist, dann wurde ein Zykel gefunden</li><li>
 Danach wird über alle Einträge gesucht</li><li>
 Wenn das Fragment dort nicht gefunden wurde, dann ist es nicht
  enthalten</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">avoid frag cycles)</span></span><br/>
<span class="in1"></span>
<span class="fn">ASSERT</span>(! <span class="fn">isFragInFrag</span>(<br/>
<span class="in2"></span>
<span class="var">frag</span>, <span class="var">child</span><br/>
<span class="in1"></span>
));<br/>

<span class="end">@end(<span class="name">avoid frag cycles)</span></span><br/>
</code>
</div>
<ul><li>
 Ein Fragment darf nur hinzugefügt werden, wenn es den Container nicht
  bereits enthält</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">check cycle frag)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">needle</span> == <span class="var">haystack</span>) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="keyword">true</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">check cycle frag)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn der Container selbst das gesuchte Fragment ist, liefert die
  Funktion <code><span class="keyword">true</span></code> zurück</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">check cycle entries)</span></span><br/>
<span class="in1"></span>
<span class="type">struct FragEntry *</span><span class="var">entry</span> =<br/>
<span class="in2"></span>
<span class="var">haystack</span>-&gt;<span class="var">firstEntry</span>;<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">entry</span>; <span class="var">entry</span> = <span class="var">entry</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="keyword">if</span> (! <span class="var">entry</span>-&gt;<span class="var">frag</span>) { <span class="keyword">continue</span>; }<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="fn">isFragInFrag</span>(<br/>
<span class="in3"></span>
<span class="var">needle</span>, <span class="var">entry</span>-&gt;<span class="var">frag</span><br/>
<span class="in2"></span>
)) {<br/>
<span class="in3"></span>
<span class="keyword">return</span> <span class="keyword">true</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">check cycle entries)</span></span><br/>
</code>
</div>
<ul><li>
 Alle Fragment in den Einträgen werden rekursiv untersucht</li><li>
 Damit wird der ganze Graph durchsucht</li></ul></div>
</div>
<h1>Fragment-Kollektion</h1>
<div class="slides">
<div><div>
<h1>Fragment-Kollektion</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
#define FRAG_SLOTS 128<br/>

<br/>
<span class="in1"></span>
<span class="type">struct FragMap</span> {<br/>
<span class="in2"></span>
<span class="type">struct FragMap *</span><span class="var">link</span>;<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frags</span><span class="type">[</span><br/>
<span class="in3"></span>
<span class="type">FRAG_SLOTS</span><br/>
<span class="in2"></span>
<span class="type">]</span>;<br/>
<span class="in1"></span>
};<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Eine Kollektion von Fragmenten ist ein Array von Fragment-Ketten</li><li>
 Alle Felder müssen mit <code><span class="keyword">NULL</span></code> initialisiert werden</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">void</span> <span class="fn">clearFragMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct FragMap *</span><span class="var">map</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag **</span><span class="var">cur</span> = <span class="var">map</span>-&gt;<span class="var">frags</span>;<br/>
<span class="in2"></span>
<span class="type">struct Frag **</span><span class="var">end</span> =<br/>
<span class="in3"></span>
<span class="var">cur</span> + <span class="var">FRAG_SLOTS</span>;<br/>
<span class="in2"></span>
<span class="keyword">for</span> (; <span class="var">cur</span> &lt; <span class="var">end</span>; ++<span class="var">cur</span>) {<br/>
<span class="in3"></span>
<span class="fn">freeFrag</span>(*<span class="var">cur</span>); *<span class="var">cur</span> = <span class="keyword">NULL</span>;<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="var">map</span>-&gt;<span class="var">link</span> = <span class="keyword">NULL</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Um den Speicher freizugeben, wird jeder Slot gelöscht</li><li>
 und auf &lt;code class="keyword"&gt;NULL&lt;/code&gt; gesetzt um wieder verwendet
  zu werden</li><li>
 Wenn es einen Link auf ein andere Map gibt, wird diese zurückgesetzt</li><li>
 Die referenzierte Map wird jedoch nicht gelöscht</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="fn">calcFragHash</span>(<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>, <span class="type">const char *</span><span class="var">end</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">hash</span> % <span class="var">FRAG_SLOTS</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Der Hash wird über den Namen des Fragments erstellt</li><li>
 Und auf die Anzahl der möglichen Slots beschränkt</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">allocFragInMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct FragMap *</span><span class="var">map</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span> =<br/>
<span class="in3"></span>
<span class="fn">allocFrag</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">insert in slot)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">frag</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Ein neues Fragment wird erstellt</li><li>
 Und in der Hash-Map abgelegt</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">insert in slot)</span></span><br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcFragHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in1"></span>
<span class="var">frag</span>-&gt;<span class="var">link</span> = <span class="var">map</span>-&gt;<span class="var">frags</span>[<span class="var">hash</span>];<br/>
<span class="in1"></span>
<span class="var">map</span>-&gt;<span class="var">frags</span>[<span class="var">hash</span>] = <span class="var">frag</span>;<br/>

<span class="end">@end(<span class="name">insert in slot)</span></span><br/>
</code>
</div>
<ul><li>
 Fragment wird im Slot eingefügt</li><li>
 Neue Fragmente überlagern alte Fragmente mit gleichem Namen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">findFragInMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct FragMap *</span><span class="var">map</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="fn">ASSERT</span>(<span class="var">map</span>);<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">find frag in slot)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">find frag in linked map)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="keyword">NULL</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Liefert das erste Fragment mit dem übergebenen Namen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">find frag in slot)</span></span> {<br/>
<span class="in1"></span>
<span class="type">int</span> <span class="var">hash</span> = <span class="fn">calcFragHash</span>(<span class="var">begin</span>, <span class="var">end</span>);<br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="var">frag</span> = <span class="var">map</span>-&gt;<span class="var">frags</span>[<span class="var">hash</span>];<br/>
<span class="in1"></span>
<span class="keyword">for</span> (; <span class="var">frag</span>; <span class="var">frag</span> = <span class="var">frag</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">a</span> = <span class="var">begin</span>;<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">b</span> = <span class="var">frag</span>-&gt;<span class="var">name</span>;<br/>
<span class="in2"></span>
<span class="keyword">while</span> (<span class="var">a</span> != <span class="var">end</span>) {<br/>
<span class="in3"></span>
<span class="keyword">if</span> (*<span class="var">a</span>++ != *<span class="var">b</span>++) { <span class="keyword">break</span>; }<br/>
<span class="in2"></span>
}<br/>
<span class="in2"></span>
<span class="keyword">if</span> (<span class="var">a</span> == <span class="var">end</span> &amp;&amp; ! *<span class="var">b</span>) {<br/>
<span class="in3"></span>
<span class="keyword">return</span> <span class="var">frag</span>; }<br/>
<span class="in1"></span>
}<br/>

} <span class="end">@end(<span class="name">find frag in slot)</span></span><br/>
</code>
</div>
<ul><li>
 Im passenden Hash-Slot werden die Namen der Fragmente verglichen</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">find frag in linked map)</span></span><br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">map</span>-&gt;<span class="var">link</span>) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="fn">findFragInMap</span>(<br/>
<span class="in3"></span>
<span class="var">map</span>-&gt;<span class="var">link</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
<span class="in2"></span>
);<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">find frag in linked map)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn es einen verlinkten Kontext gibt, so kann das Element auch in
  diesem liegen</li></ul></div>
<div><div>
<code>

<span class="add">@add(<span class="name">define frag)</span></span><br/>
<span class="in1"></span>
<span class="type">struct Frag *</span><span class="fn">getFragInMap</span>(<br/>
<span class="in2"></span>
<span class="type">struct FragMap *</span><span class="var">map</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">begin</span>,<br/>
<span class="in2"></span>
<span class="type">const char *</span><span class="var">end</span>,<br/>
<span class="in2"></span>
<span class="type">struct FragMap *</span><span class="var">insert</span><br/>
<span class="in1"></span>
) {<br/>
<span class="in2"></span>
<span class="type">struct Frag *</span><span class="var">frag</span> = NULL;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">get frag find)</span></span>;<br/>
<span class="in2"></span>
<span class="expand">@expand(<span class="name">get frag alloc)</span></span>;<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">frag</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">define frag)</span></span><br/>
</code>
</div>
<ul><li>
 Liefert Fragment mit angegebenen Namen oder legt ein neues Fragment
  mit diesem Namen an</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">get frag find)</span></span><br/>
<span class="in1"></span>
<span class="var">frag</span> = <span class="fn">findFragInMap</span>(<br/>
<span class="in2"></span>
<span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
<span class="in1"></span>
);<br/>
<span class="in1"></span>
<span class="keyword">if</span> (<span class="var">frag</span>) {<br/>
<span class="in2"></span>
<span class="keyword">return</span> <span class="var">frag</span>;<br/>
<span class="in1"></span>
}<br/>

<span class="end">@end(<span class="name">get frag find)</span></span><br/>
</code>
</div>
<ul><li>
 Wenn das Fragment in der Kollektion vorhanden ist, wird dieses
  verwendet</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">get frag alloc)</span></span><br/>
<span class="in1"></span>
<span class="var">frag</span> = <span class="fn">allocFragInMap</span>(<br/>
<span class="in2"></span>
<span class="var">map</span>, <span class="var">begin</span>, <span class="var">end</span><br/>
<span class="in1"></span>
);<br/>

<span class="end">@end(<span class="name">get frag alloc)</span></span><br/>
</code>
</div>
<ul><li>
 Sonst wird ein neues Fragment angelegt</li></ul></div>
</div>
<h1>Position im Original merken</h1>
<div class="slides">
<div><div>
<h1>Position im Original merken</h1>
</div>
</div>
<div><div>
<code>

<span class="add">@def(<span class="name">additional entry attributes)</span></span><br/>
<span class="in1"></span>
const char *source;<br/>
<span class="in1"></span>
int line;<br/>

<span class="end">@end(<span class="name">additional entry attributes)</span></span><br/>
</code>
</div>
<ul><li>
 Jedes Fragment hält einen Zeiger auf die Datei aus der das Fragment
  generiert wurde</li><li>
 Und die Zeile in dieser Datei</li><li>
 So kann durch spezielle <code>#line</code> Makros im generierten Source-Code auf
  die ursprüngliche Datei verwiesen werden</li></ul></div>
<div><div>
<code>

<span class="add">@def(<span class="name">populate additional entry fields)</span></span><br/>
<span class="in1"></span>
<span class="var">entry</span>-&gt;<span class="var">source</span> = <span class="var">source</span>;<br/>
<span class="in1"></span>
<span class="var">entry</span>-&gt;<span class="var">line</span> = <span class="var">line</span>;<br/>

<span class="end">@end(<span class="name">populate additional entry fields)</span></span><br/>
</code>
</div>
